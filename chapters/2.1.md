# 1. Angular2总览
前述篇节已经描绘了新版Angular的大图景，包括其历史发展以及周边生态，简单介绍了Angular的一些核心概念，接下来的本书第二篇将回归Angular框架本身，开始深入讲解Angular的技术细节。

Angular的重写多少会给社区带来了不便，好在Angular团队在无缝升级方面下了不少功夫，但更重要的是重写能让Angular抛掉老版的包袱，采用新的架构更加贴合新时代前端的发展趋势，如基于组件的设计，响应式编程等，除此之外，新版Angular代码更简洁易读且性能更高，且拥有更多优秀特性，如更好地适配Mobile应用（Mobile Toolkit，离线编译），支持服务端渲染等，这些新特性的加入使得Angular能更加从容地适应未来越来越复杂的客户端应用场景。

所以，新版Angular更具吸引力，也更容易快速上手，本篇节也将不再复述老版Angularjs的一些相关概念，从零开始带大家进入新版Angular的学习。本章先从总览的角度去分析Angular的核心组成，慢慢揭开Angular的神秘面纱（下称Angular均指新版）。

## 1.1 基于组件的设计

Angular框架基于组件设计，其应用由一系列大大小小的松耦合的组件组成，我们谈及组件，到底组件意味着什么？在上一篇节介绍的通讯录Demo里，运行效果图大概会是下面这个样子：

![](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapter2-1/cmp.png)

图 2.1-1

所有框起来的部分均称为组件，并且这些组件层层嵌套，自上而下构成组件树。如最外层的方框为根组件，包含了Header、ContactList以及Footer三个子组件，其中ContactList又有自己的子组件，如图2.1-2所示的树状图：

![](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapter2-1/cmp-tree.png)

图 2.1-2 组件树

树状结构的组件关系意味着每个组件并不是孤立的存在，父子组件之间存在着双向的数据流动，要理解数据是怎样流动的？首先要了解组件间调用方式。简单说，Angular的组件外在形态就是自定义标签，所以组件间的调用的实际体现在于模板标签的引用。如下`Contact`组件的代码片段：

```
@Component({
  selector: 'contact',
  template: '<div>{{item.name}}</div>' // 省略部分内容
})
export class ContactComponent {
  @Input() item: Contact;
  @Output() update: EventEmitter;
  constructor() { }
  // ...
```

`item`和`update`即是子组件`Contact`对外暴露的接口，`item`接口用来接收来自父组件的数据源输入，当`Contact`组件发生数据变动时，通过`update`接口通知父组件更新数据。上述代码定义`Contact`组件的标签形态是`<contact></contact>`，父组件`ContactList`组件的模板里可以这样引入`Contact`组件：

```
<contact [item]="listItem" (update)="doUpdate(newItem)"></contact>
```

`listItem`和`doUpdate`是父组件`ContactList`的成员属性，父子组件之间通过类似于HTML属性的方式传递数据，其中`[item]="listItem"`称为属性绑定，数据从父组件流向子组件，`(update)="doUpdate(newItem)"`称为事件绑定，数据从子组件流向父组件。

![](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapter2-1/cmp-data-flow.png)

图 2.1-3 父子组件间的数据流动

细心的读者可能已经发现，Angular的模板是可以直接引用组件里的成员属性，如`listItem`和`doUpdate`，抽取`ContactList`代码片段：
```
@Component({
  selector: 'contact-list',
  template: '...'
})
export class ContactListComponent {
  constructor() { }
  listItem: IContact[],
  doUpdate(item: IContact) {
    // ...
  }
}
```

组件类和模板之间的数据交互称为数据绑定，前面所说的属性绑定和数据绑定也属于数据绑定的范畴，属性绑定和事件绑定即可用于父子组件的数据传递，也可用于组件数据模型和模板视图之前的数据传递。在父子组件通信的机理中，模板充当类似于桥梁的角色，连接着二者的功能逻辑。

![](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapter2-1/cmp-data-flow-all.png)

图 2.1-4 数据流动

这就是Angular的数据流动机制，但流动并不是自发形成，世间万物皆如此，事物的流动需要一个驱动力，这就是Angular的变化监测机制。Angular是一个响应式系统，每个组件背后都维护着一个独立的变化监测器，当监测到有数据变化后，触发的变化事件以深度优先原则在组件树里自顶向下传播，并且引入Immutable和Observable机制使得整个监测过程非常高效。

另外，Angular监控对象的变动并非通过getter/setter实现，而是在适当的时机校验对象值是否被改动，校验的时机选择是结合Zones判断，通常是用户点击事件，或异步数据的回调触发等。

![](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapter2-1/cd-zones.png)

图 2.1-5 变化检测

变化监测机制使得应用开发者不必关心数据何时变动，结合数据绑定还实现了模板数据实时更新，若此时需要针对数据的变动做一些额外处理，可以么？答案是肯定的。Angular提供了完善的生命周期钩子给开发者调用，如`ngOnChanges`可以捕获变化监控事件，又如`ngOnDestroy`可以在组件销毁前做一些清理工作，等等。

这就是组件的概况，。。。

## 1.2 其他组成部分

组件处于Angular的核心地位，其不断创建和销毁驱动着Angular应用运作，但组件并不能独立运作，一个完整的Angular应用还有其他重要的组成部分。

- 模板
- 指令
- 服务
- 依赖注入
- 路由

这些组成部分各有职责，与组件相互协作。

### 模板
模板并不是独立的组成部分，而是组件的一个重要组成要素，之所以把模板单独列出，是因为Anglar为模板定制了一套强大的语法，响应用户的操作以及复杂的数据交互都在模板里完成。Angular模板基于HTML，并对其进行扩展，除了前述提到的数据绑定语法，负责数据的传递与展示，还有更多语法特性，如管道操作符，用以格式化视图数据，又如Elvis操作符，保证模板变量的安全引用，此外，Angular提供了一套强大的”指令“机制，来简化一些特定的交互场景，如样式指令，数据遍历指令，还有一套强大的表单指令。详细的模板语法讲解将会在第三章详细展开。

### 指令
指令与模板关系密切，指令机制扩展了模板的语法，指令可以与DOM进行灵活交互，或是改变样式，或是改变布局。指令的范畴很广，实际上组件也是指令的一种。组件与一般的指令的区别在于，组件是带有单独的模板，即DOM结构，而一般的指令是作用在已有的DOM结构上。一般的指令分为两种，结构指令和属性指令。

结构指令能够添加、修改、或是删除DOM，从而改变布局，如`ngFor`；属性指令用以改变元素的外观或是行为，属性指令使用起来跟普通的HTML元素属性非常相似，如`style`指令。指令支持开发者自由定制，在第四章指令章节会详细介绍自定义指令的构建过程。

### 服务
服务是Angular的一个独立模板，常被引用于组件/指令内部，作为组件/指令的功能扩展。服务包含什么？服务可以是一个字符串或是JSON，也可以一个函数甚至是一个类，几乎所有的对象都可以封装成服务。粗略的定义是：服务是封装单一目的的功能单元，类似于工具库，如日志服务，一个简单的日志服务可能是下面这个样子：

```
@Injectable()
export class LoggerService {
  log(msg: any)   { console.log(msg); }
  error(msg: any) { console.error(msg); }
  warn(msg: any)  { console.warn(msg); }
}
```

组件需要记录日志时只需”注入“`LoggerService`即可调用其接口，封装成独立模块的日志服务使其能被所有的组件/指令所服用，这就是服务设计的宗旨。

`Http`是Angular的内置服务，封装了一系列的数据请求接口，但与一般的接口封装类库不同，`Http`服务暴露的是Reative Programming规范的接口，基于RxJs实现。第五章服务章节除了介绍`Http`的接口方法之外，还会安排章节专门讲解RxJs这个响应式编程框架。

### 依赖注入
上述提及到服务模块时，已经提到了”注入“概念。依赖注入机制用以描述组件/指令如何引入服务模块。服务在每次被注入到组件/指令时，都会构建一个新的实例。在Typescript里，对象均明确赋以类型，通过查找该类型即可知道类所依赖的对象。如下例所示：
```
import {LoggerService} from './logger-service'
@Component({
  selector: 'contact-detail',
  templateUrl: 'app/components/contact-detail/contact-detail.html',
  providers: [ LoggerService ] 
})
export class ContactDetailComponent {
  constructor(private logger: LoggerService) {

  }
}
```
在`ContactDetailComponent`构造器执行之前，Angular会首先完成`LoggerService`的初始化。每次`ContactDetailComponent`组件重新初始化时`LoggerService`也会被重新初始化，在大多数时候并不是我们预期想要的效果，所以通常情况下依赖注入会放到应用启动函数，这样在App的任何地方均可以使用LoggerService。
```
bootstrap(AppComponent, [LoggerService]);
```

### 路由
Angular作为单页应用框架，前端路由功能必不可少。Angular里是通过`<router-outlet></router-outlet>`这个指令创建一个路由的容器节点（viewport），随着用户的浏览过程，组件在这个容器内创建和销毁，在容器节点之外可以配置不随路由切换变动的内容，如下面示例代码的`<nav></nav>`。
```
<div class="main">
  <nav></nav>
  <router-outlet></router-outlet>
</div>
```

Angular支持两种地址策略，一是利用Hash标识路由地址，二是利用利用浏览器的History API。
// Todo

## 总结
上述的6个组成部分是Angular的核心构成，打家庭的关系图如图2.1-6所示。模板作为组件的组成要素，用以描述组件的界面视图，指令增强了模板的语法，服务借助依赖注入扩展了组件/指令的功能，而路由管理应用页面的切换，控制组件的创建和销毁。

![](https://angular.io/resources/images/devguide/architecture/overview2.png)

图 2.1-6 Angular各个组成部分关系

各个组成部分以组件作为桥梁关联起来，所以接下来，组件将作为本书深入讲解的开篇，模板虽然是组件的组成部分，但内里涉及到的内容较多，故单独开辟一章介绍，接下来分别对指令、服务、依赖注入以及路由展开详细讲解，其中服务章节会连带讲述响应式编程库RxJs。最后安排一章“测试”，详细讲解在Angular框架下是如何进行测试工作，保证项目质量。



