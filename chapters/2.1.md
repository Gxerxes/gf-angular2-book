# 1. Angular2总览
Angular 是 Google 主导开发的，官方文档这么介绍它：Angular 是一个用来帮助我们用 HTML 和 JavaScript 构建客户端应用的开发框架。HTML 适合用来表述静态文档（它就是因此而生），但是当我们要开发一个交互复杂的 Web 应用，HTML + DOM 操作（通常用jQuery）也很难帮助描述好应用中的动态视图，Angular的出现就是为了帮助我们解决逻辑描述。

Angular已经是非常流行的MVVM开发框架。现如今，Angular的重写版本Angular2已经正式发布（Todo），然而Angular2并不是Angular1的简单升级，其内部的机制以及核心模块的实现相去甚远。本章将会从总览的角度去分析Angular2的总体架构设计，慢慢揭开Angular2的神秘面纱。

## 1.1 Angular的组成

相比第一代AngularJs，新版Angular（下面Angular均指新版）的代码更简洁易读，性能更高。Angular应用由一系列大大小小的松耦合的组件组成，这些组件层层嵌套，自上而下构成组件树。如图1-1显示。`Application`是根组件，其中子组件`Talks`也有自己的子组件。

> img cmp tree

图 1-1 组件树

下面是其中列表单项的组件例子。
```
@Component({
  selector: 'list-item',
  template: '<li (click)="clickItem(item.id)">{{item.name}}</li>',
})
export class ListItemComponent {
  @Input() item: contactItem;
  @Output('select') selectEmitter = new EventEmitter<number>();

  constructor(){ }
  
  clickItem(itemId) {
    // 内部逻辑
    this.selectEmitter.emit(itemId);
  }

```

上面的示例代码定义了`list-item`组件，在父组件`contact-list`的模板里，`list-item`可以这样被引入：

```
<list-item [item]="listItem" (select)="doSomething(itemId)"></list-item>
```

其中可以看出`item`和`select`是`list-item`组件对外暴露的API，所以父组件和子组件并不是孤立的存在，彼此存在双向的数据传输，组件通过配置Input和Output属性来定义数据传输的接口，
```
class ListItemComponent { 
  @Input() item: contactItem;
  @Output('select') selectEmitter = new EventEmitter<number>();
  //... 
} 
```
> img cmp data flow

> Todo 此处需替换为通讯录

每个组件都有其模板，用以定义组件的视图。组件的模板可以内联定义，如上例的`template`，也可以定义在单独的文件里。组件类数据模型和模板视图之间的数据交互有两种主要类型，一是属性绑定，数据流向是从数据模型到模板视图，如`{{item.name}}`，另一种是事件绑定，数据流向是从模板视图到数据模型，如`(click)="clickItem(item.id)"`。

![](https://angular.io/resources/images/devguide/architecture/component-databinding.png)

属性绑定和事件绑定也应用在组件树之间通讯，组件`Input`属性在模板里的体现是属性绑定，`Output`属性对应的是事件绑定。

![](https://angular.io/resources/images/devguide/architecture/parent-child-binding.png)

Angular就是这样实现数据从组件逻辑到模板视图，再到组件之间的流动，然而实现这个流动还需要一个强有力的引擎，这就是Angular的变化监测机制。Angular是一个响应式系统，每个组件背后都维护着一个独立的变动监测器，通过属性绑定以及事件绑定监控来自Model和View的数据变动，当监测到变化发生后，触发的变化事件以深度优先的顺序在组件树里自顶向下传播。更多变化监测的细节会在组件章节详细展开。

![](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapter2-1/reactive-cd.png)


![](https://yakovfain.files.wordpress.com/2016/02/ch1_angular_component.png?w=760)


组件是Angular里的核心部分，每个组件都有其生命周期，组件的不断创建和销毁驱动着Angular应用运作，但组件并不能独立运作，其行为的执行离不开下面这些重要组成部分。

- 模板
- 指令
- 服务
- 依赖注入
- 路由

### 模板
上述可见模板并不是独立的组成部分，而是组件的一个重要组成要素，二者有着密切的数据传递。Angular模板基于HTML，纯粹的HTML即可以完成Angular视图的渲染，但这不是模板的全部，Angular模板新增了一些模板语法，如前所述的属性绑定和事件绑定，有管道和Elvis扩展操作符，还有一些强大的内置“指令”，如表单指令，样式指令，遍历指令等，这里提到的“指令”是Angular的另一个独立的组成部分，通过指令系统可以创造出更多强大的自定义属性。

### 指令
指令机制扩展了模板的语法，因为指令本身可以与DOM进行灵活交互，或是改变样式，或是改变布局。指令的范畴很广，实际上组件也是指令的一种。组件与一般的指令的区别在于，组件是带有单独的模板，即DOM结构，而一般的指令是作用在已有的DOM结构上。一般的指令分为两种，结构指令和属性指令。

结构指令能够添加、修改、或是删除DOM，从而改变布局，如`ngFor`；

```
<li *ngFor="let item of contacts">
  <list-item [item]="item" (select)="doSomething($event)"></list-item>
</li>
```

`*ngFor`执行完后，每个通讯录列表项都被分配一个`li`结构，并插入到原父元素之下，同时传递变量。注意到这里的`*`号，这是语法的重要组成部分。

属性指令用以改变元素的外观或是行为，属性指令使用起来跟普通的HTML元素属性非常相似，如实现双向绑定`ngModel`，`ngModel`通过改变`input`的值和响应变更事件来改变`input`的行为。

```
<input [(ngModel)]="contact.name">
```

指令支持开发者自由定制，这是指令最迷人的地方，在第四章指令章节会详细介绍自定义指令的构建过程。

### 服务

服务常常用于组件内部，作为组件的功能扩展。Angular并没有对服务下了明确的定义，服务在Angular是一个大杂烩，可以是一个字符串或是JSON，也可以一个函数甚至是一个类，几乎所有的对象都可以封装成服务。服务是封装同一目的的功能单元，如日志服务、数据服务、应用配置等。这些功能服务或者是配置是组件所依赖的，但组件的关注的重点是与模板交互，展示友好的用户界面，以及响应用户操作，把记录日志的功能放到组件里实现，应用程序虽然也能跑通，但显然容易造成代码冗余，几乎每个组件都需要日志功能。更好的设计是把日志功能独立出来，封装到服务里，一个简单的日志服务可能是下面这个样子：

```
export class LoggerService {
  log(msg: any)   { console.log(msg); }
  error(msg: any) { console.error(msg); }
  warn(msg: any)  { console.warn(msg); }
}
```

需要日志功能的组件通过注入这个日志服务即可使用日志服务暴露出来的API，后续需要扩展日志功能只需要修改日志服务，服务的机制能帮助我们构建良好的程序架构。这里说到了"注入"，注入也是Angular里另一个重要的概念，下面继续详述。

### 依赖注入
依赖注入机制用以描述组件、指令或服务等组成部分之间相互依赖时如何进行引入调用，这些组成部分被注入时，会构建一个新的实例引入。在Typescript里，会给对象指定类型，通过查找该类型即可知道类所依赖的对象。如下例所示：
```
import {LoggerService} from './logger-service'
@Component({
  selector: 'contact-detail',
  templateUrl: 'app/components/contact-detail/contact-detail.html',
  providers: [ LoggerService ] 
})
export class ContactDetailComponent {
  constructor(private logger: LoggerService) {

  }
}
```
在`ContactDetailComponent`构造器执行之前，Angular会首先完成`LoggerService`的初始化。每次`ContactDetailComponent`组件重新初始化时`LoggerService`也会被重新初始化，在大多数时候并不是我们预期想要的效果，所以通常情况下依赖注入会放到应用启动函数，这样在App的任何地方均可以使用LoggerService。
```
bootstrap(AppComponent, [LoggerService]);
```

### 路由
Angular作为单页应用框架，前端路由功能必不可少。Angular里是通过`<router-outlet></router-outlet>`这个指令创建一个路由的容器节点（viewport），随着用户的浏览过程，组件在这个容器内创建和销毁，在容器节点之外可以配置不随路由切换变动的内容，如下面示例代码的`<nav></nav>`。
```
<div class="main">
  <nav></nav>
  <router-outlet></router-outlet>
</div>
```

Angular支持两种地址策略，一是利用Hash标识路由地址，二是利用利用浏览器的History API。
// Todo

### 总结
上述的6个组成部分是Angular的核心构成，模板是组件的组成要素，通过属性绑定和事件绑定与组件主体进行数据交互，指令扩展了模板的功能，服务借助依赖注入又扩展了组件的功能，而组件间的切换则通过路由来实现。

![](https://angular.io/resources/images/devguide/architecture/overview2.png)

各个组成部分以组件作为桥梁关联起来，所以本书的第二部分将以“组件”作为深入讲解的开篇，模板虽然是组件的组成部分，但内里涉及到的内容较多，故单独开辟一章介绍，接下来分别对指令、服务、依赖注入以及路由展开详细讲解。最后安排一章“测试”，详细讲解在Angular框架下是如何进行测试工作，保证项目质量。



