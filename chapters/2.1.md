# 1. Angular2总览
Angular 是 Google 主导开发的，官方文档这么介绍它：Angular 是一个用来帮助我们用 HTML 和 JavaScript 构建客户端应用的开发框架。HTML 适合用来表述静态文档（它就是因此而生），但是当我们要开发一个交互复杂的 Web 应用，HTML + DOM 操作（通常用jQuery）也很难帮助描述好应用中的动态视图，Angular的出现就是为了帮助我们解决逻辑描述。

Angular已经是非常流行的MVVM开发框架。现如今，Angular的重写版本Angular2已经正式发布（Todo），然而Angular2并不是Angular1的简单升级，其内部的机制以及核心模块的实现相去甚远。本章将会从总览的角度去分析Angular2的总体架构设计，慢慢揭开Angular2的神秘面纱。

## 1.1 Angular的组成

相比第一代AngularJs，新版Angular（下面Angular均指新版）的代码更简洁易读，性能更高，学习成本更低，其整体架构师完全基于组件设计。Angular构建的应用由大大小小的松耦合的组件组成，这些组件层层嵌套，自上而下构成组件树。如图1-1显示。页面整体被红色框所标记，此即为根组件，绿色框下的NavBar组件、Search组件、Product组件、Footer组件等均为根组件的子组件，根组件和子组件并不是孤立的存在，彼此存在双向的信息传递。

> Todo 此处需替换为通讯录

![](https://yakovfain.files.wordpress.com/2016/02/ch2_auction_home_page_components.png?w=760&h=547)

下面是其中列表单项的组件例子。
```
@Component({
  selector: 'list-item',
  template: '<li (click)="clickItem(item.id)">{{item.name}}</li>',
})
export class ListItemComponent {
  @Input() item: contactItem;
  @Output('select') selectEmitter = new EventEmitter<number>();

  constructor(){ }
  
  clickItem(itemId) {
    // 内部逻辑
    this.selectEmitter.emit(itemId);
  }

```

组件的物理组成有两部分，`@Component`元数据以及组件类。
元数据的作用是告诉Angular如何去处理一个类，`@Component`告诉Angular这个类需要以组件的形式去解释执行。`@Component`里有很多描述组件类特性的参数。例如`selector`标识组件类的自定义标签名称，这样我们可以在父组件的模板里使用`list-item`标签引入该组件。如

```
<list-item [item]="listItem" (select)="doSomething(itemId)"></list-item>
```

其中`listItem`为父组件变量，通过属性绑定`@Input()`传递给子组件；`(click)`语法标识事件绑定，这个事件是组件内部事件，通常处理一些内部逻辑，当然也可以如上例所示，通过`@Output()`标识将事件传递至父组件。

`{{item.name}}`这种语法实现数据绑定功能，模板渲染时，`item.name`的计算值会替换`{{item.name}}`，这种方式成为插值，是最常见的数据绑定方式，实现组件到模板的数据输出。按照数据流向形态的不同，Angular还有其他3种数据绑定的类型，分别是属性绑定、事件绑定、双向绑定，如图。

![](https://angular.io/resources/images/devguide/architecture/databinding.png)

属性绑定的数据流向也是从组件到模板，顾名思义属性绑定的目标对象是元素属性，元素属性不一定是HTML元素固有的属性，也可以是自定义组件元素的输入属性，这里不仅仅是字符串的传递，也可以是值的引用传递，如上述的`[item]="listItem"`。事件绑定如前面所述的`(click)`，用以响应用户操作，数据从模板到组件方向流动。模板的事件触发后，调用组件里定义的成员函数，除了可以传递标量值，也可以传递对象引用。双向绑定是一种特殊的数据绑定形式，同时融合了属性绑定和事件绑定，通常用在表单元素上

```
<input [(ngModel)]="contact.name">
```

用户在input表单里输入数据后，自动赋值给`contact.name`，同时当组件里`contact.name`的值发生改变时，input表单的值也会随之改变。这4种数据绑定方式除了应用在组件类与模板之间进行数据交换，也应用在父组件和子组件之间的数据交互，原理一致。

![](https://angular.io/resources/images/devguide/architecture/component-databinding.png)
![](https://angular.io/resources/images/devguide/architecture/parent-child-binding.png)


组件是Angular里的核心部分，组件的不断创建和销毁驱动着Angular应用运作。组件作为Angular的入口并不能单独运作，其行为的执行需要依赖其他一些重要的组成部分，他们分别是：

- 模板
- 指令
- 服务
- 依赖注入
- 路由

下面逐一讲解这5个组成部分以及相互间的关联关系。

### 模板
Angular模板基于HTML，纯粹的HTML即可以完成Angular视图的渲染，但这不是Angular模板的全部，Angular基于HTML的语法可扩展出灵活丰富的自定义标签或自定义属性。如下通讯录列表页示例代码：

```
<ul class="list">
  <li *ngFor="let item of contacts">
    <list-item [item]="item" (select)="doSomething($event)"></list-item>
  </li>
</ul>
```

除了我们熟知的`ul`和`li`标签，还有`list-item`自定义标签，上面的讲述可知，该组件标签是在组件`ListItemComponent`定义。组件树的视图表现为模板的嵌套，最终渲染出丰富的视图界面。
除了自定义标签，Angular内置了不少功能强大的模板语法，如上例的`ngFor`，可遍历组件变量以及模板，还有配置样式的`ngStyle`等等，这些丰富的模板语法是通过Angular指令实现。


### 指令
在复杂的应用交互里，特别是对于大型应用里，DOM往往是动态变更的，或是改变样式，或是改变布局，指令正式通过改变DOM的行为实现扩展模板的功能。在Angular里，指令的范畴很广，实际上组件也是指令的一种。组件与一般的指令的区别在于，组件是带有单独的模板，即DOM结构，而一般的指令是作用在已有的DOM结构上。一般的指令分为两种，结构指令和属性指令。

结构指令能够添加、修改、或是删除DOM，从而改变布局，如`ngFor`；

```
<li *ngFor="let item of contacts">
  <list-item [item]="item" (select)="doSomething($event)"></list-item>
</li>
```

`*ngFor`执行完后，每个通讯录列表项都被分配一个`li`结构，并插入到原父元素之下，同时传递变量。注意到这里的`*`号，这是语法的重要组成部分，指令章节会详细介绍。

属性指令用以改变元素的外观或是行为，属性指令使用起来跟普通的HTML元素属性非常相似，如实现双向绑定`ngModel`，`ngModel`通过改变`input`的值和响应变更事件来改变`input`的行为。

```
<input [(ngModel)]="contact.name">
```

上述这些是Angualar提供的一些内置指令，指令支持开发者自由定制，从而实现功能强大的模板语法。在本篇第四章节将会详细讲述自定义指令的编写过程。

### 服务
Angular并没有对服务下了明确的定义，服务在Angular是一个大杂烩，可以是一个字符串或是JSON，也可以一个函数甚至是一个类，几乎所有的对象都可以封装成服务。服务是封装同一目的的功能单元，例如日志服务、数据服务、应用配置等。

服务常常用于组件内部，作为组件的功能扩展。组件的核心作用是与模板交互，展示友好的用户界面，以及响应用户操作，记录日志并不是组件关心的功能，把记录日志的功能放到组件里实现，应用程序虽然也能跑通，但显然容易造成代码冗余，几乎每个组件都需要日志功能。更好的设计是把日志功能独立出来，封装到服务里，一个简单的日志服务可能是下面这个样子：

```
export class LoggerService {
  log(msg: any)   { console.log(msg); }
  error(msg: any) { console.error(msg); }
  warn(msg: any)  { console.warn(msg); }
}
```

需要日志功能的组件通过注入这个日志服务即可使用日志服务暴露出来的API，后续需要扩展日志功能只需要修改日志服务，服务的机制能帮助我们构建良好的程序架构。这里说到了"注入"，注入也是Angular里另一个重要的概念，下面继续详述。

### 依赖注入
依赖注入机制用以描述组件、指令或服务等组成部分之间相互依赖时如何进行引入调用，这些组成部分被注入时，会构建一个新的实例引入。在Typescript里，会给对象指定类型，通过查找该类型即可知道类所依赖的对象。如下例所示：
```
import {LoggerService} from './logger-service'
@Component({
  selector: 'contact-detail',
  templateUrl: 'app/components/contact-detail/contact-detail.html',
  providers: [ LoggerService ] 
})
export class ContactDetailComponent {
  constructor(private logger: LoggerService) {

  }
}
```
在`ContactDetailComponent`构造器执行之前，Angular会首先完成`LoggerService`的初始化。每次`ContactDetailComponent`组件重新初始化时`LoggerService`也会被重新初始化，在大多数时候并不是我们预期想要的效果，所以通常情况下依赖注入会放到应用启动函数，这样在App的任何地方均可以使用LoggerService。
```
bootstrap(AppComponent, [LoggerService]);
```

### 路由



### 总结
上述的6个组成部分是Angular的核心构成，模板是组件的组成要素，通过属性绑定和事件绑定与组件主体进行数据交互，指令扩展了模板的功能，服务借助依赖注入又扩展了组件的功能，而组件间的切换则通过路由来实现。

![](https://angular.io/resources/images/devguide/architecture/overview2.png)

各个组成部分以组件作为桥梁关联起来，所以本书的第二部分将以“组件”作为深入讲解的开篇，接入来按照与组件的关联程度，分别展开讲解模板、指令、服务、依赖注入以及路由。另外在最后安排一章“测试”，详细讲解在Angular框架下如何进行测试工作，保证项目质量。



