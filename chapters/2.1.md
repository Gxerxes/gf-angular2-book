# 1. Angular概述
前述篇节已经描绘了新版Angular的大图景，包括其历史发展以及周边生态，并简单介绍了Angular的一些核心概念，接下来本书第二篇会将重心回归到Angular框架本身，真正地去深入揭开Angular的技术内幕。

我们知道，新版的Angular彻底地重写了，虽然重写多少会给社区带来了不便，好在Angular团队在无缝升级方面下了不少功夫，而且更重要的是重写能让Angular抛掉老版的包袱。采用新架构设计的Angular代码更简洁易读、性能更高，而且更加贴合新时代前端的发展趋势，如基于组件的设计，响应式编程等。除此之外，新版Angular适用场景更广，如支持服务端渲染，能更好地适配Mobile应用（Mobile Toolkit，离线编译）等。

所以，新版Angular更具吸引力，也更容易快速上手，本书也将抛开老版Angularjs，从零开始带大家进入新版Angular的学习（下称Angular均指新版）。本章首先从总览的角度去分析Angular的各个核心组成，对框架有个整体的认知。

## 1.1 基于组件的设计

Angular框架基于组件设计，其应用由一系列大大小小的松耦合的组件构成，我们谈及组件，到底组件意味着什么？首先列举通讯录Demo的效果图，运行成功大概会是下面这个样子：

![](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapter2-1/cmp.png)

图 2.1-1

实际上所有框起来的部分均是由相应的组件所渲染，并且这些组件层层嵌套着，自上而下构成组件树。如最外层的方框为根组件，包含了Header、ContactList以及Footer三个子组件，其中ContactList又有自己的子组件。

![](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapter2-1/cmp-tree.png)

图 2.1-2 组件树

树状结构的组件关系意味着每个组件并不是孤立的存在，父子组件之间存在着双向的数据流动，要理解数据是怎样流动的？首先要了解组件间调用方式。简单说，Angular的组件外在形态就是自定义标签，所以组件间的调用的实际体现在于模板标签的引用。如下`Contact`组件的代码片段：

```
@Component({
  selector: 'contact',
  template: '<div>{{item.name}}</div>' // 省略部分内容
})
export class ContactComponent {
  @Input() item: Contact;
  @Output() update: EventEmitter;
  constructor() { }
  // ...
```

`@Input()`和`@Output`声明了组件`Contact`对外暴露的接口，`item`接口用来接收来自父组件的数据源输入，`update`接口用于向父组件发送数据，那么父组件是如何引用子组件并调用这些接口呢？抽取父组件`ContactList`组件代码片段如下：

```
import { ConcatComponnet } from './contact.ts';
@Component({
  selector: 'contact-list',
  providers: [ ConcatComponnet ],
  template: `
    ...
    <contact [item]="listItem" (update)="doUpdate(newItem)"></contact>
    ...
  `
})
export class ContactListComponent {
  constructor() { }
  listItem: IContact[],
  doUpdate(item: IContact) {
    // ...
  }
}
```

> 关于@Component里的providers属性机制，后续组件章节会介绍，这里只需了解引入`ConcatComponent`组件是通过这种声明模式。

由`template`属性值可见，父子组件之间通过类似于HTML属性的方式传递数据，其中`[item]`称为属性绑定，数据从父组件流向子组件，`(update)`称为事件绑定，数据从子组件流向父组件。

![](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapter2-1/cmp-data-flow.png)

图 2.1-3 父子组件间的数据流动

细心的读者可能已经发现，Angular的模板里是可以直接引用组件里的成员属性，如`listItem`和`doUpdate`。组件类和模板之间的数据交互称为数据绑定，前面所说的属性绑定和数据绑定也属于数据绑定的范畴，属性绑定和事件绑定既可用于父子组件的数据传递，也可用于组件数据模型和模板视图之间的数据传递。所以在父子组件通信的过程中，模板充当类似于桥梁的角色，连接着二者的功能逻辑。

![](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapter2-1/cmp-data-flow-all.png)

图 2.1-4 数据流动

这就是Angular的数据流动机制，然而流动并不是自发形成，流动需要一个驱动力，这个驱动力即是Angular的变化监测机制。Angular是一个响应式系统，每个组件都关联着一个独立的变化监测器。当监测到组件数据变化后，会触发变化事件在组件树内传播。

那么Angular是如何感知数据对象发生变动呢？ES5提供了getter/setter语言接口来捕捉对象变动，然而Angular并没有采用。Angular采用的是以适当的时机去检验对象的值是否被改动，这个适当的时机并不是以固定某个频率去执行，而通常是在用户点击，或XHR异步回调等浏览器事件触发之后，覆盖所有这些浏览器事件的捕获工作是通过`Zones`库实现的（关于Zones在组件章节会展开原理讲述）。变化监测事件图如下所示：

![](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapter2-1/cd.png)

图 2.1-5 变化检测

Zones捕获了浏览器的事件后，通知所属组件的变化监测器，若检查到数据对象有变动，即触发变化事件，并从该组件开始，以深度优先的原则向子组件传播

变化监测机制使得应用开发者不必关心数据何时变动，并结合数据绑定实现模板视图实时更新，这就是Angular强大的数据变化监测机制，提供数据自动更新功能，若此时需要手动捕获变化事件做一些额外处理，可以么？答案是肯定的。Angular还提供了完善的生命周期钩子给开发者调用，如`ngOnChanges`可以满足刚提到的捕获变化事件的要求，又如`ngOnDestroy`可以在组件销毁前做一些清理工作，等等。

这就是组件的概况，组件在Angular框架里处于最核心的位置，上述的讲解浅尝辄止，更多的关于组件的运作机理会在第二章继续剖析。

## 1.2 组件周边

组件处于Angular的核心地位，其不断创建和销毁驱动着Angular应用运作，但组件并不能独立运作，一个完整的Angular应用还有其他重要的组成部分。

- 模板
- 指令
- 服务
- 依赖注入
- 路由

这些组成部分各司其职，并与组件紧密协作。

### 模板
模板并不是独立的组成部分，而是组件的重要组成要素。之所以把模板单独列出，主要因为Anglar为模板定制了一套强大的语法体系，涉及内容颇多。Angular模板基于HTML，并对其进行扩展，除了前述提到的数据绑定语法，负责数据的传递与展示，还有更多语法特性，如管道操作符，用以格式化视图数据，又如Elvis操作符，保证模板变量的安全引用。此外，Angular还提供了一套强大的”指令“机制，来简化一些特定的交互场景，如样式处理，数据遍历，以及表单处理。详细的模板语法将会在第三章一一罗列。

### 指令
指令与模板关系密切，指令可以与DOM进行灵活交互，或是改变样式，或是改变布局。指令的范畴很广，实际上组件也是指令的一种。组件与一般的指令的区别在于，组件是带有单独的模板，即DOM结构，而一般的指令是作用在已有的DOM结构上。一般的指令分为两种，结构指令和属性指令。

结构指令能够添加、修改、或是删除DOM，从而改变布局，如`ngFor`；属性指令用以改变元素的外观或是行为，属性指令使用起来跟普通的HTML元素属性非常相似，如`style`指令。指令最具吸引力的地方在于支持自定义指令，最大限度地实现了UI层面的逻辑复用。第四章指令章节将会带大家进入Angular丰富的指令世界。

### 服务
服务是封装单一目的的功能单元，类似于工具库，常被引用于组件/指令内部，作为组件/指令的功能扩展。服务包含什么？服务可以是一个字符串或是JSON，也可以一个函数甚至是一个类，几乎所有的对象都可以封装成服务。已日志服务为例，一个简单的日志服务可能是下面这个样子：

```
@Injectable()
export class LoggerService {
  info(msg: any)   { console.log(msg); }
  warn(msg: any)  { console.warn(msg); }
  error(msg: any) { console.error(msg); }
}
```

组件需要记录日志时只需”注入“`LoggerService`即可调用其接口，封装成独立模块的日志服务使其能被所有的组件/指令所复用，这就是服务设计的宗旨。

`Http`是Angular里常用的内置服务，封装了一系列的异步数据请求接口，但与一般的接口不同，`Http`服务暴露的是Reative Programming规范的接口，基于RxJs实现，将响应式编程贯彻到底。所以第五章服务章节除了介绍`Http`的使用方法之外，还会安排章节专门讲解RxJs这个响应式编程框架。

### 依赖注入
上述提及到服务模块时，已经提到了”注入“概念。依赖注入一直都是Angular的卖点特性，通过注入机制，服务等模块可以被引入到任何一个组件/指令当中，而开发者无须关心这些模块是如何被初始化，因为Angular已经帮你处理好了，包括该模块本身依赖的其他模块也会被初始化，如图2.1-6，组件注入日志服务后，日志服务以及基础服务都会被初始化。

![](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapter2-1/di.png)

图 2.1-6 依赖注入

可以说，依赖注入是一种设计模式，一种新的方法帮助开发者管理模块依赖的琐事。
在Angular里，依赖注入与TypeScript产生了特殊的化学反应，在Typescript里，对象均明确赋以类型，透过类型匹配，组件类便可知道该用哪种类型去创建实例并把该实例赋值到组件类变量里，如下所示：

```
import {LoggerService} from './logger-service'
@Component({
  selector: 'contact',
  providers: [ LoggerService ] 
})
export class ContactDetailComponent {
  constructor(private logger: LoggerService) {

  }

  doSomething() {
    this.logger.info('xxx');
  }
}
```

> `private logger: LoggerService`创建了一个类的私有属性，若忘记了可翻查TypeScript章节。

`@Component`里头的`providers`用于引入`LoggerService`类型，构造函数里定义了一个LoggerService类型的对象，代码里并没有显示初始化即可直接使用日志。需要注意的是服务的每一次注入，Angular都会为其新建实例，有时候并不是应用预期想要的效果，所以依赖注入需要考虑缓存问题，甚至需要考虑与组件树的交互关系，在第六章注入章节会逐一讲述更多关于注入的细节。


### 路由

// Todo

Angular作为单页应用框架，前端路由功能必不可少。Angular里是通过`<router-outlet></router-outlet>`这个指令创建一个路由的容器节点（viewport），随着用户的浏览过程，组件在这个容器内创建和销毁，在容器节点之外可以配置不随路由切换变动的内容，如下面示例代码的`<nav></nav>`。
```
<div class="main">
  <nav></nav>
  <router-outlet></router-outlet>
</div>
```

Angular支持两种地址策略，一是利用Hash标识路由地址，二是利用利用浏览器的History API。

## 总结
上述的6个组成部分是Angular的核心构成，大家庭的关系图如图2.1-6所示。模板作为组件的组成要素，用以描述组件的界面视图，指令增强了模板的语法，服务借助依赖注入扩展了组件/指令的功能，而路由管理应用页面的切换，控制组件的创建和销毁。

![](https://angular.io/resources/images/devguide/architecture/overview2.png)

图 2.1-7 Angular各个组成部分关系

各个组成部分以组件作为桥梁关联起来，所以，组件将作为本书深入讲解的开篇，展开对组件的深度剖析。
组件之后是模板，模板章节基本囊括了Angular所有内置的模板语法，细心阅读完后可对Angular所能表现的视图特性有一个系统的认识。
接着，指令、服务、依赖注入以及路由都是相对比较独立的概念，这4个部分会分别开辟新章节讲述。
最后会加入“测试”这个特殊章节，帮助了解在Angular框架下是如何进行测试工作，确保项目质量。



