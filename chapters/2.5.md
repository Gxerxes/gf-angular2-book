# 5.服务
## 5.1服务介绍

### 5.1.1 什么是服务
在生活中，服务是指为他人做事，并使他人从中受益的一种有偿或无偿的活动。延伸到计算机中，后台程序提供的功能，叫做"服务"（service）。比如，Windows系统中的自动更新服务，它会定期检查有无更新并自动或者提醒用户下载更新，那么这种自动更新就是一个"服务"。所以可以说"服务"就是计算机可以提供的某一种功能。

#### NG2中的Service（Injectable）
Angular2中的服务是封装了某一特定功能，并且可以通过注入的方式在其他地方使用的独立模块（类）。服务在Angular2中使用十分广泛，为了保证组件类的精简轻量以方便后期的维护，应该把包含特定功能的代码块提取到服务中。
常见的服务有：

* 和服务器通讯的数据服务
* 检查用户输入的验证服务
* 方便跟踪错误的日志服务

通常把和服务器进行数据交互的逻辑代码封装成一个独立的数据服务，然后在需要用到的地方注入数据服务。
例如，开发一个编辑联系人的功能，编辑联系人要做以下几件事情：

* 从服务器拉取联系人信息
* 验证用户修改的信息
* 把修改后的信息提交到服务器

不建议把上面所有事情都放着组件里面做，这样会使组件的代码量非常多而且显得杂乱不堪。还有一个重要原因就是，谁知道将来有没有其他场景也要从服务器拉取联系人信息呢，难道复制一份代码吗？所以最好的做法是创建一个单一的，可复用的数据服务，然后在所有需要用到的地方注入这个服务。创建一个服务是很简单的，只要定义一个类，然后通过@Injectable()装饰器使得这个类可以背注入，这个类就成了一个服务。

```typescript
import { Injectable } from '@angular/core';
@Injectable()
export class ContactService {
	//do something
}
```
这个可以被注入的类命名为ContactService，即联系人服务。可以看到，@Injectable()是一个服务的关键，当Typescript看到@Injectable()装饰器时，会记录下括号内的元数据，当这个服务内需要注入其他依赖时，这些元数据就会被派上用场。现在我们的ContactService是没有任何依赖的，但是同样应该添加@Injectable()装饰器，因为这个利于提高统一性和减少变更。从一开始就给加上@Injectable()装饰器这是一项最佳实践。

一个最简单的服务创建好了，那怎么使用这个服务呢？
首先，我们要在使用这个服务的代码开头导入这个服务

```Typescript
import { ContactService } from './contact.service';
```
导入了之后就可以在代码中使用了，但是要怎样获得一个ContactService的实例呢？难道要自己动手用new关键字去创建一个吗？当然不是啦，如果是这样的话就失去了服务的意义了。使用new创建ContactService实例会存在许多问题：

* 我们的组件将不得不弄清楚该如何创建 ContactService 。 如果有一天我们修改了ContactService 的构造函数，我们不得不找出创建过此服务的每一处代码，并修改它。 而给代码打补丁的行为容易导致错误，并增加了测试的负担。

* 我们每次使用new都会创建一个新的服务实例。如果这个服务需要缓存英雄列表，并把这个缓存共享给别人呢？怎么办？没办法，做不到。

* 我们把AppComponent锁死在ContactService的一个特定实现中。我们很难在别的场景中把它换成别的实现。比如，能离线操作吗？能在测试时使用不同的模拟版本吗？。

所以，使用服务的最佳方法是：注入服务。

```Typescript
constructor(private contactService: ContactService) { }
```
可以看到，这个构造函数是空的，它定义了一个私有的属性：contactService，这个属性的类型是ContactService。所以在这个组件被创建时，Angular会知道它需要得到一个ContactService的实例。

```
要了解关于依赖注入的更多知识，请参见 依赖注入 一章。
```
但是现在运行代码的时候会报错：

```
EXCEPTION: No provider for HeroService! (AppComponent -> ContactService)
(异常：没有ContactService的提供商！(AppComponent -> ContactService))
```
所以得先告诉Angular，创建ContactService的提供者是谁？然后Angular才知道怎样创建一个ContactService实例。所以还要在@Component组件的元数据底部添加providers数组属性如下：

```
providers: [ContactService]
```
这样Angular就知道如何去创建一个ContactService服务的实例了。

##5.2 Http
Http的全称是Hyper Text Transfer Protocol（超文本传输协议）。是用于从万维网服务器传输超文本到本地浏览器的传送协议。
Http协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的Https。
###5.2.1 Http client介绍
和服务器通讯的最常用的方式就是发送Http请求，在web应用中有三种方式构建http请求：

* 使用XMLHttpRequest
* 通过JSONP
* 使用Fetch接口

Angular2内置的Http模块提供了XMLHttpRequest和JSONP两种方式发送http请求。结合编辑联系人的例子，我们来看看如何通过Angular2的Http服务和服务器进行通讯。

#### 注册Http服务
由于Http并不是Angular2的核心模块，所以在使用Http服务前像下面这样导入：

```Typescript
import { bootstrap }      from '@angular/platform-browser-dynamic';
import { HTTP_PROVIDERS } from '@angular/http';
import { AppComponent }   from './app.component';

bootstrap(AppComponent, [ HTTP_PROVIDERS ]);
```
HTTP_PROVIDERS是@angular/http模块中定义的一个数组，它包含了所有与其相关以及自身所依赖的服务。
考虑到Http服务基本在任何地方都可能被使用到，所以把HTTP_PROVIDERS注册到bootstrap中，把上述代码保存在启动应用和根组件AppComponent的app.ts文件。

#### 使用RxJS
为了提升用户体验，通常都是使用异步的方式发送http请求的。处理异步操作，一般来说有以下三种方式：

* 使用回调函数
* 使用promise
* 使用Observable

Angular2官方十分推崇使用Observable，由于Angular2自身并没有提供Observable的实现，所以这里使用了一个官方认可的第三方库：RxJS。RxJS不是本章的讲解重点，欲了解更多关于RxJS的内容请查看：5.3 响应式编程。

#### 编写一个数据服务

正如前文所说，为了保持组件代码的整洁清晰，应该把和服务器交互的逻辑代码写成数据服务。现在来编写一个ContactService：

#### 使用Observable

```TypeScript
import {Injectable} from '@angular/core';
import {Http, RequestOptions} from '@angular/http';
import {Observable} from 'rxjs/Rx';

const contact_url = `./app/services/contacts.json`;

@Injectable()
export class ContactService {
  constructor(private _http:Http ) {}
  
  getContacts(): Observable<any[]>  {
	  return this._http.get(contact_url)
	                    .map(this.extractData)
	                    .catch(this.handleError);
  }
  
  private extractData(res: Response) {
    let body = res.json();
    return body.data || {};
  }
  
  private handleError (error: any) {
    let errMsg = (error.message) ? error.message :
      error.status ? `${error.status} - ${error.statusText}` : 'Server error';
    console.error(errMsg); // log to console instead
    return Observable.throw(errMsg);
  }
}

```
聪明的你可能已经发现_http.get方法返回的并不是一个promise，在get的后面接着的map方法也许让你摸不着头脑。实际上，_http.get返回的是一个由RxJs库实现的Observable对象，而map方法是它的常用操作符之一。

再看看extractData方法，这里需要通过json方法把服务器返回的数据转换成可以使用的json对象。这个并不是Angular2的设计，Angular2的Http服务遵循ES2015的标准：fetch方法返回的Response对象提供一个json()方法把响应体转换成一个javascript对象。

为什么不在getContacts里直接返回Response对象？这样不是更方便吗？
非常不建议这样做，一个数据服务应该对使用者隐藏实现的细节，使用者只需要调用数据服务的接口取得数据，并不关心数据是如何取得的，从哪里来的。

最后不要忘记处理异常情况，任何I/O操作都有发生错误的机会（网络故障等），所以在数据服务里做好异常处理是十分必要的。在这个例子，通过catch操作符捕捉到错误并打印到控制台，然后使用Observable.throw返回一个新的包含友好的错误信息的Observable对象。

现在看看怎样在组件中使用这个数据服务ContactService：
ContactComponent.ts:

```Typescript
getContacts() {
  return this.contactService.getContacts()
                   .subscribe(
                     contacts => this.contacts = contacts,
                     error =>  this.errorMessage = <any>error);
}
```
在ContactComponent中调用了contactService.getContacts()，我们使用subscribe函数的第二个参数来处理错误信息。这里使用this.errorMessage变量来保存错误信息，并通过绑定到模版上显示给用户。

```
这里有个需要注意的地方。在调用http.get的时候并没有发出请求，因为可观察对象是懒惰的，只要当它被订阅了之后才会发送请求。所以在ContactComponent中调用了getContacts().subscribe的时候才会发送请求。
```

上面已经实现了从远程服务器拉取联系人数据的功能，一个通讯录应用还应该有添加和编辑联系人的功能。所以接下来我们在ContactComponent.ts里添加一个addContact()方法，他的参数是一个联系人对象Contact的实例。
 
```Typescript
addContact (contact: Contact): Observable<Contact> {
```  
我们的服务器接口是符合REST规范的，添加联系人和拉取联系人的路径是一样的，只是使用了POST方法，并且在请求体中传递新增的联系人数据，数据结构和Contact是一致的，只是没有id属性。下面是请求体的一个例子：

```Typescript
{
  "name": "李想",
   "telNum": "18900001002",
   "address": "广东省深圳市",
   "email": "123@qq.com",
   "birthday": "1990/10/10",
   "collection": 0
}
```

服务器接口在接收到数据并验证通过后会生成id并且保存到数据库中，然后以JSON格式返回带id的完整的新联系人数据。
了解了新增联系人接口的使用方式后就可以快速的实现添加联系人功能了：

```Typescript
import { Headers, RequestOptions } from '@angular/http';
```
因为要发起一个POST请求，并且在请求体中传递一个JSON格式的数据，所以要设置请求头Content-Type的值为'application/json'，故要先引入Headers, RequestOptions对象。

```Typescript
  addContact (contact: Contact): Observable<Contact> {
    let body = JSON.stringify(contact);
    let headers = new Headers({ 'Content-Type': 'application/json' });
    let options = new RequestOptions({ headers: headers });

    return this.http.post(contact_url, body, options)
                    .map(this.extractData)
                    .catch(this.handleError);
  }
```

Headers是RequestOptions中的一员，这里把这些配置对象组合起来然后以第三个参数传递给post方法以达到自定义请求头的目的。

即使Content-Type已经被指定为JSON，但是POST请求体仍然只可以接收字符串，所以发送请求前先要用JSON.stringify把联系人数据编码一下。

```
也许不久的将来我们可以跳过JSON.stringify这一步。
```

现在看看如何在组件中使用addContact方法：

```Typescript
addContact (contact: Contact) {
  if (!contact) { return; }
  this.heroService.addContact(contact)
                   .subscribe(
                     contact => this.contacts.push(contact),
                     error => this.errorMessag=<any>error);
}
```
和之前一样，在组件的addContact方法中订阅了数据服务addContact()方法返回的可观察对象，数据返回时就会把新联系人数据追加到contacts数组，用于展示给用户。



#### 使用Promise

虽然Observable很好用，但是许多人已经习惯了使用Promise。Http服务返回的Observable<Response>对象是可以轻易的转换成Promise的。（即使您更加熟悉Promise，但Observable有更多优点，在使用Promise之前你应该给Observable一个施展魅力的机会。）

下面看看ContactService的Promise版本：

```TypeScript
import {Injectable} from '@angular/core';
import {Http, RequestOptions} from '@angular/http';
import {Observable} from 'rxjs/Rx';

const contact_url = `./app/services/contacts.json`;

@Injectable()
export class ContactService {
  constructor(private _http:Http ) {
  }
  
  getContacts(): Promise<any[]>  {
	  return this._http.get(contact_url)
	                    .toPromise()
	                    .then(this.extractData)
	                    .catch(this.handleError);
  }
  private extractData(res: Response) {
    let body = res.json();
    return body.data || { };
  }
  private handleError (error: any) {
    let errMsg = (error.message) ? error.message :
      error.status ? `${error.status} - ${error.statusText}` : 'Server error';
    console.error(errMsg); // log to console instead
    return Observable.throw(errMsg);
  }
}

```

由此可见，只要使用toPromise()方法，您所熟悉的then链就回来了。

###5.2.2 JSONP
上面我们学习了如何使用Http发起XMLHttpRequest，这是和服务器通讯最常用的方式，但是它并不能适应所有场景。

如果我们尝试向与当前页面不“同源”的服务器发起XMLHttpRequest，我们发现被浏览器阻止了。
这是出于安全的考虑，网络浏览器会阻止调用与当前页面不“同源”的远端服务器的XMLHttpRequest。所谓源 就是URI的协议(scheme)、主机名(host)和端口号(port)这几部分的组合。只要当前页面与服务器的“源”不同，发起的XMLHttpRequest就会被阻止，这就是我们常说的同源策略。

当然，如果服务器支持CORS协议，那么也可以向不同源的服务器发起XHR请求的。如果服务器要需要用户凭证，我们可以在请求头中使用它。

有些老的服务器不支持CORS，但所有服务器都支持JSONP。那JSONP是什么呢？

我们知道，script标签请求资源并不会受同源策略限制，其实JSONP就是利用script标签的这个特性来绕过同源策略的。所以说JSONP是一种非正式传输协议，该协议的关键就是利用就是script标签来发起一个GET请求，在这个GET请求中传递一个callback参数给服务端，然后服务端返回一段javascript代码，这段代码的内容就是callback函数包裹着JSON数据，当script标签的请求完成后就会自动执行这段代码，所以可以在预先定义好的全局方法callback中接收到JSON数据。

Angular2的Http已经封装好了jsonp方法，我们直接调用就行，并不用关心具体的实现细节。
下面来看看如何用Angular2发起一个JSONP请求：

```Typescript

import { Injectable } from '@angular/core';
import { Jsonp, URLSearchParams } from '@angular/http';
@Injectable()
export class ContactService {
  constructor(private jsonp: Jsonp) {}
  getContacts () {
  
    let jsonpUrl = 'http://www.others.com/contancts';
    let params = new URLSearchParams();
    params.set('format', 'json');
    params.set('callback', 'JSONP_CALLBACK');
    
    // TODO: Add error handling
    return this.jsonp
               .get(jsonpUrl, { search: params })
               .map(request => <string[]> request.json()[1]);
  }
}

```

很简单，首先在构造函数中注入Jsonp服务，然后使用URLSearchParams对象构造请求参数，最后调用jsonp的get方法发起请求。


##5.3 响应式编程
###5.3.1 什么是响应式编程
响应式编程（Reactive Programming），在维基百科中的解释是一种面向异步数据流（Asynchronous Data Streams）的编程范式。

那什么又是面向异步数据流的编程范式呢？其实很简单，就是看最终的数据是否会随着异步变化而变化，举个例子：

在以往的命令式编程中，如下图所示，当C的数值异步改变之后，A的数值并没有随着C的数值的改变而改变

```
2   1   1
|   |   |
A = B + C    =>   C = 2   =>   A == 2

```

而在响应式编程中，如下图所示，随着C的异步改变，A的数值也会随之变动

```
2   1   1
|   |   |
A = B + C    =>   C = 2   =>   A == 3

```
这便是所谓的响应式编程。

在我们熟悉的MVVM中，存在一种M到V的绑定关系F，如下图，

```
view1    model1
 |         |
view = F(model)  =>  model = model2  =>  view == view2 
```
当model由model1异步变为model2时，view也随之进行了变化，由view1变为了view2，所以类MVVM框架也属于响应式编程的一种。

综上所述，响应式编程其实就是一种用于降低异步编程复杂度的编程范式。用同步的思维去处理异步的问题。这样的编程模式不仅降低了程序的复杂度，同时也提高了程序的可维护性。

###5.3.2 RectiveX
ReactiveX是Reactive Extensions的缩写，一般简写为Rx，是微软开发并维护的一套打着响应式编程招牌的编程模型，于2012年11月开源，用于提供一系列接口规范来帮助开发者更方便的处理异步数据流。简单来讲，Rx是一套专注于处理异步数据流的解决方案。

Rx作为响应式编程的一员，核心是通过观察者模式来实现处理异步数据流的调用，

####old

在响应式的编程范式下，解决复杂的异步问题的工具和框架多种多样，层出不穷。例如专注于MVVM领域的angular，又或者是用于处理异步数据的Promise。而ReactiveX也是是其中的一员，用于解决异步数据的处理问题。


可能刚开始接触Rx的朋友都会问，已经有了Promise，为什么还要多出来一套Rx的解决方案。其实，Rx在异步问题的解决上，范围更加广泛，算是Promise的超集。也就是说，任何promise的解决方案，在Rx上面都有对应的方案，而Rx最为强大的，是他对异步数据流的处理。当你把整个异步数据流看成一个队列时，Rx便相当于用来处理这个数据流队列的```loadash/underscore```。举个例子：

假设现在有一个场景，在一个输入框里输入数据，当1秒内，输入框里的数据不再变化时，便发送一个请求。

如果我们用常规思路来解决这个问题，我们需要在输入框数据改变的回调中设一个1秒的倒计时器，每当数据改变时，我们需要重置这个计时器，伪代码如下：

```js
//监听输入框的值改变时的回调
inputValueChangeCB () {
  clearTimer();
  newTimer(sendReq, 1000); //1秒后发送请求
}
```

而在Rx中，我们会把输入框的数据改变看成一个不会终止的数据流，也就是说在这个数据流中我们需要进行过滤操作，当每两个数据流节点之间的间隔超过1秒时，我们便需要拿到前一个数据流的节点，并对该数据流节点进行操作。伪代码如下：

```js
inputValueChangeObservable.debounceTime(1000).subscribe(data => {
  sendReq();
})
```

其中，```inputValueChangeObservable```是Rx抽象出来的数据流对象，而```debouceTime```则是对该数据流进行过滤的方法，过滤后的数据则通过subscribe方法传入回调中，从而发送请求。这便是观察者模式在Rx中的应用。

####Observable
ReactiveX使用观察者模式，它把所有的数据流统一抽象为一个Observable，在这种抽象下，每个Observable都可以被订阅（Subscribe），并且每一个Observable都是可操作的。就像Promise需要新建一个实例，并在回调中resolve或者reject一个值一样，Observable也是新建时，observer的next，error以及complete方法来传输自己的数据流。

####Observer
对于Observable，每一个被观察者都有一个Observer与之对应，Observer通过```observer.prototype.next```的方法发送消息流，消息流经过各种```operators```的加工，过滤，合并等方法之后，最终被```subscribe```所捕获。

####Subscription
当Observable实例被subscribe之后，会返回一个Subscription的实例，这个实例可以通过unsubscribe方法来取消对Observable的订阅。

####Subject
在Rx中，有一中数据结构既可以当做Observable可以被监听、订阅，又可以当做Observer，调用next、error等方法来传递数据，这种数据结构便是Subject。

Subject在Rx中的定位类似于一种事件代理（Event Proxy），我们订阅这样的事件代理，并在某一个时间节点通过调用Subscribe的next等方法来触发我们的事件，从而让我们的代理被每一个监听者，或者订阅者所获知。

####Operators
Operators无异于是Rx中最精髓的部分，Rx通过各种Operators对Observable进行合并，变换，过滤等等一系列操作，从而大大简化了我们对于异步数据处理难度，使我们的程序更易读。

由于Rx的各种语言对Operator的实现接口各不相同，所以我们会列出几个常用的Operators放在下一章继续做讲解。


##5.4 RxJS
###5.4.1 为什么使用RxJS



###5.4.2 RxJS
介绍完ReactiveX就要来讲讲RxJS了，RxJS作为Rx在JS上的实现，自然是实现并遵循了Rx的所有接口规范。

由于RxJS的接口太多，而这只是一本讲解Angular2的书，所以，我们不会把RxJS的所有api通通讲解一遍，只会挑选一些平时用的频率比较高的api来进行讲解。

####创建操作符（Creation Operators）
我们需要一些Observable的实例（Instance）来操作我们数据流，于是，我们需要用到一些创建操作符（Creation Operators）来创建我们的observable。

```Observable.create``` 便是我们经常用到的创建操作符，举个例子：

```js
let observable = Rx.Observable.create(observer => {
  let firstData = getFirstData();
  observer.next(firstData);

  getSecondData(secondData => {
    observer.next(secondData);
    observer.complete();
  });

 });

observable.subscribe(data => {
  doSomething(data);
});
```

在上面的例子中，```Observable.create```接受一个生产数据的callback，把```observer```传给他，并且返回一个```observable```的实例，这个实例被```subscribe```监听，每当```observer```的```next```方法被调用时，```subscribe```的callback便捕获到```observer```穿来的数据，并且执行。这样便实现了我们对数据流的监听。

####变换操作符（Transformation Operators）
有些时候，我们通过observable获取到的数据需要做一些批量的小调整。比如，我们的数据获取接口经常会有自己的一套规范去包裹数据，以至于我们拿到的数据经常不是我们实际要处理的数据，他会长这样

```json
{
  "err_code": 0,
  "data": {"name": "gfzq"}
}
```
在这种规范的数据包裹下，只有数据中的data字段是我们实际想要处理的，所以我们在对每一个请求需要做一个变换操作，把原本的数据流变换成我们需要的数据流，其中最常用的变换操作就是```Observable.prototype.map```，用上个例子中的observable来举例：

```js
observable.map(data => {
  return data.data;
}).subscribe(data => {
  doSomething(data);
});
```

当我们的```observable``` 拿到```data```并把```data```传给```subscribe```之前，我们通过```map```操作，来预先对我们的```data```进行处理，从而让```subscribe```得到正确的格式。

####过滤操作符（Filtering Operators）
过滤操作符，顾名思义，可以过滤掉一些我们不需要处理的数据。比如说，当处理闪购逻辑的时候，我们往往会遇到大量的并发请求，然而这些请求里，我们业务可能只会对第一个，或者前十个请求进行处理，其他一概忽略，这时候，我们就需要一个过滤器，来帮我们过滤掉我们不需要的请求。

回到开始那个例子，有时候在前端获取数据的时候，api会因为种种原因返回不了我们所需要的数据，只能返回一个```err_code```以及```err_msg```告知我们，因为数据没有正常返回，我们无法处理，所以就需要过滤掉这些数据（当然更多的实际情况我们需要对这些错误进行提示，不过这里我们只考虑简单忽略的情况），这时候，我们就需要用到```Observable.prototype.filter```来对数据流进行过滤：

```js
observable.filter(data => {
  return data.data !== undefined;
}).map(data => {
  return data.data;
}).subscribe(data => {
  doSomething(data);
});
```
我们通过```observable.prototype.filter```对数据流进行过滤，结果为false的数据流将不会再进入下一个，也就是```observable.prototype.map```，的操作中去。

####组合操作符（Combination Operators）
在之前的例子中，```getFirstData```以及```getSecondData```两个请求被封装在同一个 ```observable```中，并当做两个数据流进行统一处理。但在现实业务中，我们往往遇到的情况会是需要```getFirstData```和```getSecondData```两个请求同时发出，并且等到两个请求都拿到数据之后，再对两个数据一齐进行处理，或者是等到```getFirstData```请求完成后，再做```getSecondData```的请求。

对于前者，我们可以用```Observable.forkjoin```来组合我们请求：

```js
let getFirstDataObs = Rx.Observable.create(observer => {
  observer.next(getFirstData());
  observer.complete();
});
let getSecondDataObs = Rx.Observable.create(observer => {
  getSecondData(data => {
    observer.next(data);
    observer.complete();
  });
});
let observable = Rx.Observable.forkjoin(
  getFirstDataObs, getSecondDAtaObs
);

observable.subscribe(datas => {
  // datas[0]是getFirstDataObs的数据，
  // datas[1]是getSecondDataObs的数据
  doOtherthing(datas);
});
```

```Observable.forkjoin``` 把原本的两个相互独立的```observable```合并为一个新的```observable```，并且这个新的```observable```数据流会在前两个```observable```的数据流都抵达后发出。所以，本例中的```doOtherthing```只会执行一次，subscribe中拿到的```datas```便是两个数据流数据的组合。

对于后者，我们需要用```Observable.prototype.concatMap```，用回第一种情况的例子，我们的```getFirstDataObs```已经```getSecondDataObs```的构造方式不变：

```js
getFirstDataObs.concatMap(firstData => {
  doSomethingWithFirstData(firstData);
  return getSecondDataObs;
}).subscribe(secondData => {
  doSomethingWithSecondData(secondData);
});
```
通过```Observable.prototype.concatMap```的方法，我们把```getSecondDataObs```的数据流紧接在```getFirstDataObs```的数据流后，并且最终，数据流被subscribe捕获。

####工具操作符（Utility Operators）
```observable.prototype``` 中封装了很多有用的工具方法，像是```Observable.prototype.delay```或者是```Observable.prototype.timeout```等等，当我们想要给前端某个请求设置```timeout```时，就会用到这些方法：

```js
observable.timeout(5000).subscribe(data => {
  doSomething(data);
}, err => {
  handleErr(err);
});
```

这个例子中，当```observable```超过5000ms没有返回数据流时，便会抛出一个err被subscibe中的```handleErr```方法所捕获。

###5.4.3 Angular2中RxJS
在Angular2中，RxJS的应用随处可见，例如：HttpService中的get\post\request等方法会返回一个Observable实例，Router中的events，params等等也是一个Observable实例。这些Observable的具体用法会在相应的Http章节，以及Router章节进行详细的介绍，这里就不再做过多的阐述。

这一小节会列举两个比较常见的场景，来看看如何在Angular2中灵活的使用RxJS来满足现有的需求。

####Override HttpService
在写Angular2应用时，我们常常会觉得原本的HttpService不足以支撑现有的需求，没有统一的错误处理，没有统一的回调捕获（Callback Capture），为了实现这一点，我们需要对现有的HttpService进行再封装，把一些统一的业务逻辑封装在自己实现的HttpService里面。

现整理需求如下：

1. 对请求结果进行统一的预处理
2. 对捕获到的错误统一报错 
2. 在http请求发起时，开启加载动画
3. 在http请求结束时，关闭加载动画

虽然是对现有HttpService进行再封装，Override却不应该改变原有的HttpService的方法已经返回的数据类型。所以不论是get，post，update还是delete方法都需要返回一个可以被订阅的Observable。

```js
import {Injectable}     from '@angular/core';
import {Http, RequestOptions, Headers} from '@angular/http';
import {Observable}     from 'rxjs/Rx';

@Injectable()
export class HttpService {
  constructor(private http:Http) {}

  // 对于get，post，delete，update方法，统一调用request方法发送请求
  get(url:string, reqOpts?:RequestOptions) {
    return this.request(url, Object.assign({
      method: 'get'
    }, reqOpts));
  }

  /* post, delete, update ... */

  request(url:string, reqOpts:RequestOptions) {
    return new Observable(observer => {
      this.showLoading();  //需求3：开启加载动画
      
      this.http.request(url, new RequestOptions(reqOpts))
      .map(res => res.json())
      .subscribe(res => {
        this.hideLoading();  //需求4：关闭加载动画
        
        let data = this.preprocessRes(res); //需求1：对返回数据进行统一的预处理
        
        observer.next(data); //处理后的数据发送给subscriber
        observer.complete();
      }, this.handleErr);  //需求2：对请求错误统一处理
    });
  }
  
  private preprocessRes(res) {
    return res.data; //实际预处理情况会更复杂
  }

  private handleErr(err) {
    /* handle error */
  }
  
  private showLoading() {
    /* loading animation */
  }
  
  private hideLoading() {
    /* hide loading animation */
  }
}
```
在上述代码中，我们通过在request方法中返回一个新建的Observable实例，来确保get，post，delete，update请求可以成功被subscribe，并且返回的observable可以灵活切换冷热模式。业务需求以及请求被封装在

####智能联想
有时，在现实需求中会遇到这样一个场景，当用户在一个input框中输入一些字符串，需要我们在输入框下方提供一些联想，这些联想会根据用户输入的改变而改变。

这样的场景，实现方法往往很简单，只需要对input数据框进行change事件的监听，并在监听回调里，把当前用户的输入内容传给服务器，并把服务器的返回直接显示在input输入框下即可。可是实际生产中，这样的实现方式往往会出现一些不友好的问题，例如，当用户输入很快时，是否每次的输入都需要请求服务器，还是说需要在用户稍有停顿的时候，像服务器发送数据用以提示用户；再例如，生产中有很多网络问题，连续两次的异步请求往往返回的顺序会不一样，如何以正确的顺序来处理返回的数据。

现整理额外需求如下：

1. 不需要每次用户输入时都发送请求查询结果，保证如果500ms内用户不再输入数据再发送请求
2. 当连续两次的向服务器发送的请求内容相同时，不再发送请求
3. 保证请求回调数据处理的顺序不会错乱

相信这些需求在日常的生产中不会少见，而且解决方案也会比较繁琐，我们需要去记录前一个动作的某些状态量，并且在后一个动作开始前对前一个动作的状态量进行判断，当符合某些规则时，后一个动作才继续执行。虽然需求解决了，但是这样的代码以及状态量往往难以维护。接下来看下RxJS是如何优雅的解决这件事情。

首先，实现最基本的需求，对input的代码进行监听

```javascript
import {...} from '...';

@Component({
  selector: 'demo-input',
  template: `
    <input type="text" [ngFormControl]="term"/>
    <ul>
      <li *ngFor="let recommend of recommends">{{recommend}}</li>
    </ul>
  `,
  providers: [DemoService]
})
export class DemoInput {
  recommends:Array<string>;
  term = new Control();
  
  constructor(private demoService: DemoService) {
    this.term.valueChanges.subscribe(term => this.demoService.getRecommend(term).subscribe(data => {
      this.recommends = data;
    }));
  }
}
```

可以看到，在上面的代码中，最核心的是在constructor里面，```term.valueChanges```返回了一个Observable，这个Observable会在每次input框里的value进行改变时，抛出value值，并被subscribe所监听到。监听到这个value会直接调用demoService中的getRecommend接口，返回需要的recommend数据。

现在，对核心代码加点小小的改造，来完成之前的需求

```
  constructor(private demoService:DemoService) {
    this.term.valueChanges
             .debounceTime(500)  //需求1
             .distinctUntilChanged()  //需求2
             .switchMap(term => this.demoService.getRecommend(term))  //需求3
             .subscribe(items => this.items = items);
  }

```
这么简单？没错，这就是RxJS的强大之处，我们通过在Observable和subscribe之间添加了```debounceTime```,```distinctUntilChanged```,```switchMap```这三个Operator来满足了我们的三个需求。

其中，```debounceTime```会过滤掉所有Observable抛出的时间间隔不超过500毫秒的事件，而```disctictUntilChanged```会过滤掉所有Observable连续抛出的value相同的事件，这两个Operator满足了需求1和需求2。

至于```switchMap```，这个Operator接受了另外一个Observable```this.demoService.getRecommend(term)```，并把每一个valueChanges抛出来的事件映射成一个新的Observable，并把这些新的单一的Observable合并成一个新的整合在一起的Observable，更酷的是```switchMap```方法会让后来的请求数据进入subscribe之后，过滤掉所有先前的数据流，这样便优雅的实现了需求3。

### 本章小结
在本章里，我们学习了什么是服务，服务的优点以及如何创建并使用服务，接下来我们学习了Angular中最常用的服务之一：Http服务，并且通过通讯录的例子讲解了如何使用Http服务从远程服务器拉取数据和向远程发送数据。并且结合通讯录例子展示了使用Observable和Promise两种方式实现发起Http请求的差别，最后介绍了发起跨域请求的一个解决方案：JSONP，并展示的Angular2下如何发起一个JSONP请求。
另外，本章中我们介绍了响应式概念，响应式编程是一种面向异步数据流的编程理念，接着介绍了JS端的解决方案RxJS，同时介绍了RxJS中一些常用的操作符，这些都是在Angular2实际项目开发中常用到的。
通过本章，我们应该掌握了Angular2服务的编写，调用，并用RxJS来应用到Angular2的开发中，下章我们将探索依赖注入，强大的注入功能使得大型项目开发也可以相互独立，高效进行。


