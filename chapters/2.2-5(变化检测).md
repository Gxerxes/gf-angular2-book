## 2.5 变化监测机制
在`Angular2`中提供了数据绑定的功能（在模板章节会详细介绍），所谓数据绑定即将数据和页面DOM元素关联起来，当数据发生变化或者更改后，Angular2能够检测到这些变化或者更改，并对其所绑定的DOM元素进行相应的更新，反之亦然。它的数据流向是单项的，通过属性绑定和事件绑定来实现数据的流入和流出，数据从属性绑定流入组件，从事件流出组件，`Angular2`数据的双向绑定就是通过这样来实现的。

### 2.5.1 引起数据变化的来源
试想一下，页面数据在什么样的场景下会发生更改？在现有的应用场景下，开发者们大致认为有如下3类：

- `event`类，即页面操作所引发的用户事件，如click, change, hover等；
- `xmlHTTPRequest/webSocket`类，即从远端服务拉取对应的数据，这是一个异步的过程；
- `timeout`等页面的各类定时任务，如`setTimeout, setInterval, requestAnimationFrame`，都是在某个延时后触发。

以上的共同特征是什么？很明显共同点是它们都是异步的处理，即需要使用异步回调函数，这带给我们的结论就是，任意的一个异步操作，都有可能在数据层面上发生改变，这可能导致应用程序状态已经被改变，因此，如果可以在每一个异步回调函数执行结束后，能够通知`Angular2`内核进行更改检测，那么任何数据的更改就可以被实时地反应出来。

下面举个简单的例子进行说明,可以在组件的模板元数据中添加如下代码片段：

```html
<i [ngClass]="{collect: detail.collection == 0, collected: detail.collection == 1}" (click)="collectTheContact()"></i>
```
该例子是一个通讯录收藏的功能实现，当用户点击收藏按钮后，这将告诉`Angular2`此时的`detail.collection`数据发生改变，通知视图层做出相应的改变等。

正如上面的例子，通过属性绑定实现了数据从父传递给了子，而事件绑定则实现了数据由子到父的传递，这也就是`Angular2`用来实现数据双向绑定的方法。它实现的是单向流的数据传递，也就是说，数据流只能向下流入组件，如果需要进行数据变化，可以发射导致变化的事件到顶部，待数据变化处理完成，然后再往下流入组件。那么问题来了，`Angular2`如何知道数据是否已经处理处理完成，这份新的数据是否有变化，如果数据有变化，那是怎么来通知数据往下流入组件通知组件来改变视图呢？下面给读者介绍变化的通知机制。

### 2.5.2 变动通知机制
上一小节介绍了可能引起页面数据的几种场景，通过异步处理来通知页面重新更新数据源，因此，如果可以在每一个异步回调函数执行结束后，能够通知NG2内核进行更改检测，那么任何数据的更改就可以被实时地反应出来，那么，Angular2是通过什么样的机制来进行变化通知的呢？Angular2本身是不具备这样的通知机制的，为了实现这种机制，引入了ngZone这个服务。

为了更好的让您理解ngZone这个服务，本文先介绍zone的原理。

#### zone的实现原理
Zone实际上是Dart的一种语言特性，其是对Javascript某些设计缺陷的一些补充，简单的可以概述成Zone是一个异步事件拦截器，也就是说Zone能够hook到异步任务的执行上下文，以此来处理一些操作，比如说，在每次启动或者完成一个异步的操作、进行堆栈的跟踪处理、某段功能代码进入或者离开Zone，可以在这些关键的节点重写所需处理的方法。

Zone中提供了各类勾子（hooks），允许在每一个回调函数的开始和结束时，去执行统一的自定义逻辑，其本身是不做任何事的，相反它是依赖其它的代码，获取到这些代码片段的执行上下文，通过勾子来完成相关的功能。Zone的另一值得一提的是它必须依赖异步操作，当一个异步操作在执行时，它是有必要去捕获的这个异步操作并在该异步功能开始或者完成时建立对应的回调函数，然后存储到当前的Zone，举个例子，如果一个代码片段在fork的Zone中执行，并且这段代码中包含一个`setTimeout`的异步任务，那么执行到和完成这个`setTimeout`方法需要包裹一个异步的回调函数，存储到当前zone，这样是确保每个异步操作之间的相互不受影响，也就是受保护的状态，例如一个页面由业务代码和一些第三方广告代码组成，这两份代码之间是相互独立的，需要的是业务代码的异常捕获数据提交到自己的后台服务器上，第三方广告代码的异常捕获提交到自己的服务器上。当fork了多个Zone之后，异步操作将会精准的执行其所在的子Zone上面方法。

Zone的一个重要意义在于，所以来的功能或者业务代码运行在了fork的一个Zone中，该子Zone有了对该代码块执行上下文的控制权。其中也提供了一些勾子(hook)来处理基本的业务情景需求，这里你需要了解的勾子函数大致有：

- `Zone.onZoneCreated`即在Zone被fork时运行
- `Zone.beforeTask`即在执行`zone.run`包裹的函数之前调用
- `Zone.afterTask`即在执行`zone.run`包裹的函数之后调用
- `Zone.onError`即`zone.run`方法中的任务抛出异常时的勾子函数

通过上面的讲述您应该对Zone的实现原理有个大致的理解了，下面举个例子来加深对Zone的理解：

```js
zone.fork({
    beforeTask: () => {
        console.log('hi, beforeTask in.');
    },
    afterTask: () => {
        console.log('hi, afterTask in.');
    }
}).run(function () {
  zone.inTheZone = true;

  setTimeout(function () {
    console.log('in the zone: ' + !!zone.inTheZone);
  }, 0);
});

console.log('in the zone: ' + !!zone.inTheZone);
```

这段代码按照执行上下文顺序的执行，在zone的`run`函数执行的开始和结束会有对应的勾子函数进行处理，在执行环境中按照代码的执行顺序，最新看到的是`beforeTask`中的打印，接下来是最后边的打印，待到`setTimeout`方法执行后，完成整个任务并执行`afterTask`方法，该JavaScript代码的执行结果如下：

```HTML
hi, beforeTask in.
in the zone: false
in the zone: true
hi, afterTask in.
```

现在来概括下什么是Zone，它们基本上是获取到了一个异步操作的执行上下文，并且证明了在错误处理和分析非常有用，通常情况下，这些的异步处理，比如说是服务端异步返回所需要的数据，或者是一些异步事件更改视图模型的数据等，通过`beforeTask`和`afterTask`等勾子函数能够很好的在异步事件发生或者结束的时候，允许在这样的异步任务节点执行一些分析代码。

在一些复杂的业务逻辑场景下，上面提及的这些可能远远不够用，很多时候应用场景要比这个例子要复杂的多，`zone.js`采用猴子补丁(Monkey-patched)的方式将JavaScript中的异步任务都进行了包裹，同样的这使得这些异步任务都将运行在Zone的执行上下文中，每一个异步的任务在zone.js都是一个任务，除了提供了一些供开发者使用的勾子(hook)函数外，默认情况下zone.js重写了并提供了如下的方法:

- Zone.setInterval() / Zone.setTimeout()
- Zone.alert()
- Zone.prompt()
- Zone.requestAnimationFrame()
- Zone.addEventListener()
- Zone.removeEventListener()

综上所述，应该能理解Zone的应用场景了，即实现了异步task的跟踪分析和错误记录以便更好的进行开发debug等。

#### 深入理解Zone
通过上一小节可以看到，每一个Zone的勾子统一服务于该Zone下面的所有回调函数。在实际开发中，可能需要对回调函数分门别类，对不同类别的回调函数采用不用的处理方式。于是Zone.js引入了子Zone的概念：一个Zone可以包含多个子Zone，每个子Zone都有其独立的勾子，从而不同类别的回调函数就可以添加到不同的子Zone中去。

#### 创建子Zone
每个子Zone都是通过调用zone.fork()方法来创建，是父类Zone的一个实例，每一个Zone都有一个唯标识符，同时还可以通过parent属性来寻找上一级Zone。`zone.run()`方法接收一个方法作为参数，在该方法内，可以给异步事件添加回调函数，从而这些回调函数会被该zone所识别和统一管理，所有的业务代码都在`run`方法中执行，该`childZone`获取到了该业务代码的执行上下文并能通过勾子函数处理一些异步操作，还是用上面的例子说明如下：

```js
  // root zone
  console.log(zone.$id, zone.isRootZone());  // 打印输出为：1 true
  // 子zone
  var childZone = zone.fork({
    beforeTask: () => {
        console.log('hi, beforeTask in.');
    },
    afterTask: () => {
        console.log('hi, afterTask in.');
    }
}).run(function () {
  zone.inTheZone = true;

  setTimeout(function () {
    console.log('in the zone: ' + !!zone.inTheZone);
  }, 0);
});
  console.log(childZone.$id, childZone.isRootZone());  // 打印输出为：2 false
  // 通过parent属性来寻找上一级zone
  console.log(childZone.parent === zone);  //true
```

#### Zone的继承关系
Zone的父子关系除了通过parent属性来建立外，还遵循了JavaScript的原型继承，父Zone是子Zone的原型，每一个子Zone都可以直接访问其祖先zone的属性和方法，如下例子很好的说明了它们的继承关系。

```js
console.log(zone.isPrototypeOf(zone.fork()));  //true
```

再通过下面的例子来理解Zone的简单继承关系

```js
  zone.enqueueTask = function(){
    console.log(this === zone);  // this和zone变量均指向childZone
    console.log("enqueueTask hook of root zone");
  };
  let childZone = zone.fork();
  childZone.run(function(){
    setTimeout(() => {}, 30);
  });
```
`childZone`没有定义`enqueueTask`勾子，因此在用`setTimeout`添加回调函数的时候，会沿着原型链向上寻找，这里其实是调用跟（root）zone的勾子。值得注意的是，虽然调用的是跟zone的勾子，但是this指向的仍然是`childZone`。但是如下面的例子中在`childZone`中定义上`enqueueTask`勾子函数，那么在原型链上最先找到的就是子Zone中定义的`enqueueTask`勾子函数。

```js
  let childZone = zone.fork({
    enqueueTask: () => {
      console.log("enqueueTask hook of child zone");
    }
  });
```

除了简单的继承和覆盖，Zone.js还允许父子Zone的同名方法协同工作。Zone.js规定Zone的每一个方法都可以有四种状态，还是以`enqueueTask`为例，［enqueueTask］为标准状态，［-enqueueTask］为前置状态，［+enqueueTask］为后置状态，［$enqueueTask］为追溯状态，每一个zone的每一个方法只能定义一种状态，通过［+, -］来表示先后关系，其执行顺序为：前置`->`标准`->`后置。

下面的例子给子zone定义了一个后置钩子，因此在添加回调函数时，父zone的标准钩子先执行，然后再执行子zone的后置钩子。

```js
  zone.enqueueTask = function(){
    console.log("enqueueTask hook of root zone");
  };
  let childZone = zone.fork({
    "+enqueueTask": () => {
      console.log("enqueueTask hook of child zone");
    }
  });
  childZone.run(() => {
    setTimeout(() => {});
  });
```
代码执行结果如下：

```
enqueueTask hook of root zone
enqueueTask hook of child zone
```

通过前面的介绍可以了解到，Zone.js以同样的接口，不同的方式实现并替换了一系列与事件相关的标准方法。因此，当开发者使用标准接口的时候，实际上会先调用Zone.js的替换方法，再由这些方法调用底层的标准方法，不过这一对开发者透明的设计，使得可以在引入Zone的功能的时候，不需要对原有代码做太大改动成为可能。

#### Angular2中的ngZone
下面来介绍ngZone。实际上，ngZone是基于Zone.js来实现的，Angular2的ngZone从zone.js中fork了一份参考，它是Zone派生出来的一个子Zone，在Angular2环境内注册的异步事件都运行在这个子Zone上(因为ngZone拥有整个运行环境的执行上下文)，ngZone拓展了自己的一些API并添加了一些功能性的方法到它的执行上下文中，这些勾子方法如`onTurnStart`和`onTurnDone`事件也会在该子Zone的`run`方法中触发。另外值得提出的是，在ngZone的TypeScript定义中，并没有把这个子Zone给暴露出来，因此只能通过ngZone的提供的方法来间接地对该子Zone进行操作。

NgZone提供了一些我们能订阅的自定义事件，具体如下：

- `onTurnStart`即在Angular事件启动前通知订阅器，触发每一次是由Angular处理的浏览器任务事件。
- `onTurnDone`即在Angular zone完成当前任务时立即通知订阅者
- `onEventDone`在完成`onTurnDone()`回调之后在VM事件之前立即通知订阅者，常用来测试验证应用程序状态。

NgZone提供的这些自定义事件在跟踪定时器和其他微任务时是非常有用的，由于NgZone其实只是全局Zone的一个fork，Angular对于在Zone内需要或不需要执行变化检查，都具有完全的控制权，这为什么是有用的？因为我们并不总是希望Angular神奇地进行变化检测，具体我们会在下面的小节给您详细讲解。

综上所述，Zone几乎在任何浏览器的全局异步操作打上了猴子补丁，并且NgZone只是Zone fork出来的一份参考，当异步操作发生时就会通知框架进行变化检测，例如当类似于mousemove事件发生时，它也将引发变化检测。

在Angular2源码中，有一个`ApplicationRef`类，其作用是用来监听ngZone中的onTurnDone事件，不论何时只要触发这个事件，那么将会执行一个tick()方法用来告诉Angular去执行变化监测。Angular2变化检测的原理大致如此，具体的`ApplicationRef`类如下：

```js
  // very simplified version of actual source
  class ApplicationRef {
    changeDetectorRefs:ChangeDetectorRef[] = [];
    constructor(private zone: NgZone) {
      this.zone.onTurnDone.subscribe(() => this.zone.run(() => this.tick());
	 }
	 tick() {
	   this.changeDetectorRefs.forEach((ref) => ref.detectChanges());
	 }
  }
```

### 2.5.3 变化检测的响应处理
到目前为止，已经知道了何时会触发变化监测，但是变化检测是怎么响应处理的呢？这里需要理解的一个概念是，每个组件都会有它的变化监测器，一个Angular应用由一颗组件树组成，由此也将有一颗变化监测树，这种变化监测树是线性流向的，数据的流向是从上到下，这是因为变化检测的执行总是由根组件开始，从上到下的检测每一个组件的变化，单向的数据流相对环形数据流来说要更好预测的多，其实就更清楚视图中数据的来源，也就是说这些数据的变化是来自于哪个组件数据变化的结果。如前面所讲，当一个异步事件发生并导致数据的改变，在组件中绑定的相关处理事件将会被触发，NgZone将会去执行勾子函数并通知Angular执行一次变化检测。理论上在每一次变化检测不得不要去检测每一个组件的变化，但是执行这么一次完整的检测只需要几毫秒的时间就能完成。

#### 组件内部的变化检测的处理
Angular2在整个运行期间都会为每一个组件创建监测类，用来监测每个组件在每个运行周期是否有异步操作发生。任何的一个Angular2应用都是由大大小小的组件组成的，可以把它看成是一颗线性的组件树，重要的是，每一个组件都有自己的变化检测器，以此来组成了Angular2应用的一颗组件树，通过下面的例子来说明：

```js
@Component({
  template: '<v-card [vData]="vData"></v-card>'
})
class VCardApp {
  constructor() {
    this.vData = {
      name: 'Jason',
      email: 'Jason@gf.com.cn'
    }
  }

  changeData() {
    this.vData.name = 'Jofix';
  }
}
```
`VCardApp`把`<v-card>`作为一个子组件，其中有一个输入属性`vData`，数据通过`VCardApp`的对象`vData`传递到子组件，同样的，在组件中有一个`changeData`方法提供用来修改对象`vData`中的`name`属性值。当变化监测被执行时会发生什么呢？假象一下`changeData()`方法在一个异步的操作之后被执行，那么`vData.name`被改变，然后被传递到<v-card [vData]="vData"></v-card>的变化检测器来和之前的数据对比是否有改变，如果和参照数据对比有变动的话，Angular将更新视图。

那么在这个组件中，变化检测器是如何处理的呢？在`changeData()`被执行之后，属性值`name`被修改，然后被传递到`<v-vard>`组件中，该组件的变化检测器立刻校验`vData`对象和之前的参照对比是否有改变，如果没有改变的话，保持原有的参照不变，当其中的属性变化后，Angular将会针对这个`vData`对象执行变化检测。因为在JavaScript语言中不提供给我们对象的变化通知，所以Angular必须保守的要对每一个组件的每一次运行结果执行变化检测，但其实很多组件的输入属性是没有变化的，没必要对这样的组件来一次变化监测，如何减少不必要的监测，下文将继续探讨。

### 2.5.4 变化检测性能优化
上节中有讨论到Angular在有引起数据变化的操作发生时，将不得不在单次的运行期间对每个组件经行变化监测，当然在组件中有相关的变化的话这些检测是有意义的，但是在整个应用中，很多时候只是组件的局部有变化或者数据更改，但是Angular还是会针对每一个组件执行变化检测，这样的检测显然是有些浪费的。

事实上，在组件中数据的变化与否是有数据结构给我们提供担保的，下面将介绍`Immutables`和`Observables`，如果我们使用这些结构和类型，在Angular中做相应的标识，变化检测将会执行组件中有变化的部分，这样对变化监测性能的提升是有重大意义的。

#### 使用`immutable`机制提升检测性能
不可变对象(Immutable Objects)给我们提供的保障是对象不会改变，即当其内部的属性发生变化时，相对旧有的对象，我们将会保存另一份新的参照。它仅仅依赖输入的属性，也就是当输入属性没有变动（没有变动即没有产生一份新的参照），Angular将跳过对该组件的全部变化监测，直到有输入属性（@input）变化为止。如果需要在Angular2中使用不可变对象，我们需要做的就是设置changeDetection: ChangeDetectionStrategy.OnPush，如下的例子：

```js
@Component({
  template: `
    <h2>{{vData.name}}</h2>
    <span>{{vData.email}}</span>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
class VCardCmp {
  @Input() vData;
}
```

例子中，`VCardCmp`仅仅依赖它的输入属性，同时我们也设定了`ChangeDetectionStrategy`变化监测策略为`OnPush`来告诉Angular如果输入属性没有任何变化的话，则跳过对该子组件的变化监测。

```js
@Component({
  template: `
    <h2>{{vData.name}}</h2>
    <span>{{vData.email}}</span>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
class VCardCmp {
  @Input() vData;
}
```

现在想象一下应用中的那个巨大的组件树，当设置了`ChangeDetectionStrategy`变化监测策略为`OnPush`后，在`immutable`对象的属性不被改变的情况下，我们会跳过子组件的变化检测，只检测有改变的部分，相对于整个组件树的变化检测可想而知会有质的提升。

#### 使用`Observables`机制提升检测性能
使用`Observables`机制提升检测性能和不可变(immutable)对象类似，但它们有相关变化的时候不会提供一份新的参照，可观测对象在输入属性发生变化的时候来触发一个事件来更新组件视图，同样的，我们也是添加`OnPush`来跳过子组件树的监测器，但是它不会像之前的不可变对象那样在输入属性有变化的时候修改数据参照，那它是如何通知是否需要进行变化检测的呢？Angular针对特定的事件有一种非常智能的方式来启用组件树的路径来被检测，这种情形是非常的精确的，下面给这样的一个例子来帮你加深理解：

```js
@Component({
  template: '{{counter}}',
  changeDetection: ChangeDetectionStrategy.OnPush
})
class CartBadgeCmp {

  @Input() addItemStream:Observable<any>;
  counter = 0;

  ngOnInit() {
    this.addItemStream.subscribe(() => {
      this.counter++; // application state changed
    })
  }
}
```

该组件是模拟的当用户触发一个事件后增加counter这样一个场景，确切的讲，`CartBadgeCmp`设置了一个插值`counter`和一个输入属性`addItemStream`，该组件在其`ngOnInit`生命周期勾子中订阅了一个事件流来增加`counter`的数值，当有异步操作需要更新`counter`的时候，将会触发这个事件流。

值得一提的是，在这个例子中设置了变化检测策略为`onPush`，正是因为`addItemStream`不会再生产一份新的参考，这样的话整个运行期间，都不会对子组件执行变化检测了，那么，在输入属性有变化的时候，变化检测器怎么执行变化检测呢？否则的话达不到这个例子想要的目的了。如下图5-2所示，整个组件树灰色代表在有数据变化事件发生后，没有任何的变化检测。
![](https://github.com/gf-rd/gf-angular2-book/blob/master/_images/chapters2-2/change-detect-1.png?raw=true)

图 5-1 

正如前面了解到的那样，变化检测总是由根组件到具体的子组件这样一个从上到下的顺序执行的，这里所说的变化检测优化其实是要准确的知道当前变化的子组件到根组件的具体路径，变化检测仅仅就只按照这个路径检测，而不是整个组件树全部检测一遍。Angular是不知道那一条路径有改变的，但是我们知道，我们可以通过依赖注入给组件来引入一个`ChangeDetectorRef`，其中包含该一个`markForCheck`的标记方法，这个方法正是我们所需要的，它能标记有数据变化的子组件到跟组件的具体路径，代码示例如下：

```js
class CartBadgeCmp {
    constructor(private cd: ChangeDetectorRef) {}

    @Input() addItemStream:Observable<any>;
    counter = 0;

    ngOnInit() {
        this.addItemStream.subscribe(() => {
            this.counter++; // application state changed
            this.cd.markForCheck(); // marks path
        })
    }
}
```
当这个可监测的`addItemStream`触发一个事件，该事件处理句柄将会从根路径到这个已经改变的`addItemStream`组件来处理监测，一旦变化监测跑遍整个监测路径，它将会存储OnPush状态到整个组件树。这样做的好处是，变化监测系统将会走遍整棵树，你可以利用他们来监测树在局部是否有真正的改变，以此来做出相应的改变。变化检测到的路径是如下图5-2所标记的那样。
![](https://github.com/gf-rd/gf-angular2-book/blob/master/_images/chapters2-2/change-detect-3.png?raw=true)

图 5-2

#### 变化检测总结
- Angular2应用是一个是相应系统
- 变化检测系统是从根到叶的传播绑定
- 不像Angular1.x，变化监测图是一颗有向树，该系统使得性能表现更好和更可预测的
- 默认情况下，变化监测系统将会走遍整棵树，但是如果你使用不可变属性或者可观测对象，你可以利用他们来监测树在局部是否有真正的改变
- 这些优化组合不会扰乱提供的变化监测保障