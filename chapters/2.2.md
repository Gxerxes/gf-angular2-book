## 2 组件

&emsp;&emsp;组件（Component）是构成 Angular2 应用的基础和核心，了解它是如何工作是非常重要的，因此本书也将组件介绍在最前面。

&emsp;&emsp;组件是编写应用的基本单元，通俗地说，一个组件包装了一个特定的功能，并且组件之间协同工作以组装成一个完整的应用程序。

&emsp;&emsp;举个现实中的例子，一辆汽车中包含各种各样的部件、零件，比如发动机、变速箱、轮胎等等，那么这些便可以理解为组成汽车的`组件`，当然这还不是最小粒度的组件，例如发动机本身也会由众多小零件组合而成。

### 2.1 组件化的发展

&emsp;&emsp;前面的内容已经对组件有了初步的了解，下面来了解组件的概念是如何产生的，组件化又是如何发展的。

#### 2.1.1 模块化
&emsp;&emsp;谈到组件化，先要了解**模块化**。在 node.js 中，模块就是一个文件，引入一个文件就是简单地`require('xxx')`，其中 xxx 是文件名称或路径。在前端的领域，也衍生出不少模块化的规范，比如 AMD、CMD，不过前端领域发展得很快，因为还未形成一种统一的规范，目前（本书写作的时候）无论是AMD还是CMD都已经过时了，新兴的 ES6、TypeScript 均采用了类似 node 的 import module 的方式，配合 browserify、webpack 等构建工具将所有模块转换、打包成一个可用于浏览器运行的 js 文件。

> node.js 采用的是 CommonJS 规范。AMD 全称是 Asynchromous Module Definition，CMD 全称是 Common Module Definition，著名的 RequireJS、SeasJS 分别是 AMD、CMD 规范的实现之一。

&emsp;&emsp;在早期的模块化中，只是针对 js 部分做了处理，比如 AMD、CMD 的其中一个实现RequireJS、SeasJS 也只是管理 js 模块，缺少对 css、html 文件进行管理。后来逐渐形成按模块划分的概念，对比传统的按资源目录划分，从逻辑的意义上来说似乎更加合理，但是由于早期不能做到把三者（js、css、html）统一模块化，按模块划分的维护成本比较高。

&emsp;&emsp;按资源划分：

```
├── project
│   ├── css
│   ├── js
│   ├── img
│   ├── template
│   ├── index.html
```

&emsp;&emsp;按模块划分：

```
├── project
│   ├── shop
│   │   ├── shop.component.js
│   │   ├── shop.html
│   │   ├── shop.css        
│   ├── user
│   │   ├── user.component.js
│   │   ├── user.html
│   │   ├── user.css
│   ├── index.html
```

&emsp;&emsp;通过将 js、css、html 按逻辑模块划分后，使得逻辑结构更清晰了，这样逐步便形成了**组件**的概念。读者可以非常粗暴地理解，前端中的`组件`就是一堆为了实现同一业务逻辑的代码文件的组合。比如说上面按模块划分的结构中，user 便是一个实现用户相关逻辑的一个组件：

```
│   ├── user
│   │   ├── user.component.js
│   │   ├── user.html
│   │   ├── user.css
```

&emsp;&emsp;前端圈发懂得很快，各种库、框架层出不穷，例如Angular1、Backbone、Ember、React、Vue（排序按首字母）；工程化的工具也起来越多，例如Bower、Browserify、Grunt、Gulp、Webpack（排序按首字母）。近几年在技术领域中出现这么混杂又充满创新的景象，恐怕也只有在前端领域了。这一方面说明前端领域的创造力很强，另一方面也正说明了缺少标准，每个框架/库都有一套自己的组件化方式，包括本书讲解的 Angular2 也有自己的组件化方式。

&emsp;&emsp;业界为了统一组件化的标准方式，WebComponent 应运而生。

#### 2.1.2 组件化的标准
&emsp;&emsp;W3C 对 Web 组件提出了`WebComponent`的标准，通过标准化的非侵入方式封装组件，每个组件包含自己的 html、css、js 代码，并且不会对页面上其他代码产生影响。它包含以下几种重要的概念：

##### HTML导入
&emsp;&emsp;HTML 导入，是在一种在 HTML 文档中引入其他 HTML 文档的方法。在这个“其他” HTML 文档中，还能够和平常一样引入 CSS，JavaScript 等这些能在 .html 文件中能包含的任何内容。举个例子，有一个 bootstrap.html 包含了 Bootstrap 所需的各种文件：

```html
<link rel="stylesheet" href="bootstrap.css">
<script src="jquery.js"></script>
<script src="bootstrap.js"></script>
...

<!-- 还能定义一些模板 -->
<template>
  ...
</template>
```

&emsp;&emsp;然后在应用的 index.html 引入：

```html
<head>
  <link rel="import" href="bootstrap.html">
</head>
```

&emsp;&emsp;HTML 导入的功能使得开发者能够将开发好的一个模块写到一个 .html 文件去给他人使用，换句话说，仅用一个 URL，就可以将多个文件封装成一个文件提供给他人使用。

##### 模板
&emsp;&emsp;模板允许开发者预先写好一些 html 标记，用于后续使用或复用。如果你使用过 angular1.x 或者 handlebars 之类的东西，你应该熟悉模板是什么。例如：

```html
<template>
  <h1>Hello!</h1>
  <p>You can't see this script in the page.</p>
</template>
```

&emsp;&emsp;所有在`template`中的脚本都被浏览器看作“静态”的东西，换句话说所有写在`template`里面的像\<img\>、\<video\>这些标签引用的资源都不会被加载，\<script\>标签也不会被执行，里面所有的标签也都不会被渲染到页面中。直到我们使用 javascript 去控制它。

##### Shadow DOM
&emsp;&emsp;通过 Shadow DOM 可以在文档流中创建一些完全独立于其他元素的 DOM 子树，这个特性可以可以让开发者开发一个独立的组件，并且不会干扰到其它 DOM 元素（非侵入的方式）。Shadow DOM 和标准的 DOM 行为一样，可以通过 html、css、js 去定义。居于这个特性，使得组件的复用变得简单。

##### 自定义元素
&emsp;&emsp;WebComponent 规范允许开发者声明一个语义化的自定义元素来引用组件：

```html
<template id="hello-template">
  <h1>Hello!</h1>
</template>

<script>
  // 获得上面的模板
  var tmpl = document.querySelector('#hello-template');

  // 创建一个新元素的原型，继承自 HTMLElement
  var HelloProto = Object.create(HTMLElement.prototype);

  // 设置 Shadow DOM 并将模板的内容 clone 进去
  HelloProto.createdCallback = function() {
    var root = this.createShadowRoot();
    root.appendChild(document.importNode(tmpl.content, true));
  };

  // 注册新元素
  var Hello = document.registerElement('hello', {
    prototype: HelloProto
  });
</script>
```

&emsp;&emsp;目前的浏览器只有 Chrome 和 Opera 对 WebComponent 的支持度比较高，其他浏览器不能运行使用 WebComponent 标准写的哪怕是很简单的 hello-world 代码。Google 官方出口的 Polymer 框架则比较接近 WebComponent 的写法，它简直就是面向未来的框架。同样也是出自 Google 之手的 Angular2 ——也就是本书的内容——的概念也有几分相似，虽然 Angular1 也能写模板和自定义元素，但 Angular2 的组件化比 Angular1 更加彻底。

### 2.2 组件基本概念
&emsp;&emsp;前面的章节已经介绍了 Angular2 是什么，以及为什么要使用它。本章的开头也介绍了组件及组件化的概念，在 Angular2 中，组件是非常重要的组成部分，一种更面向对象的方法来开发Web 应用。

&emsp;&emsp;如果读者写过 Java 或者 C#，或者其他强面向对象的语言，你会很容易理解“组件”，它实际上是一个类，一个有着自己特定的成员数据，并根据成员数据的特性将自己渲染到屏幕上的类。Angular2 也不外乎这些，先看看 Hello World：

```typescript
import {Component, OnInit, ViewEncapsulation} from '@angular/core';
import {bootstrap} from '@angular/platform-browser-dynamic';

@Component({
  selector: 'hello-world',
  template: '<div>Hello World, {{name}}</div>',
  encapsulation: ViewEncapsulation.None
})
export class HelloWorldComponent implements OnInit {
  constructor() {
    this.name = 'Super Man';
  }
  ngOnInit() {
    console.log('HelloWorldComponent inited');
  }
}

bootstrap(HelloWorldComponent, [])
```

&emsp;&emsp;然后在 index.html 的 body 中，用上 hello-world 组件：

```html
<body>
  <hello-world>Loading...</hello-world>
</body>
```

&emsp;&emsp;上面的代码大概的意思是创建了一个叫 HelloWorldComponent 的组件，这个组件有一个`name`的成员数据，它将 template 里指定的 div 渲染到了页面上，并且在组件初始化时输出`HelloWorldComponent inited`。所有的 Angular2 应用都需要通过 bootstrap 去启动。

&emsp;&emsp;以上代码，也展示了 Angular2 及组件的一些核心概念：

> - 自定义标签（selector）
> - 模板（template）
> - 视图包装（view encapsulation）

##### 自定义元素
&emsp;&emsp;Angular2 允许开发者自定义元素名称，在刚才的示例代码中，`selector: hello-world`就给 HelloWorldComponent 定义了一个新的元素名称`hello-world`，在相应的 index.html 里，就可以这样去使用了`<hello-world>Loading...</hello-world>`。

> 为什么要在`hello-world`之间加上一句`Loading...`？这是因为在 Angular2 还没解析好组件并渲染到页面上时，可以看到一个加载的提示。当然也可以不加上。

##### 模板
&emsp;&emsp;和很多框架一样，Angular2 也提供模板机制，允许开发者预先定义好一系列 DOM 结构，以用于填充数据。例子中的`template: '<div>Hello World, {{name}}</div>'`便为 HelloWorldComponent 指定了模板内容。关于模板的更多内容，请参考**模板**章节。本节也会作简单的介绍。

&emsp;&emsp;和 DOM 树类似，Angular2 的应用是一棵组件树，每个组件都是一个`类`，有自己的生命周期，组件使用`@Component`修饰符（Decorator）来修饰。

&emsp;&emsp;每个组件都应有它对应的模板，通过`template`或`templateUrl`来指定。模板决定了组件在页面上的展现方式。

##### 视图包装
&emsp;&emsp;相比 Angular1，这是一个新的特性，并且可以配置使用原生的 Shadow DOM，它的主要目的是让组件的样式之间更加“独立”而互不影响，使得组件间的复用变得更简单。ViewEncapsulation 有三个可选的值：

- ViewEncapsulation.None - 无 Shadow DOM，并且也无样式包装。
- ViewEncapsulation.Emulated - 无 Shadow DOM，但是通过 Angular2 提供的样式包装机制来模拟组件的独立性，使得组件的样式不受外部影响。
- ViewEncapsulation.Native - 使用原生的 Shadow DOM 特性。

##### 数据交互
&emsp;&emsp;Angular2 通过单向的数据流，将更新应用模型（Application Model）和视图状态（View State）分成两个阶段：开发者负责更新模型；Angular2 则通过变更检测（Change Detection）自动更新对应的视图。

&emsp;&emsp;事件绑定（Event Bindings），开发者可以通过`()`操作符将事件绑定到组件中，当浏览器触发了该事件，则此绑定的组件方法便会执行，这便是第一种情况：开发者通过定义方法来更新模型。

&emsp;&emsp;属性绑定（Property Bindings），开发者可以通过`[]`将组件中的属性绑定到模板上，这样当组件中的属性变化时，Angular2 的变化检测机制便会自动更新该组件的对应视图。

&emsp;&emsp;相对于组件的模板来说，属性绑定是一种`数据输入`，用`@Input`定义，通过`[]`语法调用；事件绑定则是`数据输出`，使用`@Output`定义，通过`()`语法调用。

### 2.3 组件基本构成
&emsp;&emsp;上一小节对组件的核心概念有了基本的认识，现在通过联系人 Demo 来深入学习组件。

![Dialog](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapters2-2/ng2-contact-demo.png)

图2-1 通讯录 Demo

#### 应用的根组件（ContactApp）
&emsp;&emsp;一般来说，每一个应用程序都有自己的根组件（一般被命名为 XxxApp 或 XxxAppComponent，本例子中是 ContactApp），当应用被启动（bootstrap）时，Angular 会从根组件开始启动，并解析组件树。

&emsp;&emsp;contact-app.ts 部分代码

```typescript
import {Component, OnInit} from '@angular/core';
...

@Component({
  selector: 'contact-app',
  templateUrl: 'app/contact-app.html',
  styleUrls: ['app/contact-app.css']
})
...
export class ContactApp implements OnInit{
  constructor() {}

  ngOnInit(){
  }
}
```
&emsp;&emsp;代码中的`import`在之前也出现了不少次，如果读者了解 NodeJS 的话，这里也很容易理解，因为 Angular2 所有的模块都是依照 NodeJS 的规范去管理的，这里的意思就是从`node_modules`的`@angular`模块中的`core`子模块，导入`Component`和`OnInit`这两个接口。

> OnInit 是组件生命周期中的初始化，后续内容将会讲述。

&emsp;&emsp;然后代码定义了一个`ContactApp`的类，并用`@Component`修饰符修饰了这个类，这是用于定义 Angular2 组件的修饰符，它使得这个类“成为” Angular2 的一个组件。这是 Angular2 提供的一种便捷的语法，除此之外 Angular2 还提供了其他很多很有用的修饰符，用于对开发者定义的类进行修饰，使得这个类可以”装配“上特定的功能。例如上面的代码，通过`selector`、`templateUrl`和`styleUrls`分别定义了组件的标签、模板以及组件的样式。

&emsp;&emsp;每个组件，更准确来说，每个类都会有一个构造方法`constructor`，在构造方法中可以用于声明一些类的属性或做一些**简单的**初始化操作。注意这里用了“简单的”词眼，像变量赋值初始化这些便是“简单的”操作。一般不建议在构造方法里做复杂的初始化操作，例如我们经常会在页面 loaded 之后获取数据，相应地类似这些操作不建议放在构造方法中，而建议放在`ngOnInit`中，保持构造方法的简洁。

&emsp;&emsp;刚才也提到了`OnInit`接口，这个组件实现了这个接口。这是 TypeScript 提供的一种语法约束，类似 Java 中的 Interface，当组件声明了要实现某个接口时，相应地就必须添加该接口的方法实现。例如`OnInit`对应的方法便是`ngOnInit`，以上代码实现了这个接口方法，方法体为空。

#### @Component

&emsp;&emsp;任何一个组件，都会有类似这么一段代码：

```typescript
@Component({
  selector: 'my-component',
  template: '<div>My first component</div>'
})
export class MyComponent { }
```

&emsp;&emsp;每个组件类都会被`@Component`修饰，如果移除了这个修饰器这个组件就没有任何意义了，它将不再是 Angular2 的组件。那么这个修饰器是什么？有什么作用？浏览器如何解释它？

&emsp;&emsp;可以看到，通过`import {Component} from 'angular2/core'`可以看到，`@Component`是从`angular2/core`导入的，在 Angular2 的源码中：

```typescript
export declare var Component: ComponentMetadataFactory;
```

```typescript
export interface ComponentMetadataFactory {
  (obj: {
    ...
  }): ComponentDecorator;
  new (obj: {
    ...
  }): ComponentMetadata;
}
```

> interface 是 TypeScript 里定义的内容，具体可以参考 TypeScript 官网的教程。在这里读者只需要知道，**`Component`是具有这个接口定义的所有属性和方法的一个类**即可。

&emsp;&emsp;由于目前的浏览器还不能直接解释 TypeScript 代码，最终会通过解析器转换成 JavaScript 代码，解析器的选择有很多，比较流行的是 Babel、Traceur，上述组件转换后的代码如下（示意）：

```javascript
var MyComponent = (function () {
  function MyComponent() {}
  MyComponent = __decorate([
    core_1.Component({
      selector: 'my-component',
      template: '<div>My first component</div>'
    })
    __metadata('design:paramtypes', [])
  ], MyComponent);
  return MyComponent;
}());
```

&emsp;&emsp;可以看到，Angular2 通过`@Component`将`MyComponent`这个类“装饰”起来，使`MyComponent`具有 Angular2 组件定义的一切属性。Angular2 提供的`@`操作符来实现修饰组件，并没有什么特别之处，可以理解为对组件封装的语法糖，方便开发者编写 Angular2 的组件。

&emsp;&emsp;正如你所知的，`MyComponent`是一个普通的类，那么自然地这个类也可以自定义成员变量、方法，封装自己的业务逻辑。

```typescript
@Component({
  selector: 'my-component',
  template: '<div>My first component</div>'
})
export class MyComponent {
  private _customVar: number = 0;
  constructor() {
  }
  
  customMethod() {
    _customVar = 1;
  }
}
```

#### 应用的启动（Bootstrap）

&emsp;&emsp;app.ts 部分代码

```typescript
import {bootstrap} from '@angular/platform-browser-dynamic';
...
import {ContactApp} from './app/contact-app';


bootstrap(ContactApp, ...)
```

&emsp;&emsp;有了根组件，还需要告诉 Angular2 去启动它。因为 Angular2 的启动是平台相关的，它能实现在后端渲染以提高页面输出的速度以及优化 SEO，现在此处需要在浏览器端渲染，所以代码中从`plattorm-browser-dynamic`导入了`bootstrap`这个方法。启动应用很简单，将根组件作为第一个参数传入`bootstrap`即可。

&emsp;&emsp;最后，别忘了还需要在 index.html 中写上你的根组件要渲染的位置。

```html
<body>
  <contact-app>
    Loading...
  </contact-app>
</body>
```

&emsp;&emsp;在本例子中，`contact-app.html`模板中只有以下几行代码，因为首页使用了**页面路由**，关于页面路由的更多内容，请参阅**路由**章节，现在先跳过这一部分知识，来看看首页的组件`ContactList`。

```
<main class="main">
  <router-outlet></router-outlet>
</main>
```

### 2.3 组件功能详解
&emsp;&emsp;上一小节对组件的概念已经有了基本的认识，这一节再通过深入 Demo 来学习 Component 常用的元数据（metadata）以及字段修饰器。

#### 2.3.1 @Component 常用的元数据
&emsp;&emsp;一起来看看 `contact-list.ts` 这个文件中的 @Component 修饰器部分：大部分组件都会使用到这些元数据——`selector`、`templateUrl/template`、`styleUrls/styles`、`directives`。

```typescript
...
@Component({
  selector: 'list',
  templateUrl: 'app/components/contact-list/contact-list.html',
  styleUrls: ['app/components/contact-list/contact-list.css'],
  directives: [
    ROUTER_DIRECTIVES,
    Footer,
    ListChildrenComponent
  ]
})
...
```

*此处的 ListChildrenComponent 以及 list 可能要规范一下*

##### selector（string）
&emsp;&emsp;用于定义组件在 HTML 代码中匹配的标签。selector 参数是必须设置的，它将成为新组件的命名标记，它的工作原理很像 querySelector，会返回文档中选择器匹配到的第一个元素。

> 事实上 selector 也可以忽略不指定，此时默认会变成 div，但绝对不要这样做，因为这样组件会无法准确定位 DOM 中的元素。
> 
> selector 的命名方式建议使用“烤肉串式”命名，即名称全小写，并以`-`分隔。例如`contact-app`、`hello-world`。

&emsp;&emsp;在 Demo 中，`ContactList`是展示在首页——联系人列表的组件，在上一小节**应用的启动**中，说到了需要在 index.hmlt 中写中根组件的渲染位置，因为其中用到了**路由**，此处先不展开路由的细节，读者只需要知道，当你通过`npm start`并在浏览器输入`http://localhost:3000`时，会默认展示`ContactList`这个组件的内容，可以理解为，路由中默认将这个组件的内容显示了出来，相当于以下代码：

```typescript
<main class="main">
  <list></list>
</main>
```

&emsp;&emsp;`ContactList`中的`selector`设置为`list`，那么 Angular2 便会通过查找 DOM 上的一个 list 元素，从而将**组件的内容**显示在页面上。那么**组件的内容**又是怎么指定的？这就要用到 template/templateUrl 。

##### template（string）
&emsp;&emsp;为组件指定一个内联模版。

> 关于模板的更多内容，请参见**模板**章节。
> 
> 如果要写内联模板，建议使用ES6的``语法，能够轻松创建多行模版。
> 
> ```typescript
>   template: `
>     <div>
>       <div>Inner Div</div>
>     </div>
>   `
> ```

##### templateUrl（string）
&emsp;&emsp;为组件指定一个外部模版的 URL 地址

```typescript
  templateUrl: 'app/components/contact-list/contact-list.html',
```
> 每个组件只能指定一个模版，templateUrl 或 template。
>
> 总的来说，本书更推荐使用 templateUrl ，因为无论如何，组件的内容都会由不少 DOM 元素组成，在 .ts 文件里写一长串 html 代码不是一个好主意。除非你确定你的组件就是一两行极简的代码，并且不会发生什么变化，此时可以使用 template。

&emsp;&emsp;在本 Demo 中，使用了 templateUrl，为`ContactList`指定了一个`contact-list.html`模板，它的内容如下：

```typescript
<h3>所有联系人<i (click)="addContact()"></i></h3>
<ul class="list">
  <li *ngFor="let contact of contacts">
    <list-li [contact]="contact" (routerNavigate)="routerNavigate($event)"></list-li>
  </li>
</ul>
<my-footer [path]="path" (writeTitle)="writeTitle($event)"></my-footer>
```

&emsp;&emsp;于是乎，Angular2 便在`<list></list>`这个位置，将`contact-list.html`的内容都渲染到 DOM 上了。这就是 selector 以及 template/templateUrl 的作用。

> 读者应该会注意到，`contact-list.html`模板中，会用到一些未曾见过的写法，比如`(click)="addContact()"`、`*ngFor="let contact of contacts"`、`[contact]="contact"`，这些都是 Angular2 提供的语法糖，`()`和`[]`在本章节会学习到，并且读者能在 list-li.ts 中看到`@Input @Output`这样的写法，在本章节稍后会讲述。而`*ngFor`是 Angular2 内置的指令，它将成员变量`contacts`遍历并依次显示在页面上。可参阅**指令**章节了解更多内容，接下来先继续学习组件的其他的元数据。

##### styles（string[]）
&emsp;&emsp;为组件指定内联样式。

```typescript
  styles: [
    `
    li:last-child{
      border-bottom: none;
    }
    `
  ]
```

##### styleUrls（string[]）
&emsp;&emsp;为组件指定一系列用于该组件的样式表文件。

```typescript
  styleUrls: ['app/components/contact-list/contact-list.css'],
```

> styles 和 styleUrls 允许同时指定。如果同时指定，styles 中的样式会先被解析，然后才会解析 styleUrls 中的样式。换句话说，styles 的样式会被 styleUrls 的样式覆盖。
> 
> 强烈建议，styles 或 styleUrls 只使用其中一个设置。另外，像 templateUrl 那样，本书也建议使用 styleUrls 将样式表文件分开，这样代码结构更清晰，更易于管理。

&emsp;&emsp;细心的话可以注意到，styles/styleUrls 是复数，所以要使用数组来承载样式表字符串或样式表文件路径字符串，Angular2 允许使用多个样式表文件，来同时渲染一个组件。

&emsp;&emsp;开发者也可以使用一些 css 预处理器比如 sass 来更好地编写样式代码。在本 Demo 中，使用了 webpack 作为工程化的工具，可以很方便地集成。在 webpack.config.js 中的 loaders 设置项下，加上以下代码

```javascript
{test: /\.scss$/, loader: 'raw-loader!sass-loader', exclude: /node_modules/},
```

&emsp;&emsp;并通过`npm install sass-loader`，便可以在代码中使用了，例如`ContactList`引用的样式可以改成：

```typescript
  styleUrls: [require('app/components/contact-list/contact-list.sass')],
```

##### directives（Array\<Type | any[]\>）
&emsp;&emsp;指定可以在模版中使用的指令/组件列表。除了 Angular2 默认提供的指令，即 ng 开头的如 ngFor 等不需要显式指定外，自定义的指令或组件必须明确指定，否则在组件中无法正确使用它们。

&emsp;&emsp;例如在 contact-list.ts 的代码中，需要指定了`Footer`和`ListChildrenComponent`这两个组件，然后才能在模板 contact-list.html 中使用它们：

&emsp;&emsp;contact-list.ts 部分代码：

```typescript
...
@Component({
  ...
  directives: [
    ROUTER_DIRECTIVES,
    Footer,
    ListChildrenComponent  // 引入了 Footer、ListChildrenComponent 两个组件
  ]
})
...
```
&emsp;&emsp;contact-list.html：

```html
<h3>所有联系人<i (click)="addContact()"></i></h3>
<ul class="list">
  <li *ngFor="let contact of contacts">
    <!-- 组件中指定了 ListChildrenComponent，才能使用 list-li 标签 -->
    <list-li [contact]="contact" (routerNavigate)="routerNavigate($event)"></list-li>
  </li>
</ul>
<!-- 组件中指定了 Footer，才能使用 my-footer 标签 -->
<my-footer [path]="path" (writeTitle)="writeTitle($event)"></my-footer>
```

> 关于指令的更多内容，请参阅**指令**章节。

#### 2.3.2 组件的常用功能

&emsp;&emsp;组件的模板最终是会解析到 DOM 上的，所以组件必然要和一个 DOM 元素关联，该 DOM 元素称为宿主元素。Angular2 提供了丰富的功能实现了宿主元素和组件之间的交互：

- **变量显示**，将组件的成员变量通过插值的语法显示到宿主元素上
- **事件绑定**，监听宿主元素的事件，响应用户的输入
- **属性绑定**，更改宿主元素的属性，改变组件的显示
- **依赖组件**，通过指定依赖的组件实现更丰富的组件功能
- **自定义内容**，通过使用 ng-content 来创建可复用的组件

##### 使用插值显示组件属性

&emsp;&emsp;先看看 Demo 中的联系人详细页，从首页点击任一个联系人进去，显示的便是`ContactDetail`组件的内容。

![Dialog](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapters2-2/demo-contact-detail.png)
图2-2 联系人详细页

&emsp;&emsp;在该页面中，有很多显示联系人信息的字段如手机号码、邮箱等，右上方有个“编辑”按钮，头像右边有个收藏按钮。

&emsp;&emsp;contact-detail.ts 部分代码。`ContactDetail`这个类中定义了三个成员变量`contact_id`，`detail`和`contacts`。

```typescript
...
export class ContactDetail implements OnInit, OnDestroy {
  contact_id: number;
  detail:any = {};
  contacts:any = {};
  
  ...
  
  ngOnInit() {
    this.contact_id = parseInt(this._routeParams.get('id'));
    this.getById(this.contact_id);
  }
  
  ...
  
  getById(id:number) {
    let ss_contacts = sessionStorage.getItem('contacts');
    if(ss_contacts) {
      this.contacts = JSON.parse(ss_contacts);
      this.detail = this.contacts[id-1];
    }else {
      this._constactService.getContactById(id).subscribe(data => {
        this.detail = data;
      });
    }
  }
}
```

&emsp;&emsp;我们来看看`detail`，它是联系人信息的对象。`ContactDetail`实现了`OnInit`和`OnDestroy`这两个**生命周期**的方法，并且在`ngOnInit`的时候，初始化了成员变量。之后，Angular2 便会将在模板中引用到的`detail`成员变量的属性（如手机号码`detail.telNum`）显示到宿主元素上。

> 生命周期是组件的关键概念，详情请参阅本章的后续小节。

&emsp;&emsp;在对应的模板 contact-detail.html 中，需要用`{{}}`语法，来显示成员变量的值。

```html
...
    <li>
      <p>手机号码：</p>
      <p>{{ detail.telNum }}</p>
    </li>
...
```

> 这种语法`{{}}`在 Angular2 中称为**插值**，本质上**插值**和**属性绑定**都属于 Angular2 中的**数据绑定**的概念，但是属性绑定是指在元素的属性上的数据绑定，并且使用的语法并不一样，于是本书将它们分开讲解。
> 
> 关于插值、数据绑定的更多内容，请参阅**模板**章节。

##### 事件绑定响应用户输入
&emsp;&emsp;Angular2 提供了非常方便的事件绑定的方式，读者在上面也看到了`(click)`这样的用法，`()`是 Angular2 提供的事件绑定语法糖，通过`(eventName)`的方式可以轻易地响应UI事件。

&emsp;&emsp;看看 contact-detail.html 中的点击编辑按钮的代码。

```html
...
    <a class="edit" (click)="editContact()">编辑</a>
...
```

&emsp;&emsp;“编辑”按钮在用户点击时，便会触发 click 事件，从而调用到组件的`editContact()`方法，跳转到编辑联系人的页面。

```typescript
...
  editContact() {
    this._router.navigate(['Operate',{id: this.contact_id}]);
  }
...
```

&emsp;&emsp;事件绑定还支持传递事件参数`$event`，例如在刚才的“编辑”按钮里，如果加上这个参数，在组件中的方法便能得到这个参数，从而获得事件信息如点击的元素、坐标等。

```html
...
    <a class="edit" (click)="editContact($event)">编辑</a>
...
```

```typescript
...
  editContact($event) {
    this._router.navigate(['Operate',{id: this.contact_id}]);
    console.log($event.type); // 此处会打印 click
  }
...
```

&emsp;&emsp;正如本章**组件基本概念**中所描述的，事件绑定在 Angular2 中是一种单向的数据流，**事件及包含事件的数据**由 Angular2 内部处理，从宿主元素中传递到组件，使得组件能够与模板的事件进行交互。

> 关于事件绑定的更多内容，请参阅**模板**章节的相关部分。

##### 属性绑定将变化渲染到页面
&emsp;&emsp;相对于事件绑定，属性绑定则是 Angular2 通过变化检测机制，及时检测到组件成员变量的变化，并将变更重新渲染到宿主元素的 DOM 上的过程。这种数据流向也是单向的，**成员变量**数据通过 Angular2 的处理，传递到宿主元素。

> 变化检测机制，也是组件的核心概念，详情请参阅本章的**变化检测机制**小节。

&emsp;&emsp;请看例子中的 contact-detail.html 的代码片段

```html
...
      <span class="contact-name">
        {{ detail.name }}
        <i [ngClass]="{collect: detail.collection == 0, collected: detail.collection == 1}" (click)="collectTheContact()"></i>
      </span>
...
```

&emsp;&emsp;当点击头像右下方的“收藏”标记时，会触发 click 事件并调用组件的`collectTheContact`方法，该方法会将成员变量`detail`的`collection`属性由0变为1，或由1变为0，即是否收藏该联系人。

```typescript
  ...
  collectTheContact() {
    this.detail.collection == 0 ? this.detail.collection = 1 : this.detail.collection = 0;
    ...
  }
  ...
```

&emsp;&emsp;回头看 html 中的代码，注意其中的`[ngClass]`中使用到了`detail.collection`这个变量的值去判断，当为0时，使用`collect`这个样式，当为1时，使用`collected`这个样式。当相应的变量值被改变时，Angular2 的变更检测便会检查到，从而根据模板中的表达式去更新 DOM。

> 以上例子使用的是`ngClass`，事实上，更准确来说这是一个**指令**，而不是 DOM 对象的属性。广义的属性绑定包括了 DOM 元素的属性、组件的属性、指令属性三种。
> 
> 关于属性绑定的更多内容，请参阅**模板**章节的相关部分。

##### Input、Output 和 EventEmitter
&emsp;&emsp;刚才学习了通过 Angular2 提供的内置事件和指令，实现了响应页面的 click 事件，以及将组件成员变量的变化更新到页面中。回想一下在`contact-list.html`中，有这么一段代码

```typescript
  <li *ngFor="let contact of contacts">
    <list-li [contact]="contact" (routerNavigate)="routerNavigate($event)"></list-li>
  </li>
```

&emsp;&emsp;此处的`[contact]`和`(routerNavigate)`，Angular2 提供了 Input、Output 和 EventEmitter，可以自定义的属性绑定和事件绑定。

&emsp;&emsp;在`ListChildrenComponent`组件中，引入了 @angular/core 中的 Input 和 Output，修饰并定义了两个成员变量：

```typescript
  @Input() contact:any = {};
  @Output() routerNavigate = new EventEmitter<number>();
```

&emsp;&emsp;顾名思义，Input 和 Output 分别指输入输出，读者可以理解为，被`@Input`修饰的`contact`变量属于输入属性，而被`@Output`修饰的`routerNavigate`则是输出事件，这里的“输入输出”均是以当前组件角度去说的，换句话说，`contact`和`routerNavigate`分别是`ListChildrenComponent`组件的输入和输出。输出一般是以事件的形式，将数据通过 EventEmitter 抛出去，这部分属于组件交互的内容，读者可以阅读本章的**组件交互**小节了解更多。

&emsp;&emsp;除了使用`@Input`和`@Output`修饰外，还可以在组件的元数据中使用 inputs、outputs 设置，设置的值必须为字符串数组，元素的名称需要和成员变量相对应。上述代码和以下代码是等价的：

```typescript
// 部分代码
@Component({
  ...
  inputs: ['contact'], // 'contact'匹配成员变量 contact
  outputs: ['routerNavigate'] // 'routerNavigate'匹配成员变量 routerNavigate
})

export class ListChildrenComponent implements OnInit {
  contact:any = {};
  routerNavigate = new EventEmitter<number>();
  ...
}
```

##### 引入其他依赖组件
&emsp;&emsp;在前面的`ContactList`中提到过 directives，可以使用它来引入其他组件或指令，使得开发复杂的组件变得更容易。该部分内容会在**指令**章节重点介绍。

```typescript
@Component({
  ...
  directives: [ // 指定该组件依赖的其他组件或指令
    ROUTER_DIRECTIVES,
    Footer,
    ListChildrenComponent
  ]
})
```

&emsp;&emsp;组件中另一个常用的功能是管道（pipes），通过在组件的元数据中指定 pipes，便可以在模板中使用它，管道的主要作用是用来格式化数据，通常这对于国际化很有用处。在本书 Demo 的`ContactDetail`中，可以看到 pipes 的用法。关于管道的更多知识，请参阅**模板**章节的相关部分。

```typescript
@Component({
  ...
  pipes: [DateReform] // 引入自定义的管道，用于格式化日期
})
```

&emsp;&emsp;还有两个很重要的是 providers 和 viewProviders，可以为组件注入指定的服务。此内容会在**服务**章节重点介绍。

##### 自定义内容
&emsp;&emsp;自定义内容有时被认为是一个高级的功能，使用自定义内容能很好地扩充组件的功能，特别是在需要创建团队、项目之间共享的通用的 HTML 代码片段的时候。

> 接触过 Angular1 的读者，相信对这个自定义内容的知识不会陌生，它和 Angular1 中指令的 `transclude`属性非常类似。

&emsp;&emsp;自定义内容通用用来创建可复用的组件，典型的例子是模态对话框或导航栏。想像一下，在开发 Web 应用的时候，模态对话框和导航栏是使用得非常频繁的功能，自定义内容的特性正是提供了一种复用的方式，使得复用的组件具有样式完全一致的，但内容可自定义的组件。

&emsp;&emsp;假设有一个“黑色边框”的组件，叫 BlackBoarder，我们把这个组件的外观统一成黑色的边框，无论里面的内容怎么变化。假设它的模板是这样子：

```html
<div style="border:1px solid black">
  <ng-content></ng-content>
</div>
```

&emsp;&emsp;然后，你在其他地方使用了这个组件：

```html
<black-border>
  <h1>This is the content of black board!</h1>
</black-border>
```

&emsp;&emsp;最后模板会被渲染成：

```html
<div style="border:1px solid black">
  <h1>This is the content of black board!</h1>
</div>
```

&emsp;&emsp;甚至还可以通过选择器来指定 ng-content，假设有一个叫 BoarderComponent 的组件的模板如下：

```html
<div style="border:1px solid black">
  <ng-content select="header"></ng-content>
</div>
<div style="border:1px solid red">
  <ng-content select="div.body"></ng-content>
</div>
<div style="border:1px solid orange">
  <ng-content select="footer"></ng-content>
</div>
```

&emsp;&emsp;然后在别的地方这样去使用它：

```html
<borders-component>
  <header>I'm a header</header>
  <div class="body">I'm a body</div>
  <footer>I'm a footer</footer>
</borders-component>
```

&emsp;&emsp;渲染后的结果是：

```html
<div style="border:1px solid black">
  <header>I'm a header</header>
</div>
<div style="border:1px solid red">
  <div class="body">I'm a body</div>
</div>
<div style="border:1px solid orange">
  <footer>I'm a footer</footer>  
</div>
```

#### 2.3.3 @Component 的其他元数据

##### properties（string[]）
&emsp;&emsp;这是旧版本的属性，可忽略，相当于 inputs。

##### events（string[]）
&emsp;&emsp;这是旧版本的属性，可忽略，相当于 outputs。

##### host（{[key: string]: string}）
&emsp;&emsp;host 是个非常强大的元数据，它主要用在指令中，通过 host 可以指定此指令/组件的事件、动作和属性等。因为 @Component 继承自 @Directive，所以 @Directive 中的配置也同样适用于组件。更多内容请参阅**指令**章节。

##### exportAs（any[]）
&emsp;&emsp;此属性主要在指令中使用，作用是将指令分配给一个变量，使用这个名称就可以在模版中调用指令。因为 @Component 继承自 @Directive， 所以 @Directive 中的配置也同样适用于组件。更多内容请参阅**指令**章节。

##### moduleId（any[]）
&emsp;&emsp;包含该组件模块的 id，它被用于解析模版和样式的相对路径。在 Dart 中，它可以被自动确定，并不需要去设置。在 CommonJS 中，它总是被设置为 module.id。 

##### queries（{[key: string]: any;}）
&emsp;&emsp;设置需要被注入到组件的查询。有两种查询，视图查询和内容查询，分别会在ngAfterViewInit和ngAfterContentInit回调函数被调用之前设置。

&emsp;&emsp;假设有种场景，你的组件里有一个输入框（input），希望在组件初始化之后，将焦点设置到输入框中。传统的做法，可能会是用代码选中 input 在 DOM 中的节点，然后调用 focus 方法。

```typescript
@Component({
  selector: 'my-input',
  template: `
    <input type="text" />
    <div>Input Component</div>
  `
})
export class MyInput {
  constructor(el: ElementRef) {
    // 直接操作 ElementRef 对应的 DOM 节点（不推荐）
    el.nativeElement.querySelector('input').focus();
  }
}
```

&emsp;&emsp;然而这种做法不推荐，只有极少的情况需要直接操作 DOM。angular2 提供了一系列高阶 APIs 来替代 DOM 操作，例如现在正在讲解的 queries。利用 angular2 提供的这些 APIs 的好处有：

- 降低单元测试复杂度
- 从浏览器中解耦，允许代码在任何渲染环境里运行（比如：Web Worker，或者服务器端，又或者是在 Electron 里）

&emsp;&emsp;那么上述例子可以用 queries 来优化。可以使用视图查询 @ViewChild/@ViewChildren 这两个 queries 获取当前组件模版里的内嵌组件到组件的成员变量中，当组件初始化后，就可以通过 renderer 执行 focus 方法了。

```typescript
@Component({
  selector: 'my-input',
  template: `
    <input #theInput type="text" />
    <div>Input Component</div>
  `
})
export class MyInput implements AfterViewInit {
  @ViewChild('theInput') input: ElementRef;

  constructor(private renderer: Renderer) {}

  ngAfterViewInit() {
    this.renderer.invokeElementMethod(this.input.nativeElement,    
    'focus');
  }
}
```

&emsp;&emsp;读者可能有疑问，上面的代码 queries 在哪里？事实上，上面的代码和下面的代码是等价的：

```typescript
@Component({
  selector: 'my-input',
  template: `
    <input #theInput type="text" />
    <div>Input Component</div>
  `,
  queries: {
    input: new ViewChild('theInput')
  }
})
export class MyInput implements AfterViewInit {
  input: ElementRef = null;

  constructor(private renderer: Renderer) {}

  ngAfterViewInit() {
    this.renderer.invokeElementMethod(this.input.nativeElement,    
    'focus');
  }
}
```

&emsp;&emsp;以上便是视图查询，简言之借助视图查询和 Angular2 提供的 APIs 可以获得在组件模板上定义的 DOM 节点。那么内容查询又是什么呢？和视图查询类似，只不过内容查询是配合 ng-content 使用的，它用来获得不在组件模版定义里定义的元素。假设有一个列表组件 MyList，它允许用户自定义内容，然后你需要列表的数量。既然是自定义的内容，那我们不可能要求用户能在内容里写上元素的 id，即不能通过 id 去获取，可以通过选择器指令。

&emsp;&emsp;假设用户使用 MyList 写的代码如下：

```html
<my-list>
   <li *ngFor="#item of items"> {{item}} </li>
</my-list>
```

&emsp;&emsp;然后你需要获得 li 的列表，可以使用 `@Directive` 修饰器，它提供了 selector 的功能，据此来定义一个能查找/选择 `<li>` 元素的指令，用 `@ContentChildren` 获得 li 元素。

```typescript
// 定义 li 选择器，命名为 ListItem
@Directive({ selector: 'li' })
export class ListItem {}

// 组件代码，使用 ng-content 允许自定义内容
@Component({
  selector: 'my-list',
  template: `
    <ul>
      <ng-content></ng-content>
    </ul>
  `
})
export class MyList implements AfterContentInit {
  @ContentChildren(ListItem) items: QueryList<ListItem>;

  ngAfterContentInit() {
     // 此时便能对 items 进行操作
  }
}
```

&emsp;&emsp;以上代码，和以下使用 queries 的代码也是等价的：

```typescript
@Component({
  selector: 'my-list',
  template: `
    <ul>
      <ng-content></ng-content>
    </ul>
  `,
  queries: {
    items: new ContentChildren(ListItem)
  }
})
export class MyList implements AfterContentInit {
  items: QueryList<ListItem>;

  ngAfterContentInit() {
  }
}
```

##### changeDetection（ChangeDetectionStrategy）
&emsp;&emsp;定义使用的变化检测策略。

&emsp;&emsp;当组件被实例化，Angular2 创建一个变动监测器，它负责传播组件的绑定。通过修改此属性，来为组件选择是每次变化检测都会被检查还是只有组件告诉它的时候才触发。不同的策略包括：

- Default：CheckAlways
- OnPush
- Detached
- CheckAways
- Checked
- CheckOnce

&emsp;&emsp;可以设定具体的检查策略减少检查的次数，来提高程序的性能。

> 更详细的内容，请参阅本章节的**变化检测机制**小节。

##### pipes（Array\<Type | any[]\>）
&emsp;&emsp;用于指定组件对应的模板中使用的属性过滤、格式化处理的类，更多的内容请参阅**模板**章节的相关内容。

##### encapsulation（ViewEncapsulation）
&emsp;&emsp;在本章的开头部分，提到了**视图包装**这个特性，它的主要目的是让组件的样式之间更加“独立”而互不影响，使得组件间的复用变得更简单。ViewEncapsulation 有三个可选的值：

- ViewEncapsulation.None - 无 Shadow DOM，并且也无样式包装。
- ViewEncapsulation.Emulated - 无 Shadow DOM，但是通过 Angular2 提供的样式包装机制来模拟组件的独立性，使得组件的样式不受外部影响。
- ViewEncapsulation.Native - 使用原生的 Shadow DOM 特性。

###### ViewEncapsulation.None
&emsp;&emsp;Angular 不使用 Shadow DOM。应用在组件的样式会被写到 Document 头部。

&emsp;&emsp;假设有一个 Hello 的组件和模板如下：

```typescript
import {ViewEncapsulation} from '@angular/core';

@Component({
  selector: 'hello',
  templateUrl: 'hello.html',
  styles: [`
    .hello {
      background: green;
    }
  `],
  encapsulation: ViewEncapsulation.None
})
class Hello {
}
```

```html
<div class="hello">
  <h1>Hello World</h1>
</div>
```

&emsp;&emsp;Angular 会将其渲染成：

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      .hello { 
        background: green;
      }
    </style>
  </head>
  <body>
    <hello>
      <div class="hello">
        <h1>Hello World</h1>
      </div>
    </hello>
  </body>
</html>
```

&emsp;&emsp;ViewEncapsulation.None 设置的结果是没有 Shadow DOM，并且所有的样式都是应用到整个 document，换句话说，组件的样式可以被覆盖。

###### ViewEncapsulation.Emulated
&emsp;&emsp;无 Shadow DOM，但是通过 Angular2 提供的样式包装机制来模拟组件的独立性，使得组件的样式不受外部影响。这是 Angular2 的默认选项。

&emsp;&emsp;这是个强大的功能，组件间的样式是相互独立不影响的，这样怎么做到的呢？还是刚才的例子，使用了这个设置后，Angular 会将它渲染为：

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      .hello[_ngcontent-1] { 
        background: green;
      }
    </style>
  </head>
  <body>
    <hello _ngcontent-0 _nghost-1>
      <div class="hello" _ngcontent-1>
        <h1>Hello World</h1>
      </div>
    </hello>
  </body>
</html>
```

&emsp;&emsp;虽然样式仍然是应用到整个 document，但是 Angular 为`.hello`创建了一个`[_ngcontent-1]`选择器。没错，组件的样式选择被 Angular 修改了，并且在组件的属性里也添加上了这个选择器。那`_ngcontent-0`和`_nghost-1`又是干什么用的呢？为了实现局部的样式，Angular 需要保证某个组件的样式只会匹配到该组件，所以给组件添加了`_ngcontent-0`和`_nghost-1`属性。

###### ViewEncapsulation.Native
&emsp;&emsp;使用原生的 Shadow DOM 特性。理解这个就非常简单了，Angular 会把组件以浏览器支持的 Shadow DOM 形式渲染，像刚才的例子在浏览器中能看到这样的结构：

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      .hello[_ngcontent-1] { 
        background: green;
      }
    </style>
  </head>
  <body>
    <hello>
      #shadow-root
      | <style>
      |   .hello {
      |     background: green;
      |   }
      | </style>
      | <div class="hello">
      |  <h1>Hello World</h1>
      | </div>
    </hello>
  </body>
</html>
```

### 2.4 组件的生命周期

> 关于组件的生命周期，可继续阅读“指令”的生命周期章节。
> 组件继承自指令，因此它们具有相同的生命周期实现。

&emsp;&emsp;使用过 Angular1 的读者应该知道，Angualr1 中有构造函数，$watch 方法和 $destroy 事件可以尝试挂接控制器中生命周期的各个时间点。在 Angular2 中，生命周期的含义被定义得更加明确，包括但不限于 ngOninit、ngOnDestroy、ngOnchanges。当组件实现一些生命周期钩子的回调，那么在变化检测的时候就会在特定的时间点被触发。

&emsp;&emsp;当组件被创建的时候构造函数被调用，获取到组件的初始状态，如果组件依赖子组件中的属性或数据，我们需要等它初始化完毕。要做到这一点，我们可以处理 ngOnInit 生命周期事件，或者可以在构造函数里调用 setTimeout 能达到同样效果。就像 ngOnInit，我们可以追踪一个组件生命周期中很多事件的足迹。

#### 2.4.1 生命周期勾子
&emsp;&emsp;指令或组件实例都有一套生命周期，表现在 Angular 对它们的创建、更新和销毁。

&emsp;&emsp;开发者可以实现一个或者多个 “生命周期钩子（接口）” ，从而在生命周期的各阶段作出适当的处理。这些钩子接口包含在 angular2/core 中。

&emsp;&emsp;以下是所有的生命周期钩子接口，Angular 会依序调用下列钩子方法：

- ngOnChanges
- ngOnInit
- ngDoCheck
- ngAfterContentInit
- ngAfterContentChecked
- ngAfterViewInit
- ngAfterViewChecked
- ngOnDestroy

##### OnChanges
&emsp;&emsp;在 Angular1 中，如果想要监听数据的变化，需要设置$scope.$watch，然后在每次 digest 循环里判断数据是否有改变。在 Angular2 中，ngOnChanges钩子把这个过程变得简单。只要在组件里定义了 ngOnChanges 方法，在输入数据发生变化时该方法就会被自动调用。

&emsp;&emsp;需要注意的是，ngOnChanges 当且仅当组件输入数据变化时被调用，“输入数据”指的是通过`@Input`修饰器显式指定的那些数据。如果是在`@ViewChildren`，`@ContentChildren`的结果集增加/删除了数据，ngOnChanges 是不会被调用的。

&emsp;&emsp;如果希望在 queries 结果集变化时收到通知，可以通过 changes 属性订阅其内置的observable。一般在`ngAfterContentInit`或`ngAfterViewInit`中去监听，而不是在构造器里或`ngOnInit`中。

```typescript
@Component({
  selector: 'my-list',
  template: `
    <ul>
      <ng-content></ng-content>
    </ul>
  `
})
export class MyList implements AfterContentInit {
  @ContentChildren(ListItem) items: QueryList<ListItem>;

  ngAfterContentInit() {
    this.items.changes.subscribe(() => {
       // 当 items 增加/删除了数据后，这里会被调用
    });
  }
}
```

##### OnInit
&emsp;&emsp;使用 ngOnInit 有两个重要的原因：

1. 构造后不久就要进行复杂的初始化
2. 在 Angular 设置输入属性之后就要设置组件

&emsp;&emsp;在 Angular2 的组件中，经常会使用 ngOnInit 获取数据，那为什么不在组件构造函数中获取数据呢？因为构造函数做的事，应该是尽可能简单的，例如初始化局部变量这种简单的事情。这对于有经验的开发人员来说，已经是一种共识。另外，这对于 Angular2 的自动化测试也有非常重要的作用，因为编写测试代码的开发人员，不需要担心一个新的组件在测试或者创建之前会尝试连接远程服务器获取数据。

##### DoCheck
&emsp;&emsp;开发者可以使用 DoCheck 钩子来检测并在 Angular 没有捕捉到自身变化的时候采取行动。通过这个方法可以检测到 Angular 忽略的这一变化。

&emsp;&emsp;ngDoCheck 被调用的频率很高 —— 每一个变化检测周期后，不管是否发生了变化。大多数这些初步检查是由 Angular 在网页其他地方不相关的数据第一次渲染的时候触发，例如简单地将鼠标移到另一个输入框就会触发调用。显然，ngDoCheck 方法中不能写一些复杂的代码，否则用户体验就会受到影响。

##### AfterContentInit
&emsp;&emsp;ngAfterContentInit 会在 Angular 将外部内容放到视图内之后调用。

##### AfterContentChecked
&emsp;&emsp;ngAfterContentChecked 会在 Angular 检测放到视图内的外部内容的绑定后调用。

##### AfterViewInit
&emsp;&emsp;ngAfterViewInit 会在 Angular 创建了组件视图之后被调用。

##### AfterViewChecked
&emsp;&emsp;ngAfterViewChecked 在 Angular 检测了组件视图的绑定之后调用。

##### OnDestroy
&emsp;&emsp;组件在被销毁之前会触发这个勾子，ngOnDestroy 会被调用。建议把组件成员变量等东西的清理逻辑放到 ngOnDestroy 中，它是在指令/组件销毁之前必定运行的逻辑。在这个时候可以通知另一部分关心的程序，这个组将将要被销毁。

&emsp;&emsp;不会被垃圾处理自动收集的资源应当在这个地方去释放，例如订阅了的观察者事件，绑定过的 DOM 事件，通过 setTimeout 或 setInterval 设置过的计时器等，都应当在 ngOnDestroy 中去注销、删除所有与该组件相关的回调。如果忽略这些的话，会导致一些意想不到的后果，并有可能导致内存泄漏。


## 2.4 组件交互

从前面的章节了解到，组件是由大大小小的组件树组成，数据的共享是通过不同的组件或者指令来完成，那么一个组件是如何与其它组件进行数据传递交互的呢？你可能会想到这样的场景，使用输入绑定从父组件向子组件传递数据，在子组件中使用`setter`或者`ngOnChanges`拦截输入属性的变化，这样就实现了数据从父组件到子组件的交互，同样的，父组件可以绑定相关事件，由子组件来触发该事件来达到数据交互的目的。这就是组件交互的大致实现方式，组件交互是什么呢？组件交互就是组件通过一定的方式来达到有权限访问其它组件中对应的属性或者方法来实现数据的双向流动的一种方式。

除了前面介绍的，组件交互还有丰富的形式供你选择，比如父子组件通过本地变量交换数据，除了父子组件之间通过分享数据接口实现组件的双向通信服务外，还有一些结构上不相关的组件，即父子组件通过service通信，那么本节将重点讲述如下的几种组件交互：

- 使用输入绑定从父组件向子组件传递数据
- 使用`setter`&`ngOnChanges`拦截输入属性的变化
- 父组件监听子组件事件
- 父子组件通过本地变量交换数据及父组件调用ViewChild
- 父子组件通过service通信

### 2.4.1 父组件向子组件传送数据
#### 使用输入绑定从父组件向子组件传递数据
本章将讲解父组件和子组件通过输入输出属性来完成组件间的交互，读者朋友可能会对输入输出（@Input&@Output）这些概念有些模糊，通过后面的例子讲解来一起学习这些概念，同时理解组件间的数据交互。下面将通过使用输入绑定从父组件向子组件传递通讯录列表数据来简单讲解组件的数据交互。

如前面的通讯录联系人列表，该列表可能包含多个联系人，联系人中需要展示的信息为联系人姓名`name`和联系人电话号码`telNum`等，这两个属性包含在`contact`对象下，在这个组件中是没有任何获取`contact`对象的动作，数据的来源是通过由装饰器`@Input()`装饰来获取，这个`contact`对象来自于其父组件`ListComponent`，通过属性绑定的方式将值赋值给这个表达式，简单的代码示例如下：

```js
@Component({
  selector: 'contact-list',
  template: `
  	<li>
	  <contact-child class="contact-info">
	    <label class="contact-name">{{ contact.name }}</label>
	    <span class="contact-tel">{{ contact.telNum }}</span>
	  </contact-child>
	</a>
	</li>
  `,
  directives: [ ROUTER_DIRECTIVES , Footer]
})

export class ContactListComponent {
  @Input() contact: contact;
}
```

父组件`ListComponent`通过`ngFor`属性指令（属性指令请参考模板章节的具体详解）将每个`contact`实例对象通过属性绑定绑定到其孩子属性`contact`中。通过上面的@Input修饰器注入到子组件`ContactListComponent`中。具体的代码示例如下：

```js
@Component({
  selector: 'list',
  template: `
  	<ul class="list">
	  <contact-child *ngFor="let contact of contacts" [contact]="contact">
	  </contact-child>	
	</ul>
  `,
  directives: [ ROUTER_DIRECTIVES , Footer, ContactListComponent]
})

export class ListComponent implements OnInit {
  this.contacts = data; // 伪代码获取到联系人数据
}
```
不过需要注意的是，目标属性必须通过输入属性明确的标记修饰，对于此例，也就是说必须在子组件中用装饰器`@Input`修饰，通过模板绑定表达式把数据流入绑定的属性中。

前面也讲解到组件是由大大小小的组件树组成，当应用被启动（即bootstrap）时，Angular会从根组件开始启动，并解析组件树，该小节例子通过以上两个父子组件的数据交互，实现了通过使用输入绑定从父组件向子组件传递数据，数据由父组件流出，通过输入属性流入子组件。

#### 使用setter&ngOnChanges拦截输入属性的变化
##### 利用input的setter和getter属性做拦截
上一节中讲到了通过输入属性来实现父子组件的数据交互，除此之外，组件还可以通过输入属性`setter`来拦截来自父组件的数据，并对拦截到的数据进行在处理，使数据的输出更加合理和可控。下面的例子中，父组件将继续沿用前面的`ListComponent`组件，仅仅对子组件修改如下：

```js
@Component({
  selector: 'contact-list',
  template: `
  	<li>
	  <contact-child class="contact-info">
	    <label class="contact-name">{{ contact.name }}</label>
	    <span class="contact-tel">{{ contact.telNum }}</span>
	  </contact-child>
	</a>
	</li>
  `,
  directives: [ ROUTER_DIRECTIVES , Footer]
})

export class ContactListComponent {
  _contact: object = {};
  @Input()
  set contact(contact: object) {
    this._contact.name = (contact.name && contact.name.trim()) || 'no name set';
    this._contact.telNum = contact.telNum || '000-000';
  }
  get contact() { return this._contact; }
}
```
当父组件`ListComponent`中的联系人有增删改等变化时，`contact`对象的值在子组件`ContactListComponent`中被`setter`拦截器拦截，将数据展示到视图层，在这里，你甚至在子组件可以对拦截到的数据进行再处理，使得数据处理的自由度更高，数据的展示更符合预期等。

##### ngOnChanges监听数据变化
在生命周期的勾子章节中已经了解过生命周期勾子接口`OnChanges`其中的方法`ngOnChanges`，通过`ngOnChanges`方法能够监测数据的变化并处理数据的变化，下面将举例来详细讲解ngOnChanges监听数据变化，该例子中，通过点击修改按钮来做修改操作，这里我们仅仅是统计修改的次数，即每次点击修改按钮`changeTelCount`的统计数字加1，以此来输出联系人修改前后的数据对比。

```js
import { Component } from '@angular/core';
import { ContactChildComponent } from 'contact-child.component';

@Component({
  selector: 'detail',
  templateUrl: `
  	<a class="edit" (click)="editContact()">修改联系人telNum</a>
  	<contact-child [name]="name" [changeTelCount]="changeTelCount"></contact-child>
  `,
  directives: [ ROUTER_DIRECTIVES ]
})

export class EditContactComponent {
  name: string = 'test';
  changeTelCount: number = 0;
  
  editContact() {
    this.changeTelCount++;
  }
}
```
在子组件中，通过`ngOnChanges`方法来监测数据变化前后的数据，`ngOnChanges`方法具体监测原理将在下面的变化监测章节中详细讲解，其中的`previousValue`是修改前的数据，`currentValue`是修改后当前联系人的数据。每次点击父组件的修改按钮，都会在changeLog中记录了数据的变化并以文本的形式输出到页面上。

```js
import { Component, Input, OnChanges, SimpleChange } from '@angular/core';

@Component({
  selector: 'contact-child',
  template: `
    <h3>Contact name: {{name}}, changeTelCount: {{changeTelCount}}</h3>
    <h4>Change log:</h4>
    <ul>
      <li *ngFor="let change of changeLog">{{change}}</li>
    </ul>
  `
})
export class ContactChildComponent implements OnChanges {
  @Input() name: string;
  @Input() changeTelCount: number;
  changeLog: string[] = [];
  ngOnChanges(changes: {[propKey:string]: SimpleChange}){
    let log: string[] = [];
    for (let propName in changes) {
      let changedProp = changes[propName];
      let from = JSON.stringify(changedProp.previousValue);
      let to =   JSON.stringify(changedProp.currentValue);
      log.push( `${propName} changed from ${from} to ${to}`);
    }
    this.changeLog.push(log.join(', '));
  }
}
```
在子组件中，我们能捕获到父组件中数据的变化，甚至变化的细节都可以通过`changedProp`的属性来监测变化的细节。该例子中会逐条输出变化的log，清晰的看到修改的次数变化。

### 2.4.2 子组件向父组件传送数据

#### 父组件监听子组件事件
子组件通过暴露一个`EventEmitter`属性，这个属性是一个输出属性，由装饰器@Output装饰，该属性当有用户行为操作发生时事件会被触发，父组件则通过事件的绑定，当有具体事件触发时会具体反应在该组件当中，请看下面的例子。

```js
import { Component, EventEmitter, Input, Output } from '@angular/core';
@Component({
  selector: 'contact-collect',
  template: `
    <h4>{{name}}</h4>
    <button (click)="collect(true)"  [disabled]="collected">Collect</button>
  `
})
export class ContactCollectComponent {
  @Input()  name: string;
  @Output() onCollected = new EventEmitter<boolean>();
  collected = false;
  collect(flag: boolean){
    this.onVoted.emit(flag);
    this.collected = true;
  }
}
```
父组件`CollectTakerComponent`通过绑定事件`onCollected`来处理数据的变化

```js
import { Component }      from '@angular/core';
import {ContactService} from '../services/contact-service';
import { VoterComponent } from 'contact-collect.component';
@Component({
  selector: 'collect-taker',
  template: `
  	 <h3> Collected: {{collected}}, NoCollected: {{noCollected}}</h3>
    <contact-collect *ngFor="let contact of contacts"
      [name]="contact.name"
      (onCollected)="onCollected($event)">
    </contact-collect>
  `,
  directives: [ContactCollectComponent]
})
export class CollectTakerComponent {
  constructor(
    private _constactService: ContactService
  ) {}
  
  ngOnInit() {
    this.collected = 0;
    this.noCollected = 0;
    this.getContacts();
  }
  
  getContacts() {
    this._constactService.getContactsData().subscribe(data => {
      this.contacts = data;
    });
  }
  
  onCollected(collected: boolean) {
    collected ? this.collected++ : this.noCollected++;
  }
}
```

#### 通过局部变量调用子组件的成员函数或者成员变量
父组件不能使用数据绑定来读写子组件的相关成员变量，也不能调用子组件的相关成员变量方法，但是我们可以间接的通过创建模板局部变量来实现这种场景，即在父组件的模板中为子组件的模板创建一个局部变量，那么这个父组件可以通过这个局部变量来获得读取子组件成员变量的权限，也可以获取到调用子组件中成员方法的权限，现在用通讯录例子中收藏的例子来说明，具体例子如下：

```js
import { Component, EventEmitter, Input, Output } from '@angular/core';
@Component({
  selector: 'contact-collect',
  template: `
    <h4>{{name}}</h4>
    <button (click)="collect(true)"  [disabled]="voted">Collect</button>
  `
})
export class CollectActionComponent {
  contact_id: number;
  detail:any = {};
  contacts:any = {};

  constructor(
    private _router: Router,
    private _routeParams:RouteParams,
    private _constactService:ContactService
  ){}
  
  ngOnInit() {
    this.contact_id = parseInt(this._routeParams.get('id'));
    this.getById(this.contact_id);
  }
  
  getById(id:number) {
    let ss_contacts = sessionStorage.getItem('contacts');
    if(ss_contacts) {
      this.contacts = eval('(' + ss_contacts + ')');
      this.detail = this.contacts[id-1];
    }else {
      this._constactService.getContactById(id).subscribe(data => {
        this.detail = data;
      });
    }
  }
  
  collectTheContact() {
    this.detail.collection == 0 ? this.detail.collection = 1 : this.detail.collection = 0;
    let ss_contacts = sessionStorage.getItem('contacts');
    this.contacts = eval('(' + ss_contacts + ')');
    this.contacts[this.contact_id-1].collection = this.detail.collection;
    sessionStorage.setItem('contacts',JSON.stringify(this.contacts));
  }
}
```
这是一个联系人收藏的功能，该组件在`collectTheContact`方法实现了收藏的功能，但是在父组件中是没有调用`collectTheContact`的权限的，同样的也不可能获取到这个联系人`collection`的属性，这个时候可以通过定义局部模板变量`#collect`来实现（具体可以参考第三章的模板局部变量章节），即在标签元素`<collect-action>`中放置一个局部变量`collect`来代表子组件并获取到了子组件，该变量获取到了这个子组件本身的一份参考，并能被父组件获取到该子组件中成员变量和方法的权限，父组件的代码示例如下：

```js
import { Component, EventEmitter, Input, Output } from '@angular/core';
@Component({
  selector: 'contact-collect',
  template: `
    <span class="contact-name">
        {{ detail.name }}
        <i [ngClass]="{collect: collect.detail.collection == 0, collected: collect.detail.collection == 1}" (click)="collect.collectTheContact()"></i>
      </span>
      <collect-action #collect></collect-action>
  `
})
export class ContactCollectComponent {
  
}
```
在这整个例子中，通过点击收藏按钮来实现收藏功能，具体功能的实现在子组件中实现。

#### 使用`@viewChild`获取子组件的引用
使用局部变量实现父组件调用子组件的成员函数或者成员变量，这样看上去既简单也容易，但是这样也有它的一些局限性，就是必须在父组件的模板中对应上“父-子”关系的写法，这样的耦合性还是有一定的代价的，并且父组件并不是真正的获取到了子组件的成员变量和方法的权限。

当父组件需要获取到子组件中变量或者方法的读写权限时，可以通过注入的方式来实现，即在父组件中通过`ViewChild`注入子组件。下面的例子继续用上节中收藏的例子，要实现的功能一样，其中子组件的代码还是一样，对父组件修改如下：

```js
import { Component } from '@angular/core';
@Component({
  selector: 'contact-collect',
  template: `
    <span class="contact-name">
        {{ detail.name }}
        <i [ngClass]="{collect: detail.collection == 0, collected: detail.collection == 1}" (click)="collectTheContact()"></i>
      </span>
      <collect-action></collect-action>
  `
  directives: [CollectActionComponent]
})
export class ContactCollectComponent {
  @ViewChild(CollectActionComponent)
  private actionComponent: CollectActionComponent;
  
  collectTheContact() {
    this.actionComponent.collectTheContact();
  }
}
```
这种实现方式把按钮绑定到了父组件中，同时在父组件的组件类中来调用子组件中的方法，其中通过@ViewChild装饰器将`CollectActionComponent`子组件注入进来，并实现了一个私有的`actionComponent`属性。

### 2.4.3 父组件和子组件通过服务进行交互
在前面两个小结中提到的组件交互，其实并没有真正实现实际的交互通信，这种数据的流动设计是由数据驱动，并由事件改变的。本节将重点讲解父子组件之间通过共享一个`service`的接口实现组件的双向通信服务,该服务实例的作用范围是父组件和它的孩子们，在这个组件树之外的组件没有权限接入到服务并进行通信的。

下面实现一个`SharedService`来供`parentComponent`和`ChildComponent`共享这个实例，通过在子组件中的输入框来添加数据，以此来实现组件中的交互通讯。这个公共的service代码如下所示：

```js
import {Injectable} from 'angular2/core';

@Injectable()
export class SharedService {
  dataArray: string[] = [];

  insertData(data: string){
    this.dataArray.unshift(data);
  }
}
```

在父组件`parentComponent`中，逐条展示每条数据，同时引入子组件`<child-component>`来处理数据源，父组件的代码示例如下：

```js
import {Component} from 'angular2/core';
import {SharedService} from './shared.service';
import {ChildComponent} from './child.component';
@Component({
  selector: 'parent-component',
  template: `
    <ul *ngFor="#data in data">
      <li>{{data}}</li>
    </ul>
    <child-component></child-component>
  `,
  providers: [SharedService],
  directives: [ChildComponent]
})
export class parentComponent{
  data: string[] = [];
  constructor(private _sharedService: SharedService) {}
  ngOnInit():any {
    this.data = this._sharedService.dataArray;
  }
} 
```
在子组件`ChildComponent`中，设置一个点击按钮来处理增加的数据，当在该组件中添加数据后，能在父组件中实时的反应出来。

```js
import {Component} from 'angular2/core';
import {SharedService} from './shared.service'

@Component({
  selector: 'child-component',
  template: `
    <input type="text" [(ngModel)]="data"/>
    <button (click)="addData()"></button>
  `
})
export class ChildComponent{
  data: string = 'Testing data';
  constructor(private _sharedService: SharedService){}
  addData(){
    this._sharedService.insertData(this.data);
      this.data = '';
  }
}
```

组件间通过共享一个service实例来进行数据的交互，在父组件的元数据中的`provide`引入这个共享的实例对象，而在子组件中则不需要这样做，但是在子组件中需要通过`import`来引入这个service，并且在构造函数`constructor`注入即可。

## 2.5 变化监测机制
在`Angular2`中提供了数据绑定的功能（在模板章节会详细介绍），所谓数据绑定即将数据和页面DOM元素关联起来，当数据发生变化或者更改后，Angular2能够检测到这些变化或者更改，并对其所绑定的DOM元素进行相应的更新，反之亦然。它的数据流向是单项的，通过属性绑定和事件绑定来实现数据的流入和流出，数据从属性绑定流入组件，从事件流出组件，`Angular2`数据的双向绑定就是通过这样来实现的。

### 2.5.1 引起数据变化的来源
试想一下，页面数据在什么样的场景下会发生更改？在现有的应用场景下，开发者们大致认为有如下3类：

- `event`类，即页面操作所引发的用户事件，如click, change, hover等；
- `xmlHTTPRequest/webSocket`类，即从远端服务拉取对应的数据，这是一个异步的过程；
- `timeout`等页面的各类定时任务，如`setTimeout, setInterval, requestAnimationFrame`，都是在某个延时后触发。

以上的共同特征是什么？很明显共同点是它们都是异步的处理，即需要使用异步回调函数，这带给我们的结论就是，任意的一个异步操作，都有可能在数据层面上发生改变，这可能导致应用程序状态已经被改变，因此，如果可以在每一个异步回调函数执行结束后，能够通知`Angular2`内核进行更改检测，那么任何数据的更改就可以被实时地反应出来。

下面举个简单的例子进行说明,可以在组件的模板元数据中添加如下代码片段：

```html
<i [ngClass]="{collect: detail.collection == 0, collected: detail.collection == 1}" (click)="collectTheContact()"></i>
```
该例子是一个通讯录收藏的功能实现，当用户点击收藏按钮后，这将告诉`Angular2`此时的`detail.collection`数据发生改变，通知视图层做出相应的改变等。

正如上面的例子，通过属性绑定实现了数据从父传递给了子，而事件绑定则实现了数据由子到父的传递，这也就是`Angular2`用来实现数据双向绑定的方法。它实现的是单向流的数据传递，也就是说，数据流只能向下流入组件，如果需要进行数据变化，可以发射导致变化的事件到顶部，待数据变化处理完成，然后再往下流入组件。那么问题来了，`Angular2`如何知道数据是否已经处理处理完成，这份新的数据是否有变化，如果数据有变化，那是怎么来通知数据往下流入组件通知组件来改变视图呢？下面给读者介绍变化的通知机制。

### 2.5.2 变动通知机制
上一小节介绍了可能引起页面数据的几种场景，通过异步处理来通知页面重新更新数据源，因此，如果可以在每一个异步回调函数执行结束后，能够通知NG2内核进行更改检测，那么任何数据的更改就可以被实时地反应出来，那么，Angular2是通过什么样的机制来进行变化通知的呢？Angular2本身是不具备这样的通知机制的，为了实现这种机制，引入了ngZone这个服务。

为了更好的让您理解ngZone这个服务，本文先介绍zone的原理。

#### zone的实现原理
Zone实际上是Dart的一种语言特性，其是对Javascript某些设计缺陷的一些补充，简单的可以概述成Zone是一个异步事件拦截器，也就是说Zone能够hook到异步任务的执行上下文，以此来处理一些操作，比如说，在每次启动或者完成一个异步的操作、进行堆栈的跟踪处理、某段功能代码进入或者离开Zone，可以在这些关键的节点重写所需处理的方法。

Zone中提供了各类勾子（hooks），允许在每一个回调函数的开始和结束时，去执行统一的自定义逻辑，其本身是不做任何事的，相反它是依赖其它的代码，获取到这些代码片段的执行上下文，通过勾子来完成相关的功能。Zone的另一值得一提的是它必须依赖异步操作，当一个异步操作在执行时，它是有必要去捕获的这个异步操作并在该异步功能开始或者完成时建立对应的回调函数，然后存储到当前的Zone，举个例子，如果一个代码片段在fork的Zone中执行，并且这段代码中包含一个`setTimeout`的异步任务，那么执行到和完成这个`setTimeout`方法需要包裹一个异步的回调函数，存储到当前zone，这样是确保每个异步操作之间的相互不受影响，也就是受保护的状态，例如一个页面由业务代码和一些第三方广告代码组成，这两份代码之间是相互独立的，需要的是业务代码的异常捕获数据提交到自己的后台服务器上，第三方广告代码的异常捕获提交到自己的服务器上。当fork了多个Zone之后，异步操作将会精准的执行其所在的子Zone上面方法。

Zone的一个重要意义在于，所以来的功能或者业务代码运行在了fork的一个Zone中，该子Zone有了对该代码块执行上下文的控制权。其中也提供了一些勾子(hook)来处理基本的业务情景需求，这里你需要了解的勾子函数大致有：

- `Zone.onZoneCreated`即在Zone被fork时运行
- `Zone.beforeTask`即在执行`zone.run`包裹的函数之前调用
- `Zone.afterTask`即在执行`zone.run`包裹的函数之后调用
- `Zone.onError`即`zone.run`方法中的任务抛出异常时的勾子函数

通过上面的讲述您应该对Zone的实现原理有个大致的理解了，下面举个例子来加深对Zone的理解：

```js
zone.fork({
    beforeTask: () => {
        console.log('hi, beforeTask in.');
    },
    afterTask: () => {
        console.log('hi, afterTask in.');
    }
}).run(function () {
  zone.inTheZone = true;

  setTimeout(function () {
    console.log('in the zone: ' + !!zone.inTheZone);
  }, 0);
});

console.log('in the zone: ' + !!zone.inTheZone);
```

这段代码按照执行上下文顺序的执行，在zone的`run`函数执行的开始和结束会有对应的勾子函数进行处理，在执行环境中按照代码的执行顺序，最新看到的是`beforeTask`中的打印，接下来是最后边的打印，待到`setTimeout`方法执行后，完成整个任务并执行`afterTask`方法，该JavaScript代码的执行结果如下：

```HTML
hi, beforeTask in.
in the zone: false
in the zone: true
hi, afterTask in.
```

现在来概括下什么是Zone，它们基本上是获取到了一个异步操作的执行上下文，并且证明了在错误处理和分析非常有用，通常情况下，这些的异步处理，比如说是服务端异步返回所需要的数据，或者是一些异步事件更改视图模型的数据等，通过`beforeTask`和`afterTask`等勾子函数能够很好的在异步事件发生或者结束的时候，允许在这样的异步任务节点执行一些分析代码。

在一些复杂的业务逻辑场景下，上面提及的这些可能远远不够用，很多时候应用场景要比这个例子要复杂的多，`zone.js`采用猴子补丁(Monkey-patched)的方式将JavaScript中的异步任务都进行了包裹，同样的这使得这些异步任务都将运行在Zone的执行上下文中，每一个异步的任务在zone.js都是一个任务，除了提供了一些供开发者使用的勾子(hook)函数外，默认情况下zone.js重写了并提供了如下的方法:

- Zone.setInterval() / Zone.setTimeout()
- Zone.alert()
- Zone.prompt()
- Zone.requestAnimationFrame()
- Zone.addEventListener()
- Zone.removeEventListener()

综上所述，应该能理解Zone的应用场景了，即实现了异步task的跟踪分析和错误记录以便更好的进行开发debug等。

#### 深入理解Zone
通过上一小节可以看到，每一个Zone的勾子统一服务于该Zone下面的所有回调函数。在实际开发中，可能需要对回调函数分门别类，对不同类别的回调函数采用不用的处理方式。于是Zone.js引入了子Zone的概念：一个Zone可以包含多个子Zone，每个子Zone都有其独立的勾子，从而不同类别的回调函数就可以添加到不同的子Zone中去。

#### 创建子Zone
每个子Zone都是通过调用zone.fork()方法来创建，是父类Zone的一个实例，每一个Zone都有一个唯标识符，同时还可以通过parent属性来寻找上一级Zone。`zone.run()`方法接收一个方法作为参数，在该方法内，可以给异步事件添加回调函数，从而这些回调函数会被该zone所识别和统一管理，所有的业务代码都在`run`方法中执行，该`childZone`获取到了该业务代码的执行上下文并能通过勾子函数处理一些异步操作，还是用上面的例子说明如下：

```js
  // root zone
  console.log(zone.$id, zone.isRootZone());  // 打印输出为：1 true
  // 子zone
  var childZone = zone.fork({
    beforeTask: () => {
        console.log('hi, beforeTask in.');
    },
    afterTask: () => {
        console.log('hi, afterTask in.');
    }
}).run(function () {
  zone.inTheZone = true;

  setTimeout(function () {
    console.log('in the zone: ' + !!zone.inTheZone);
  }, 0);
});
  console.log(childZone.$id, childZone.isRootZone());  // 打印输出为：2 false
  // 通过parent属性来寻找上一级zone
  console.log(childZone.parent === zone);  //true
```

#### Zone的继承关系
Zone的父子关系除了通过parent属性来建立外，还遵循了JavaScript的原型继承，父Zone是子Zone的原型，每一个子Zone都可以直接访问其祖先zone的属性和方法，如下例子很好的说明了它们的继承关系。

```js
console.log(zone.isPrototypeOf(zone.fork()));  //true
```

再通过下面的例子来理解Zone的简单继承关系

```js
  zone.enqueueTask = function(){
    console.log(this === zone);  // this和zone变量均指向childZone
    console.log("enqueueTask hook of root zone");
  };
  let childZone = zone.fork();
  childZone.run(function(){
    setTimeout(() => {}, 30);
  });
```
`childZone`没有定义`enqueueTask`勾子，因此在用`setTimeout`添加回调函数的时候，会沿着原型链向上寻找，这里其实是调用跟（root）zone的勾子。值得注意的是，虽然调用的是跟zone的勾子，但是this指向的仍然是`childZone`。但是如下面的例子中在`childZone`中定义上`enqueueTask`勾子函数，那么在原型链上最先找到的就是子Zone中定义的`enqueueTask`勾子函数。

```js
  let childZone = zone.fork({
    enqueueTask: () => {
      console.log("enqueueTask hook of child zone");
    }
  });
```

除了简单的继承和覆盖，Zone.js还允许父子Zone的同名方法协同工作。Zone.js规定Zone的每一个方法都可以有四种状态，还是以`enqueueTask`为例，［enqueueTask］为标准状态，［-enqueueTask］为前置状态，［+enqueueTask］为后置状态，［$enqueueTask］为追溯状态，每一个zone的每一个方法只能定义一种状态，通过［+, -］来表示先后关系，其执行顺序为：前置`->`标准`->`后置。

下面的例子给子zone定义了一个后置钩子，因此在添加回调函数时，父zone的标准钩子先执行，然后再执行子zone的后置钩子。

```js
  zone.enqueueTask = function(){
    console.log("enqueueTask hook of root zone");
  };
  let childZone = zone.fork({
    "+enqueueTask": () => {
      console.log("enqueueTask hook of child zone");
    }
  });
  childZone.run(() => {
    setTimeout(() => {});
  });
```
代码执行结果如下：

```
enqueueTask hook of root zone
enqueueTask hook of child zone
```

通过前面的介绍可以了解到，Zone.js以同样的接口，不同的方式实现并替换了一系列与事件相关的标准方法。因此，当开发者使用标准接口的时候，实际上会先调用Zone.js的替换方法，再由这些方法调用底层的标准方法，不过这一对开发者透明的设计，使得可以在引入Zone的功能的时候，不需要对原有代码做太大改动成为可能。

#### Angular2中的ngZone
下面来介绍ngZone。实际上，ngZone是基于Zone.js来实现的，Angular2的ngZone从zone.js中fork了一份参考，它是Zone派生出来的一个子Zone，在Angular2环境内注册的异步事件都运行在这个子Zone上(因为ngZone拥有整个运行环境的执行上下文)，ngZone拓展了自己的一些API并添加了一些功能性的方法到它的执行上下文中，这些勾子方法如`onTurnStart`和`onTurnDone`事件也会在该子Zone的`run`方法中触发。另外值得提出的是，在ngZone的TypeScript定义中，并没有把这个子Zone给暴露出来，因此只能通过ngZone的提供的方法来间接地对该子Zone进行操作。

NgZone提供了一些我们能订阅的自定义事件，具体如下：

- `onTurnStart`即在Angular事件启动前通知订阅器，触发每一次是由Angular处理的浏览器任务事件。
- `onTurnDone`即在Angular zone完成当前任务时立即通知订阅者
- `onEventDone`在完成`onTurnDone()`回调之后在VM事件之前立即通知订阅者，常用来测试验证应用程序状态。

NgZone提供的这些自定义事件在跟踪定时器和其他微任务时是非常有用的，由于NgZone其实只是全局Zone的一个fork，Angular对于在Zone内需要或不需要执行变化检查，都具有完全的控制权，这为什么是有用的？因为我们并不总是希望Angular神奇地进行变化检测，具体我们会在下面的小节给您详细讲解。

综上所述，Zone几乎在任何浏览器的全局异步操作打上了猴子补丁，并且NgZone只是Zone fork出来的一份参考，当异步操作发生时就会通知框架进行变化检测，例如当类似于mousemove事件发生时，它也将引发变化检测。

在Angular2源码中，有一个`ApplicationRef`类，其作用是用来监听ngZone中的onTurnDone事件，不论何时只要触发这个事件，那么将会执行一个tick()方法用来告诉Angular去执行变化监测。Angular2变化检测的原理大致如此，具体的`ApplicationRef`类如下：

```js
  // very simplified version of actual source
  class ApplicationRef {
    changeDetectorRefs:ChangeDetectorRef[] = [];
    constructor(private zone: NgZone) {
      this.zone.onTurnDone.subscribe(() => this.zone.run(() => this.tick());
	 }
	 tick() {
	   this.changeDetectorRefs.forEach((ref) => ref.detectChanges());
	 }
  }
```

### 2.5.3 变化检测的响应处理
到目前为止，已经知道了何时会触发变化监测，但是变化检测是怎么响应处理的呢？这里需要理解的一个概念是，每个组件都会有它的变化监测器，一个Angular应用由一颗组件树组成，由此也将有一颗变化监测树，这种变化监测树是线性流向的，数据的流向是从上到下，这是因为变化检测的执行总是由根组件开始，从上到下的检测每一个组件的变化，单向的数据流相对环形数据流来说要更好预测的多，其实就更清楚视图中数据的来源，也就是说这些数据的变化是来自于哪个组件数据变化的结果。如前面所讲，当一个异步事件发生并导致数据的改变，在组件中绑定的相关处理事件将会被触发，NgZone将会去执行勾子函数并通知Angular执行一次变化检测。理论上在每一次变化检测不得不要去检测每一个组件的变化，但是执行这么一次完整的检测只需要几毫秒的时间就能完成。

#### 组件内部的变化检测的处理
Angular2在整个运行期间都会为每一个组件创建监测类，用来监测每个组件在每个运行周期是否有异步操作发生。任何的一个Angular2应用都是由大大小小的组件组成的，可以把它看成是一颗线性的组件树，重要的是，每一个组件都有自己的变化检测器，以此来组成了Angular2应用的一颗组件树，通过下面的例子来说明：

```js
@Component({
  template: '<v-card [vData]="vData"></v-card>'
})
class VCardApp {
  constructor() {
    this.vData = {
      name: 'Jason',
      email: 'Jason@gf.com.cn'
    }
  }

  changeData() {
    this.vData.name = 'Jofix';
  }
}
```
`VCardApp`把`<v-card>`作为一个子组件，其中有一个输入属性`vData`，数据通过`VCardApp`的对象`vData`传递到子组件，同样的，在组件中有一个`changeData`方法提供用来修改对象`vData`中的`name`属性值。当变化监测被执行时会发生什么呢？假象一下`changeData()`方法在一个异步的操作之后被执行，那么`vData.name`被改变，然后被传递到<v-card [vData]="vData"></v-card>的变化检测器来和之前的数据对比是否有改变，如果和参照数据对比有变动的话，Angular将更新视图。

那么在这个组件中，变化检测器是如何处理的呢？在`changeData()`被执行之后，属性值`name`被修改，然后被传递到`<v-vard>`组件中，该组件的变化检测器立刻校验`vData`对象和之前的参照对比是否有改变，如果没有改变的话，保持原有的参照不变，当其中的属性变化后，Angular将会针对这个`vData`对象执行变化检测。因为在JavaScript语言中不提供给我们对象的变化通知，所以Angular必须保守的要对每一个组件的每一次运行结果执行变化检测，但其实很多组件的输入属性是没有变化的，没必要对这样的组件来一次变化监测，如何减少不必要的监测，下文将继续探讨。

### 2.5.4 变化检测性能优化
上节中有讨论到Angular在有引起数据变化的操作发生时，将不得不在单次的运行期间对每个组件经行变化监测，当然在组件中有相关的变化的话这些检测是有意义的，但是在整个应用中，很多时候只是组件的局部有变化或者数据更改，但是Angular还是会针对每一个组件执行变化检测，这样的检测显然是有些浪费的。

事实上，在组件中数据的变化与否是有数据结构给我们提供担保的，下面将介绍`Immutables`和`Observables`，如果我们使用这些结构和类型，在Angular中做相应的标识，变化检测将会执行组件中有变化的部分，这样对变化监测性能的提升是有重大意义的。

#### 使用`immutable`机制提升检测性能
不可变对象(Immutable Objects)给我们提供的保障是对象不会改变，即当其内部的属性发生变化时，相对旧有的对象，我们将会保存另一份新的参照。它仅仅依赖输入的属性，也就是当输入属性没有变动（没有变动即没有产生一份新的参照），Angular将跳过对该组件的全部变化监测，直到有输入属性（@input）变化为止。如果需要在Angular2中使用不可变对象，我们需要做的就是设置changeDetection: ChangeDetectionStrategy.OnPush，如下的例子：

```js
@Component({
  template: `
    <h2>{{vData.name}}</h2>
    <span>{{vData.email}}</span>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
class VCardCmp {
  @Input() vData;
}
```

例子中，`VCardCmp`仅仅依赖它的输入属性，同时我们也设定了`ChangeDetectionStrategy`变化监测策略为`OnPush`来告诉Angular如果输入属性没有任何变化的话，则跳过对该子组件的变化监测。

```js
@Component({
  template: `
    <h2>{{vData.name}}</h2>
    <span>{{vData.email}}</span>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
class VCardCmp {
  @Input() vData;
}
```

现在想象一下应用中的那个巨大的组件树，当设置了`ChangeDetectionStrategy`变化监测策略为`OnPush`后，在`immutable`对象的属性不被改变的情况下，我们会跳过子组件的变化检测，只检测有改变的部分，相对于整个组件树的变化检测可想而知会有质的提升。

#### 使用`Observables`机制提升检测性能
使用`Observables`机制提升检测性能和不可变(immutable)对象类似，但它们有相关变化的时候不会提供一份新的参照，可观测对象在输入属性发生变化的时候来触发一个事件来更新组件视图，同样的，我们也是添加`OnPush`来跳过子组件树的监测器，但是它不会像之前的不可变对象那样在输入属性有变化的时候修改数据参照，那它是如何通知是否需要进行变化检测的呢？Angular针对特定的事件有一种非常智能的方式来启用组件树的路径来被检测，这种情形是非常的精确的，下面给这样的一个例子来帮你加深理解：

```js
@Component({
  template: '{{counter}}',
  changeDetection: ChangeDetectionStrategy.OnPush
})
class CartBadgeCmp {

  @Input() addItemStream:Observable<any>;
  counter = 0;

  ngOnInit() {
    this.addItemStream.subscribe(() => {
      this.counter++; // application state changed
    })
  }
}
```

该组件是模拟的当用户触发一个事件后增加counter这样一个场景，确切的讲，`CartBadgeCmp`设置了一个插值`counter`和一个输入属性`addItemStream`，该组件在其`ngOnInit`生命周期勾子中订阅了一个事件流来增加`counter`的数值，当有异步操作需要更新`counter`的时候，将会触发这个事件流。

值得一提的是，在这个例子中设置了变化检测策略为`onPush`，正是因为`addItemStream`不会再生产一份新的参考，这样的话整个运行期间，都不会对子组件执行变化检测了，那么，在输入属性有变化的时候，变化检测器怎么执行变化检测呢？否则的话达不到这个例子想要的目的了。如下图5-2所示，整个组件树灰色代表在有数据变化事件发生后，没有任何的变化检测。
![](https://github.com/gf-rd/gf-angular2-book/blob/master/_images/chapters2-2/change-detect-1.png?raw=true)

图 5-1 

正如前面了解到的那样，变化检测总是由根组件到具体的子组件这样一个从上到下的顺序执行的，这里所说的变化检测优化其实是要准确的知道当前变化的子组件到根组件的具体路径，变化检测仅仅就只按照这个路径检测，而不是整个组件树全部检测一遍。Angular是不知道那一条路径有改变的，但是我们知道，我们可以通过依赖注入给组件来引入一个`ChangeDetectorRef`，其中包含该一个`markForCheck`的标记方法，这个方法正是我们所需要的，它能标记有数据变化的子组件到跟组件的具体路径，代码示例如下：

```js
class CartBadgeCmp {
    constructor(private cd: ChangeDetectorRef) {}

    @Input() addItemStream:Observable<any>;
    counter = 0;

    ngOnInit() {
        this.addItemStream.subscribe(() => {
            this.counter++; // application state changed
            this.cd.markForCheck(); // marks path
        })
    }
}
```
当这个可监测的`addItemStream`触发一个事件，该事件处理句柄将会从根路径到这个已经改变的`addItemStream`组件来处理监测，一旦变化监测跑遍整个监测路径，它将会存储OnPush状态到整个组件树。这样做的好处是，变化监测系统将会走遍整棵树，你可以利用他们来监测树在局部是否有真正的改变，以此来做出相应的改变。变化检测到的路径是如下图5-2所标记的那样。
![](https://github.com/gf-rd/gf-angular2-book/blob/master/_images/chapters2-2/change-detect-3.png?raw=true)

图 5-2

#### 变化检测总结
- Angular2应用是一个是相应系统
- 变化检测系统是从根到叶的传播绑定
- 不像Angular1.x，变化监测图是一颗有向树，该系统使得性能表现更好和更可预测的
- 默认情况下，变化监测系统将会走遍整棵树，但是如果你使用不可变属性或者可观测对象，你可以利用他们来监测树在局部是否有真正的改变
- 这些优化组合不会扰乱提供的变化监测保障






