# 2 组件

&emsp;&emsp;组件（Component）是构成 Angular 应用的基础和核心，了解它是如何工作是非常重要的，通俗地说，一个组件包装了一个特定的功能，并且组件之间协同工作以组装成一个完整的应用程序。

&emsp;&emsp;举个现实中的例子，一辆汽车中包含各种各样的部件、零件，比如发动机、变速箱、轮胎等等，那么这些便可以理解为组成汽车的`组件`，当然这还不是最小粒度的组件，例如发动机本身也会由众多小零件组合而成。

&emsp;&emsp;通过本章节的内容，读者可以了解到组件化的发展和 WebComponent 标准是如何形成的，以及 Angular 是如何向 WebComponent 靠近的；接着是从如何创建组件开始学习，到组件的构成，从基础到深入学习组件的元数据、生命周期、组件交互以及变化监测机制等内容。

## 2.1 组件化以及 Angular 的组件

&emsp;&emsp;前面的内容已经对组件有了初步的了解，下面来了解组件的概念是如何产生的，组件化又是如何发展的。

### 2.1.1 模块化
&emsp;&emsp;谈到组件化，先要了解**模块化**。在 node.js 中，模块就是一个文件，引入一个文件就是简单地`require('xxx')`，其中 xxx 是文件名称或路径。在前端的领域，也衍生出不少模块化的规范，比如 CommonJS、AMD，不过前端领域发展得很快，因为还未形成一种统一的规范，目前（本书写作的时候）无论是 CommonJS 还是 AMD 都已经不那么流行了。ES6、TypeScript 这些“后起之秀”均采用了类似 node 的 import module 的方式，配合 browserify、webpack 等构建工具将所有模块转换、打包成一个可用于浏览器运行的 js 文件。

> node.js 采用的是 CommonJS 规范。AMD 全称是 Asynchromous Module Definition，著名的 RequireJS、SeaJS 分别是 AMD、CommonJS 规范的实现之一。

&emsp;&emsp;在早期的模块化中，只是针对 js 部分做了处理，比如 RequireJS、SeaJS 也只是管理 js 模块，缺少对 css、html 文件进行管理。后来逐渐形成按模块划分的概念，对比传统的按资源目录划分，从逻辑的意义上来说似乎更加合理，但是由于早期不能做到把三者（js、css、html）统一模块化，按模块划分的维护成本比较高。

&emsp;&emsp;按资源划分：

```
├── project
│   ├── css
│   ├── js
│   ├── img
│   ├── template
│   ├── index.html
```

&emsp;&emsp;按模块划分：

```
├── project
│   ├── shop
│   │   ├── shop.component.js
│   │   ├── shop.html
│   │   ├── shop.css        
│   ├── user
│   │   ├── user.component.js
│   │   ├── user.html
│   │   ├── user.css
│   ├── index.html
```

&emsp;&emsp;通过将 js、css、html 按逻辑模块划分后，使得逻辑结构更清晰了，这样逐步便形成了**组件**的概念。读者可以非常粗暴地理解，前端中的**组件**就是一堆为了实现同一业务逻辑的代码文件的组合。比如说上面按模块划分的结构中，user 便是一个实现用户相关逻辑的一个组件：

```
│   ├── user
│   │   ├── user.component.js
│   │   ├── user.html
│   │   ├── user.css
```

&emsp;&emsp;前端发展得很快，各种库、框架层出不穷，例如Angular1、Backbone、Ember、React、Vue（排序按首字母）；工程化的工具也越来越多，例如Bower、Browserify、Grunt、Gulp、Webpack（排序按首字母）。近几年在技术领域中出现这么混杂又充满创新的景象，恐怕也只有在前端领域了。这一方面说明前端领域的创造力很强，另一方面也正说明了缺少标准，每个框架/库都有一套自己的组件化方式，包括本书讲解的 Angular 也有自己的组件化方式。

&emsp;&emsp;业界为了统一组件化的标准方式，WebComponent 应运而生。

### 2.1.2 组件化的标准
&emsp;&emsp;W3C 对 Web 组件提出了 WebComponent 的标准，通过标准化的非侵入方式封装组件，每个组件包含自己的 html、css、js 代码，并且不会对页面上其他代码产生影响。它包含以下几种重要的概念：

#### HTML导入
&emsp;&emsp;HTML 导入，是在一种在 HTML 文档中引入其他 HTML 文档的方法。在这个“其他” HTML 文档中，还能够和平常一样引入 CSS，JavaScript 等这些能在 .html 文件中能包含的任何内容。举个例子，有一个 bootstrap.html 包含了 Bootstrap 所需的各种文件：

```html
<link rel="stylesheet" href="bootstrap.css">
<script src="jquery.js"></script>
<script src="bootstrap.js"></script>
...

<!-- 还能定义一些模板 -->
<template>
  ...
</template>
```

&emsp;&emsp;然后在应用的 index.html 引入：

```html
<head>
  <link rel="import" href="bootstrap.html">
</head>
```

&emsp;&emsp;HTML 导入的功能使得开发者能够将开发好的一个模块写到一个 .html 文件去给他人使用，换句话说，仅用一个 URL，就可以将多个文件封装成一个文件提供给他人使用。还有关键的一点是，通过 HTML 导入的特性，使得异步加载模块、执行模块变得更加容易。

#### 模板
&emsp;&emsp;模板允许开发者预先写好一些 html 标记，用于后续使用或复用。如果你使用过 Angular1.x 或者 Handlebars 之类的东西，你应该熟悉模板是什么。例如：

```html
<template>
  <h1>Hello!</h1>
  <p>You can't see this script in the page.</p>
  <img src="http://example.com/image.png" />
</template>
```

&emsp;&emsp;所有在`<template>`中的内容都被浏览器看作“静态”的东西，换句话说所有写在`<template>`里面的像`<img>`、`<video>`这些标签引用的资源都不会被加载，`<script>`标签也不会被执行，也不会被渲染到页面中，直到使用 Javascript 去控制它。

#### Shadow DOM
&emsp;&emsp;通过 Shadow DOM 可以在文档流中创建一些完全独立于其他元素的 DOM 子树，这个特性可以可以让开发者开发一个独立的组件，并且不会干扰到其它 DOM 元素（非侵入的方式）。Shadow DOM 和标准的 DOM 行为一样，可以通过 html、css、js 去定义。居于这个特性，使得组件的复用变得简单。

#### 自定义元素
&emsp;&emsp;WebComponent 规范允许开发者声明一个语义化的自定义元素来引用组件：

```html
<template id="hello-template">
  <h1>Hello!</h1>
</template>

<script>
  // 获得上面的模板
  var tmpl = document.querySelector('#hello-template');

  // 创建一个新元素的原型，继承自 HTMLElement
  var HelloProto = Object.create(HTMLElement.prototype);

  // 设置 Shadow DOM 并将模板的内容 clone 进去
  HelloProto.createdCallback = function() {
    var root = this.createShadowRoot();
    root.appendChild(document.importNode(tmpl.content, true));
  };

  // 注册新元素
  var Hello = document.registerElement('hello', {
    prototype: HelloProto
  });
  
  // 渲染新元素
  document.body.appendChild(new Hello());
</script>
```

&emsp;&emsp;目前（本书写作的时候）的浏览器只有 Chrome 和 Opera 对 WebComponent 的支持度比较高，其他浏览器不能运行使用 WebComponent 标准写的哪怕是很简单的 hello-world 代码。Google 官方出品的 Polymer 框架则比较接近 WebComponent 的写法，它是面向未来的框架。同样也是出自 Google 的 Angular 与 WebComponent 也有几分相似，虽然 Angular1.x 的版本也支持模板和自定义标签，但 Angular 的组件化比 Angular1.x 更加彻底，而且与 WebComponent 标准更接近。

### 2.1.3 Angular 的组件
&emsp;&emsp;本章的开头介绍了组件及组件化的概念，以及 WebComponent 的标准。相对于 Angular1.x 版本，Angular 更面向未来，它对 WebComponent 更友好。

&emsp;&emsp;Angular 设计之初就打算跟未来的 WebComponent 标准协作，Angular 引入了视图包装（ViewEncapsulation）的概念，允许通过设置`ViewEncapsulation.Native`选项来使用原生的 Shadow Dom。该内容会在本章后续讲述。

&emsp;&emsp;除此之外，Angular 支持**模板、自定义标签、异步加载组件**，相比 Angular1.x 的版本，Angular 的组件是**自描述**的——组件可以和宿主元素交互，组件知道如何及何时渲染自己，组件可配置注入服务，组件有明确的 Input&Output 定义（注入与服务是后续章节的内容，宿主元素、Input和Output在本章有讲述）。这使得所有 Angular 的组件都可以独立存在，这意味着任何 Angular 组件都可以通过 bootstrap 来启动，也可以被路由加载，或者在其他组件中使用，这极大地提高了组件的复用性。

&emsp;&emsp;在上一章，读者已经接触了 Angular 组件的一些概念，知道了 Angular 应用由一系列大大小小的松耦合的组件构成了一棵完整的应用组件树，以及了解了组件间的数据流动、变化监测等概念。在本章接下来的内容会结合代码及 Demo 对上述概念进行详细讲解。

## 2.2 组件基础

### 2.2.1 如何创建组件
&emsp;&emsp;一般学习一门程序语言，都会从 Hello World 开始，现在我们也创建一个显示 Hello World 的例子，学习如何去创建组件：

- 从 @angular/core 中引入 Component
- 建立一个普通的类，并用 @Component 修饰它
- 在 @Component 中，设置 selector **自定义标签**，以及 template **模板**

```typescript
import {Component} from '@angular/core';

@Component({
  selector: 'hello-world',
  template: '<div>Hello World!</div>'
})
export class HelloWorldComponent {}
```

&emsp;&emsp;以上便创建了一个最简单的 Angular 组件，要使用这个组件的话，则需要在 HTML 中添加 hello-world 这个自定义标签，然后 Angular 便会在此标签中插入一个 HelloWorldComponent 的实例对应的模板。

```typescript
<body>
  <hello-world></hello-world>
</body>
```

&emsp;&emsp;会被渲染成

```typescript
<body>
  <hello-world>
    <div>Hello World!</div>
  </hello-world>
</body>
```

### 2.2.2 组件基础构成
&emsp;&emsp;刚才学习了最简单的组件创建，实际上构成组件的东西有很多，本节及后续内容将通过 Demo 深入来分析。

&emsp;&emsp;读者通过`npm start`运行 Demo，在浏览器打开后可以看到首页——首页展现的是`ContactList`这个组件（contact-list.ts）。在这个大组件中，展示的每个单一的联系人，是`ListChildrenComponent`组件（list-li.ts）。

![Contact Demo](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapters2-2/ng2-contact-demo.png)

图2-1 通讯录 Demo

&emsp;&emsp;先看 list-li.ts 以及 list-li.html 的代码：

![Core Concept of Component](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapters2-2/component-core-concept.png)

图2-2 ListChildrenComponent 相关代码

&emsp;&emsp;从上述代码中，看到一些重要的概念，这些是构成组件的基础：

- 组件修饰器（Component Decorator）：每个组件类必须用 @Component 修饰才能成为 Angular 组件
- 组件元数据（Component Metadata）：selector、templateUrl、styleUrls等
- 宿主元素：每个组件都会关联一个模板，这个模板最终会渲染到页面上，页面的这个 DOM 元素就是此组件实例的宿主元素
- 组件生命周期及勾子（Component Lifecycle、Hook）：OnInit 和 ngOnInit 等
- Inputs & Outputs：组件的数据输入与输出

&emsp;&emsp;其中组件的元数据并不只上面列出的四个，完整的元数据在本章节中也会分别讲解。另外组件的生命周期是进阶知识，会在本章节后续讲解。

#### @Component

&emsp;&emsp;从刚才的代码，以及上一节的 Hello World 组件中，都能看 @Component 这样的代码，它是一个修饰器，任何一个 Angular 的组件类都会用这个修饰器修饰，如果移除了这个修饰器这个组件就没有任何意义了，它将不再是 Angular 的组件。那么这个修饰器是什么？有什么作用？浏览器如何解释它？

&emsp;&emsp;Component 在 Angular 源码中的定义：

```typescript
export declare var Component: ComponentMetadataFactory;
```

```typescript
export interface ComponentMetadataFactory {
  (obj: {
    ...
  }): ComponentDecorator;
  new (obj: {
    ...
  }): ComponentMetadata;
}
```

> interface 是 TypeScript 里定义的内容，在本书第一部分有简单的讲解，详细可以参考 TypeScript 官网的教程。在这里读者只需要知道，**`Component`是具有这个接口定义的所有属性和方法的一个类**即可。

&emsp;&emsp;由于目前的浏览器还不能直接解释 TypeScript 代码，最终组件的代码会通过 TypeScript 解析器转换成 JavaScript 代码，上述组件转换后的代码如下（示意）：

```javascript
var ListChildrenComponent = (function () {
  function ListChildrenComponent() {}
  ListChildrenComponent = __decorate([
    core_1.Component({
      selector: 'list-li',
      templateUrl: 'app/components/contact-list/list-li.html'
    })
    __metadata('design:paramtypes', [])
  ], ListChildrenComponent);
  return ListChildrenComponent;
}());
```

&emsp;&emsp;可以看到，Angular 通过`@Component`将`ListChildrenComponent`这个类“修饰”起来，使`ListChildrenComponent`具有 Angular 组件定义的一切属性。Angular 提供的`@`操作符来实现修饰组件，并没有什么特别之处，可以理解为对组件封装的语法糖，方便开发者编写 Angular 的组件。

#### 基础的元数据
&emsp;&emsp;在`list-li.ts` 这个文件中的 @Component 修饰器部分，使用到了大部分组件需要的元数据——用于定位元素的`selector`、用于定义组件宿主元素模板的`templateUrl/template`、用于指定组件渲染的样式`styleUrls/styles`。

```typescript
...
@Component({
  selector: 'list-li',
  templateUrl: 'app/components/contact-list/list-li.html',
  styleUrls: ['app/components/contact-list/list-li.css']
})
...
```

*此处的 ListChildrenComponent 以及 list 可能要规范一下*

##### selector
&emsp;&emsp;用于定义组件在 HTML 代码中匹配的标签。selector 参数是必须设置的，它将成为新组件的命名标记，它的工作原理很像 querySelector，会返回文档中选择器匹配到的第一个元素。

&emsp;&emsp;事实上 selector 也可以忽略不指定，此时默认会变成 div，但绝对不要这样做，因为这样组件会无法准确定位 DOM 中的元素。

&emsp;&emsp;selector 的命名方式建议使用“烤肉串式”命名，即名称全小写，并以`-`分隔。例如`contact-app`、`hello-world`。

&emsp;&emsp;在 Demo 中，`ListChildrenComponent`是展示在首页联系人列表中的单个联系人项目，它的`selector`设置为`list-li`，那么 Angular 便会通过查找 DOM 上的一个 list-li 元素，从而将**组件的内容**显示在页面上。那么**组件的内容**又是怎么指定的？这就要用到 template/templateUrl 。

##### template
&emsp;&emsp;为组件指定一个内联模版。

> 关于模板的更多内容，请参见**模板**章节。
> 
> 如果要写内联模板，建议使用ES6的``语法，能够轻松创建多行模版。
> 
> ```typescript
>   template: `
>     <div>
>       <div>Inner Div</div>
>     </div>
>   `
> ```

##### templateUrl
&emsp;&emsp;为组件指定一个外部模版的 URL 地址

```typescript
  templateUrl: 'app/components/contact-list/list-li.html',
```
> 每个组件只能指定一个模版，templateUrl 或 template。
>
> 总的来说，本书更推荐使用 templateUrl ，因为无论如何，组件的内容都会由不少 DOM 元素组成，在 .ts 文件里写一长串 html 代码不是一个好主意。除非你确定你的组件就是一两行极简的代码，并且不会发生什么变化，此时可以使用 template。

&emsp;&emsp;在本`list-li.ts`中，使用了 templateUrl，为`ListChildrenComponent`指定了一个`list-li.html`模板，它的内容如下：

```typescript
<a (click)="goDetail(contact.id)">
  <img class="icon-head" src="./images/Iverson.jpg">
  <div class="contact-info">
    <label class="contact-name">{{ contact.name }}</label>
    <span class="contact-tel">{{ contact.telNum }}</span>
    <i class="contact-to-detail"></i>
  </div>
</a>
```

&emsp;&emsp;于是，Angular 便在 DOM 上搜索`<list-li></list-li>`这个位置，将`list-li.html`的内容都渲染到 DOM 上。这就是 selector 以及 template/templateUrl 的作用。

##### styles
&emsp;&emsp;为组件指定内联样式。

```typescript
  styles: [
    `
    li:last-child{
      border-bottom: none;
    }
    `
  ]
```

##### styleUrls
&emsp;&emsp;为组件指定一系列用于该组件的样式表文件。

```typescript
  styleUrls: ['app/components/contact-list/list-li.css'],
```

> styles 和 styleUrls 允许同时指定。如果同时指定，styles 中的样式会先被解析，然后才会解析 styleUrls 中的样式。换句话说，styles 的样式会被 styleUrls 的样式覆盖。
> 
> 强烈建议，styles 或 styleUrls 只使用其中一个设置。另外，像 templateUrl 那样，本书也建议使用 styleUrls 将样式表文件分开，这样代码结构更清晰，更易于管理。

&emsp;&emsp;细心一点可以注意到，styles/styleUrls 是复数，所以要使用数组来承载样式表字符串或样式表文件路径字符串，Angular 允许使用多个样式表文件，来同时渲染一个组件。

&emsp;&emsp;开发者也可以使用一些 css 预处理器比如 sass 来更好地编写样式代码。在本 Demo 中，使用了 webpack 作为工程化的工具，可以很方便地集成。在 webpack.config.js 中的 loaders 设置项下，加上以下代码

```javascript
{test: /\.scss$/, loader: 'raw-loader!sass-loader', exclude: /node_modules/},
```

&emsp;&emsp;并通过`npm install sass-loader`，便可以在代码中使用了，例如`ListChildrenComponent`引用的样式可以改成：

```typescript
  styleUrls: [require('app/components/contact-list/list-li.sass')],
```

#### 宿主元素
&emsp;&emsp;要将 Angular 的组件渲染到 DOM 上，就需要将组件与 DOM 元素关联起来，这个 DOM 元素就叫做**宿主元素**。上文也提到组件是自描述的，其中一点便是组件可以与宿主元素交互：

- 与宿主元素同步数据
- 监听宿主元素的事件
- 宿主元素可以调用组件的方法

##### 显示数据
&emsp;&emsp;在模板中，可以使用`{{}}`语法来显示组件的数据，这和 Angular1.x 的版本是一致的。比方说在 Hello World 组件中，有一个成员变量`name`，就可以通过`{{name}}`来将名称输出到页面上。

```typescript
@Component({
  selector: 'hello-world',
  template: '<div>Hello World, {{name}}!</div>'
})
export class HelloWorldComponent {
  name: string = 'Super Man';
}
```

&emsp;&emsp;组件会被渲染成

```html
  <hello-world>
    <div>Hello World, Super Man!</div>
  </hello-world>
```

&emsp;&emsp;这种语法`{{}}`在 Angular 中称为**插值**，插值的更多内容，请参阅**模板**章节。

##### 双向数据绑定
&emsp;&emsp;Angular 也提供了双向数据的绑定，这在控制用户的输入文本时很有用处，双向绑定使用的是`[(ngModel)]="property"`这样的语法。

```typescript
@Component({
  selector: 'hello-world',
  template: `<div>Hello World!<input type="text" value="{{name}}" [(ngModel)]="contact.name"/></div>`
})
export class HelloWorldComponent {
  name: string = 'Super Man';
}
```

&emsp;&emsp;关于双向数据绑定的语法更多细节，请参阅**模板**章节。

##### 监听宿主元素事件
&emsp;&emsp;Angular 提供了非常方便的事件绑定的方式，读者在`contact-list.html`中也能看到`(click)`这样的用法，`()`是 Angular 提供的事件绑定语法糖，通过`(eventName)`的方式可以轻易地响应UI事件。

&emsp;&emsp;list-li.html 中事件绑定的代码：

```html
<h3>所有联系人<i (click)="addContact()"></i></h3>
```

&emsp;&emsp;关于双向数据绑定的语法更多细节，请参阅**模板**章节。

##### 调用组件方法
&emsp;&emsp;调用组件方法一般是和监听事件一起使用的，像上面提到的，`(click)="addContact()"`就是在用户点击了该元素时，调用组件的 addContact 方法。

#### @Input、@Output
&emsp;&emsp;一个组件可以指定输入或输出的属性，这是构成上文提到的**组件自描述**的因素之一。输入输出的属性可以使用属性修饰器（Property Decorator）@Input 和 @Output 来修饰。然后通过`()`和`[]`的语法来调用。

&emsp;&emsp;回想一下在`list-li.ts`以及`contact-list.html`中的代码：

```typescript
export class ListChildrenComponent implements OnInit {
  @Input() contact:any = {};
  @Output() routerNavigate = new EventEmitter<number>();
  ...
}
```

```html
  <li *ngFor="let contact of contacts">
    <list-li [contact]="contact" (routerNavigate)="routerNavigate($event)"></list-li>
  </li>
```

&emsp;&emsp;`ListChildrenComponent`的作用是显示单个联系人的 Item，由于联系列表数据是在`ContactList`组件维护的，在显示单个联系人的时候，需要传入一个联系人数据；另外在点击单个联系人的时候，需要跳转到此联系人的明细信息，因此此处分别自定义了`[contact]`和`(routerNavigate)`的输入输出变量，用于满足上述功能。

&emsp;&emsp;顾名思义，Input 和 Output 分别指输入输出，读者可以理解为，被`@Input`修饰的`contact`变量属于输入属性，而被`@Output`修饰的`routerNavigate`则是输出事件，这里的“输入输出”是以当前组件角度去说的，换句话说，`contact`和`routerNavigate`分别是`ListChildrenComponent`组件的输入和输出。输出一般是以事件的形式，将数据通过 EventEmitter 抛出去，这部分属于组件交互的内容，读者可以阅读本章的**组件交互**小节了解更多。

##### inputs & outputs
&emsp;&emsp;除了使用`@Input`和`@Output`修饰外，还可以在组件的元数据中使用 **inputs、outputs** 设置，设置的值必须为字符串数组，元素的名称需要和成员变量相对应。上述代码和以下代码是等价的：

```typescript
// 部分代码
@Component({
  ...
  inputs: ['contact'], // 'contact'匹配成员变量 contact
  outputs: ['routerNavigate'] // 'routerNavigate'匹配成员变量 routerNavigate
})

export class ListChildrenComponent implements OnInit {
  contact:any = {};
  routerNavigate = new EventEmitter<number>();
  ...
}
```

### 2.2.3 注入依赖
&emsp;&emsp;通常一个组件不会独立存在，而是通过与其他组件协作，形成一个完整的功能模块或者应用，这个时候就需要通过注入依赖的方式，引用其他组件、指令、服务或者管道，这使得开发复杂的组件变得更容易。上文提到组件是自描述的，其中组件可以配置注入的依赖也是构成自描述的因素之一。

> **依赖注入、指令、服务、管道**均属于后续章节的内容

##### directives
&emsp;&emsp;在`contact-list.ts`文件中，可以看到`ContactList`是如何引入依赖的其他组件的：
```typescript
@Component({
  ...
  directives: [ // 指定该组件依赖的其他组件或指令
    ROUTER_DIRECTIVES,
    Footer,
    ListChildrenComponent
  ]
})
```

&emsp;&emsp;这里使用了 **directives** 这个元数据——指定可以在模版中使用的指令/组件列表。由于组件继承自指令，所以并没有 components 这样的元数据来注入组件依赖。除了 Angular 默认提供的指令，即 ng 开头的如 ngFor 等不需要显式指定外，自定义的指令或组件必须明确指定，否则在组件中无法正确使用它们。

&emsp;&emsp;例如在 contact-list.ts 的代码中，需要指定了`Footer`和`ListChildrenComponent`这两个组件，然后才能在模板 contact-list.html 中使用它们：

&emsp;&emsp;contact-list.html：

```html
<h3>所有联系人<i (click)="addContact()"></i></h3>
<ul class="list">
  <li *ngFor="let contact of contacts">
    <!-- 组件中指定了 ListChildrenComponent，才能使用 list-li 标签 -->
    <list-li [contact]="contact" (routerNavigate)="routerNavigate($event)"></list-li>
  </li>
</ul>
<!-- 组件中指定了 Footer，才能使用 my-footer 标签 -->
<my-footer [path]="path" (writeTitle)="writeTitle($event)"></my-footer>
```

##### pipes
&emsp;&emsp;组件中另一个常用的功能是管道（pipes），通过在组件的元数据中指定 pipes，便可以在模板中使用它，管道的主要作用是用来格式化数据，通常这对于国际化很有用处。在本书 Demo 的`ContactDetail`中，可以看到 pipes 的用法。关于管道的更多知识，请参阅**模板**章节的相关部分。

```typescript
@Component({
  ...
  pipes: [DateReform] // 引入自定义的管道，用于格式化日期
})
```

##### providers & viewProviders
&emsp;&emsp;还有两个很重要的是 providers 和 viewProviders，可以为组件注入指定的服务。

&emsp;&emsp;在联系人 Demo 的入口组件 `ContactApp` 中，有着这么一段代码：通过 viewProviders 元数据注入了 HTTP_PROVIDERS 和自定义的 `ContactService` 服务。

> `ContactService` 是维护联系人数据的主服务，提供了联系人的相关操作。关于服务的更多内容请参考**服务**章节。

```typescript
...
import {HTTP_PROVIDERS} from "@angular/http";
import {ContactService} from "../services/contact-service";

@Component({
  ...
  viewProviders: [HTTP_PROVIDERS, ContactService],
  ...
})

...
```

&emsp;&emsp;这里使用了 viewProviders 来注入服务，在此处使用 providers 和 viewProviders 的作用是一样的，它们之间的区别是 providers 可以在所有子组件，包括使用了自定义内容（ng-content）的子组件都可以使用，而 viewProviders 则会限制在仅能在子组件中使用，不能在自定义内容的组件中使用。这个特性在开发一个库时特别有用。

&emsp;&emsp;自定义内容属于组件的进阶知识，viewProviders 的作用会在后续一并解析。

## 2.3 组件进阶

### 2.3.1 自定义内容
&emsp;&emsp;自定义内容有时被认为是一个高级的功能，使用自定义内容能很好地扩充组件的功能，特别是在需要创建团队、项目之间共享的通用的 HTML 代码片段的时候。

> 接触过 Angular1.x 的读者，相信对这个自定义内容的知识不会陌生，它和 Angular1.x 中指令的 `transclude`属性非常类似。

&emsp;&emsp;自定义内容通常用来创建可复用的组件，典型的例子是模态对话框或导航栏。想像一下，在开发 Web 应用的时候，模态对话框和导航栏是使用得非常频繁的功能，自定义内容的特性正是提供了一种复用的方式，使得复用的组件具有样式完全一致的，但内容可自定义的组件。

&emsp;&emsp;例如在通讯录的 Demo 中，可以看到无论去到哪一页，header 都是一样的样式：

![Demo Headers](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapters2-2/contact-demo-header.png)
图2-3 联系人 Demo 的头部

&emsp;&emsp;在这种情况下，就可以考虑把它改造成自定义内容的复用组件。这里以一个简化的例子，来说明这种场景。定义一个 `ExampleComponent`，然后把这个组件的外观统一成绿色的背景，无论里面的内容怎么变化：

![ng-content header](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapters2-2/example-ng-content-header.png)
图2-4 自定义 Header 内容例子

&emsp;&emsp;它的代码大概是这样子：

```typescript
@Component({
  selector: 'example-content',
  template: `
    <div>
	    <h4>Example component with ng-content.</h4>
	    <div style="background-color: green; padding: 5px; margin: 2px">
	      <ng-content select="header"></ng-content>
	    </div>
    </div>
  `
})
class ExampleContent {}
```

&emsp;&emsp;然后，定义一个很简单的根组件并这样去使用它：

```typescript
@Component({
  selector: 'app',
  template: `
	 <example-content>
	   <header>Header content</header> <!-- 此处将自定义的内容放到 example-content 标签之间 -->
	 </example-content>
  `,
  directives: [ExampleContent]
})
export class App {}
```

&emsp;&emsp;最后会被渲染成：

```html
<app>
  <example-content>
    <div>
      <h4>Example component with ng-content.</h4>
      <div style="background-color: green; padding: 5px; margin: 2px">
        <header>Header content</header>
      </div>
    </div>
  </example-content>
</app>
```

&emsp;&emsp;注意到在 example-content 标签之间的内容，被填充到了 ng-content 中去了，而 `ExampleContent` 模板中的其他元素没有受到影响。那么自定义的内容是如何匹配显示的呢？是否可以有多个自定义内容？答案是可以的，留意一下 `ExampleContent` 模板中紧跟着 ng-content 有个 select 属性，其值为 header，这与 css 的选择器是一致的，它表示匹配 example-content 标签之间的第一个 header 标签，并将其填充 到相应的 ng-content 中：

```html
    <ng-content select="header"></ng-content>
```

&emsp;&emsp;那么就可以通过选择器来指定多个 ng-content 了，修改 `ExampleContent` 的模板如下：

```html
    <div>
	    <h4>Example component with ng-content.</h4>
	    <div style="background-color: green; padding: 5px; margin: 2px">
	      <ng-content select="header"></ng-content>
	    </div>
	    <div style="background-color: gray; padding: 5px; margin: 2px">
	      <ng-content select=".class-select"></ng-content>
	    </div>
	    <div style="background-color: blue; padding: 5px; margin: 2px">
	      <ng-content select="footer"></ng-content>
	    </div>
    </div>
```

&emsp;&emsp;然后在 App 组件中这样去使用：

```html
    <example-content>
      <header>Header content</header>
      <div class="class-select">
        div with .class-select
      </div>
      <footer>Footer content</footer>
    </example-content>
```

&emsp;&emsp;最终的效果：

![multiple ng-content](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapters2-2/example-multiple-ng-content.png)
图2-5 多个自定义内容

### 2.3.2 视图包装

&emsp;&emsp;在本章的开头部分，提到了**视图包装**这个特性，它的主要目的是让组件的样式之间更加“独立”而互不影响，使得组件间的复用变得更简单。

&emsp;&emsp;读者可能在多人开发的项目中也遇到过样式冲突的情况，比如有个父 div 有一个 .background-style 的样式将整个背景设置为灰色，然后另外一个开发者，在这个 div 下添加了其他元素，也有一个 .background-style 的样式将背景设置为红色，此时背景色就变成“灰+红”了。当然一般会以不同的名称来命名样式，但是这毕竟是人工操作，在项目开发中难免会遇到一些重名样式冲突的情况。Angular 的视图包装正是解决了此问题。下面以一个简化的例子，来说明视图包装是如何做到自动隔离组件间的样式的。

&emsp;&emsp;视图包装的设置可通过 **encapsulation** 这个元数据来设置，允许设置的有三个可选的值：

- ViewEncapsulation.None - 无 Shadow DOM，并且也无样式包装。
- ViewEncapsulation.Emulated - 无 Shadow DOM，但是通过 Angular 提供的样式包装机制来模拟组件的独立性，使得组件的样式不受外部影响。这是 Angular 的默认设置。
- ViewEncapsulation.Native - 使用原生的 Shadow DOM 特性。

#### ViewEncapsulation.None
&emsp;&emsp;Angular 不使用 Shadow DOM。应用在组件的样式会被写到 Document 头部。

&emsp;&emsp;假设有一个 Hello 的组件和模板如下：

```typescript
import {ViewEncapsulation} from '@angular/core';

@Component({
  selector: 'hello',
  templateUrl: 'hello.html',
  styles: [`
    .hello {
      background: green;
    }
  `],
  encapsulation: ViewEncapsulation.None
})
class Hello {
}
```

```html
<div class="hello">
  <h1>Hello World</h1>
</div>
```

&emsp;&emsp;Angular 会将其渲染成：

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      .hello { 
        background: green;
      }
    </style>
  </head>
  <body>
    <hello>
      <div class="hello">
        <h1>Hello World</h1>
      </div>
    </hello>
  </body>
</html>
```

&emsp;&emsp;ViewEncapsulation.None 设置的结果是没有 Shadow DOM，并且所有的样式都是应用到整个 document，换句话说，组件的样式可以被覆盖。

#### ViewEncapsulation.Emulated
&emsp;&emsp;无 Shadow DOM，但是通过 Angular 提供的样式包装机制来模拟组件的独立性，使得组件的样式不受外部影响。这是 Angular 的默认选项。

&emsp;&emsp;这是个强大的功能，组件间的样式是相互独立不影响的，这样怎么做到的呢？还是刚才的例子，使用了这个设置后，Angular 会将它渲染为：

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      .hello[_ngcontent-1] { 
        background: green;
      }
    </style>
  </head>
  <body>
    <hello _ngcontent-0 _nghost-1>
      <div class="hello" _ngcontent-1>
        <h1>Hello World</h1>
      </div>
    </hello>
  </body>
</html>
```

&emsp;&emsp;虽然样式仍然是应用到整个 document，但是 Angular 为`.hello`创建了一个`[_ngcontent-1]`选择器。没错，组件的样式选择被 Angular 修改了，并且在组件的属性里也添加上了这个选择器。那`_ngcontent-0`和`_nghost-1`又是干什么用的呢？为了实现局部的样式，Angular 需要保证某个组件的样式只会匹配到该组件，所以给组件添加了`_ngcontent-0`和`_nghost-1`属性。

#### ViewEncapsulation.Native
&emsp;&emsp;使用原生的 Shadow DOM 特性。理解这个就非常简单了，Angular 会把组件以浏览器支持的 Shadow DOM 形式渲染，像刚才的例子在浏览器中能看到这样的结构：

```html
<!DOCTYPE html>
<html>
  <head>
    <style>
      .hello[_ngcontent-1] { 
        background: green;
      }
    </style>
  </head>
  <body>
    <hello>
      #shadow-root
      | <style>
      |   .hello {
      |     background: green;
      |   }
      | </style>
      | <div class="hello">
      |  <h1>Hello World</h1>
      | </div>
    </hello>
  </body>
</html>
```

### 2.3.3 组件的生命周期

> 关于组件的生命周期，可继续阅读“指令”的生命周期章节。
> 组件继承自指令，因此它们具有相同的生命周期实现。

&emsp;&emsp;使用过 Angular1.x 的读者应该知道，Angualr1.x 中有构造函数，$watch 方法和 $destroy 事件可以尝试挂接控制器中生命周期的各个时间点。在 Angular 中，生命周期的含义被定义得更加明确，包括但不限于 ngOninit、ngOnDestroy、ngOnchanges。当组件实现一些生命周期钩子的回调，那么在变化检测的时候就会在特定的时间点被触发。

&emsp;&emsp;当组件被创建的时候构造函数被调用，获取到组件的初始状态，如果组件依赖子组件中的属性或数据，我们需要等它初始化完毕。要做到这一点，我们可以处理 ngOnInit 生命周期事件，或者可以在构造函数里调用 setTimeout 能达到同样效果。就像 ngOnInit，我们可以追踪一个组件生命周期中很多事件的足迹。

#### 生命周期勾子
&emsp;&emsp;指令或组件实例都有一套生命周期，表现在 Angular 对它们的创建、更新和销毁。

&emsp;&emsp;开发者可以实现一个或者多个 “生命周期钩子（接口）” ，从而在生命周期的各阶段作出适当的处理。这些钩子接口包含在 Angular/core 中。

&emsp;&emsp;以下是所有的生命周期钩子接口，Angular 会依序调用下列钩子方法：

- ngOnChanges
- ngOnInit
- ngDoCheck
- ngAfterContentInit
- ngAfterContentChecked
- ngAfterViewInit
- ngAfterViewChecked
- ngOnDestroy

##### OnChanges
&emsp;&emsp;在 Angular1.x 中，如果想要监听数据的变化，需要设置$scope.$watch，然后在每次 digest 循环里判断数据是否有改变。在 Angular 中，ngOnChanges钩子把这个过程变得简单。只要在组件里定义了 ngOnChanges 方法，在输入数据发生变化时该方法就会被自动调用。

&emsp;&emsp;需要注意的是，ngOnChanges 当且仅当组件输入数据变化时被调用，“输入数据”指的是通过`@Input`修饰器显式指定的那些数据。如果是在`@ViewChildren`，`@ContentChildren`的结果集增加/删除了数据，ngOnChanges 是不会被调用的。

&emsp;&emsp;如果希望在 queries 结果集变化时收到通知，可以通过 changes 属性订阅其内置的observable。一般在`ngAfterContentInit`或`ngAfterViewInit`中去监听，而不是在构造器里或`ngOnInit`中。

```typescript
@Component({
  selector: 'my-list',
  template: `
    <ul>
      <ng-content></ng-content>
    </ul>
  `
})
export class MyList implements AfterContentInit {
  @ContentChildren(ListItem) items: QueryList<ListItem>;

  ngAfterContentInit() {
    this.items.changes.subscribe(() => {
       // 当 items 增加/删除了数据后，这里会被调用
    });
  }
}
```

##### OnInit
&emsp;&emsp;使用 ngOnInit 有两个重要的原因：

1. 构造后不久就要进行复杂的初始化
2. 在 Angular 设置输入属性之后就要设置组件

&emsp;&emsp;在 Angular 的组件中，经常会使用 ngOnInit 获取数据，那为什么不在组件构造函数中获取数据呢？因为构造函数做的事，应该是尽可能简单的，例如初始化局部变量这种简单的事情。这对于有经验的开发人员来说，已经是一种共识。另外，这对于 Angular 的自动化测试也有非常重要的作用，因为编写测试代码的开发人员，不需要担心一个新的组件在测试或者创建之前会尝试连接远程服务器获取数据。

##### DoCheck
&emsp;&emsp;开发者可以使用 DoCheck 钩子来检测并在 Angular 没有捕捉到自身变化的时候采取行动。通过这个方法可以检测到 Angular 忽略的这一变化。

&emsp;&emsp;ngDoCheck 被调用的频率很高 —— 每一个变化检测周期后，不管是否发生了变化。大多数这些初步检查是由 Angular 在网页其他地方不相关的数据第一次渲染的时候触发，例如简单地将鼠标移到另一个输入框就会触发调用。显然，ngDoCheck 方法中不能写一些复杂的代码，否则用户体验就会受到影响。

> 此处要注意，DoCheck 和 OnChanges 不能同时使用

##### AfterContentInit
&emsp;&emsp;ngAfterContentInit 会在 Angular 将外部内容放到视图内之后调用。

##### AfterContentChecked
&emsp;&emsp;ngAfterContentChecked 会在 Angular 检测放到视图内的外部内容的绑定后调用。

##### AfterViewInit
&emsp;&emsp;ngAfterViewInit 会在 Angular 创建了组件视图之后被调用。

##### AfterViewChecked
&emsp;&emsp;ngAfterViewChecked 在 Angular 检测了组件视图的绑定之后调用。

##### OnDestroy
&emsp;&emsp;组件在被销毁之前会触发这个勾子，ngOnDestroy 会被调用。建议把组件成员变量等东西的清理逻辑放到 ngOnDestroy 中，它是在指令/组件销毁之前必定运行的逻辑。在这个时候可以通知另一部分关心的程序，这个组将将要被销毁。

&emsp;&emsp;不会被垃圾处理自动收集的资源应当在这个地方去释放，例如订阅了的观察者事件，绑定过的 DOM 事件，通过 setTimeout 或 setInterval 设置过的计时器等，都应当在 ngOnDestroy 中去注销、删除所有与该组件相关的回调。如果忽略这些的话，会导致一些意想不到的后果，并有可能导致内存泄漏。

## 2.x 附表 —— @Component 的元数据一览

### 2.x.1 元数据一览表

| 名称 | 类型 | 作用 |
| --- | --- | --- |
| selector | string | 自定义组件的标签，用于匹配元素 |
| inputs | string[] | 指定组件的输入属性 |
| outputs | string[] | 指定组件的输出属性 |
| host | {[key: string]: string;} | 指定指令/组件的事件、动作和属性等 |
| providers | any[] | 指定该组件及其所有子组件（含 ContentChildren）可用的服务 |
| exportAs | string | 给指令分配一个变量，使得可以在模板中调用 |
| moduleId | string | 包含该组件模块的 id，它被用于解析模版和样式的相对路径 |
| queries | {[key: string]: any;} | 设置需要被注入到组件的查询 |
| viewProviders | any[] | 指定该组件及其所有子组件（不含 ContentChildren）可用的服务 |
| changeDetection | ChangeDetectionStrategy | 指定使用的变化检测策略 |
| templateUrl | string | 指定组件模板所在的路径 |
| template | string | 指定组件的内联模板 |
| styleUrls | string[] | 指定组件引用的样式文件 |
| styles | string[] | 指定组件使用的内联样式 |
| animations | AnimationEntryMetadata[] |  |
| directives | Array<Type or any[]> | 指定该组件需要依赖的其他指令，或组件 |
| pipes | Array<Type or any[]> | 指定该组件需要注入的管道 |
| encapsulation | ViewEncapsulation | 设置组件的视图包装选项 |
| interpolation | [string, string] |  |

### 2.x.2 元数据说明

&emsp;&emsp;在本章的内容中已对 selector、inputs、outputs、providers、viewProviders、 templateUrl、template、styleUrls、styles、directives、pipes、encapsulation、changeDetection 等元数据做了不同程度的讲解，以下将解析本章未提及的元数据。

##### host
&emsp;&emsp;host 是个非常强大的元数据，它主要用在指令中，通过 host 可以指定此指令/组件的事件、动作和属性等。因为 @Component 继承自 @Directive，所以 @Directive 中的配置也同样适用于组件。更多内容请参阅**指令**章节。

##### exportAs
&emsp;&emsp;此属性主要在指令中使用，作用是将指令分配给一个变量，使用这个名称就可以在模版中调用指令。因为 @Component 继承自 @Directive， 所以 @Directive 中的配置也同样适用于组件。更多内容请参阅**指令**章节。

##### moduleId
&emsp;&emsp;包含该组件模块的 id，它被用于解析模版和样式的相对路径。在 Dart 中，它可以被自动确定，并不需要去设置。在 CommonJS 中，它总是被设置为 module.id。 

##### queries
&emsp;&emsp;设置需要被注入到组件的查询。有两种查询，视图查询和内容查询，分别会在ngAfterViewInit和ngAfterContentInit回调函数被调用之前设置。

&emsp;&emsp;假设有种场景，你的组件里有一个输入框（input），希望在组件初始化之后，将焦点设置到输入框中。传统的做法，可能会是用代码选中 input 在 DOM 中的节点，然后调用 focus 方法。

```typescript
@Component({
  selector: 'my-input',
  template: `
    <input type="text" />
    <div>Input Component</div>
  `
})
export class MyInput {
  constructor(el: ElementRef) {
    // 直接操作 ElementRef 对应的 DOM 节点（不推荐）
    el.nativeElement.querySelector('input').focus();
  }
}
```

&emsp;&emsp;然而这种做法不推荐，只有极少的情况需要直接操作 DOM。Angular 提供了一系列高阶 APIs 来替代 DOM 操作，例如现在正在讲解的 queries。利用 Angular 提供的这些 APIs 的好处有：

- 降低单元测试复杂度
- 从浏览器中解耦，允许代码在任何渲染环境里运行（比如：Web Worker，或者服务器端，又或者是在 Electron 里）

&emsp;&emsp;那么上述例子可以用 queries 来优化。可以使用视图查询 @ViewChild/@ViewChildren 这两个 queries 获取当前组件模版里的内嵌组件到组件的成员变量中，当组件初始化后，就可以通过 renderer 执行 focus 方法了。

```typescript
@Component({
  selector: 'my-input',
  template: `
    <input #theInput type="text" />
    <div>Input Component</div>
  `
})
export class MyInput implements AfterViewInit {
  @ViewChild('theInput') input: ElementRef;

  constructor(private renderer: Renderer) {}

  ngAfterViewInit() {
    this.renderer.invokeElementMethod(this.input.nativeElement,    
    'focus');
  }
}
```

&emsp;&emsp;读者可能有疑问，上面的代码 queries 在哪里？事实上，上面的代码和下面的代码是等价的：

```typescript
@Component({
  selector: 'my-input',
  template: `
    <input #theInput type="text" />
    <div>Input Component</div>
  `,
  queries: {
    input: new ViewChild('theInput')
  }
})
export class MyInput implements AfterViewInit {
  input: ElementRef = null;

  constructor(private renderer: Renderer) {}

  ngAfterViewInit() {
    this.renderer.invokeElementMethod(this.input.nativeElement,    
    'focus');
  }
}
```

&emsp;&emsp;以上便是视图查询，简言之借助视图查询和 Angular 提供的 APIs 可以获得在组件模板上定义的 DOM 节点。那么内容查询又是什么呢？和视图查询类似，只不过内容查询是配合 ng-content 使用的，它用来获得不在组件模版定义里定义的元素。假设有一个列表组件 MyList，它允许用户自定义内容，然后你需要列表的数量。既然是自定义的内容，那我们不可能要求用户能在内容里写上元素的 id，即不能通过 id 去获取，可以通过选择器指令。

&emsp;&emsp;假设用户使用 MyList 写的代码如下：

```html
<my-list>
   <li *ngFor="#item of items"> {{item}} </li>
</my-list>
```

&emsp;&emsp;然后你需要获得 li 的列表，可以使用 `@Directive` 修饰器，它提供了 selector 的功能，据此来定义一个能查找/选择 `<li>` 元素的指令，用 `@ContentChildren` 获得 li 元素。

```typescript
// 定义 li 选择器，命名为 ListItem
@Directive({ selector: 'li' })
export class ListItem {}

// 组件代码，使用 ng-content 允许自定义内容
@Component({
  selector: 'my-list',
  template: `
    <ul>
      <ng-content></ng-content>
    </ul>
  `
})
export class MyList implements AfterContentInit {
  @ContentChildren(ListItem) items: QueryList<ListItem>;

  ngAfterContentInit() {
     // 此时便能对 items 进行操作
  }
}
```

&emsp;&emsp;以上代码，和以下使用 queries 的代码也是等价的：

```typescript
@Component({
  selector: 'my-list',
  template: `
    <ul>
      <ng-content></ng-content>
    </ul>
  `,
  queries: {
    items: new ContentChildren(ListItem)
  }
})
export class MyList implements AfterContentInit {
  items: QueryList<ListItem>;

  ngAfterContentInit() {
  }
}
```

##### pipes
&emsp;&emsp;用于指定组件对应的模板中使用的属性过滤、格式化处理的类，更多的内容请参阅**模板**章节的相关内容。


## 2.4 组件交互

从前面的章节了解到，Angular应用是由各式各样的组件组成，这些组件形成了一颗完整的组件树，数据在组件间完成交互。那么组件是如何与该组件树中的其它组件进行数据交互的呢？组件间的交互包括父子组件间和兄弟组件间的数据传递，如从父组件向子组件传递数据，在子组件中使用拦截器来拦截输入属性的变化，以此实现数据从父组件到子组件的交互，相反，父组件可以绑定相关事件，由子组件来触发该事件来达到数据交互的目的，这就是组件交互的大致实现方式。组件交互就是组件通过一定的方式来达到有权限访问其它组件中的属性或方法来实现数据双向流动的一种方式。

除了前面介绍的，组件交互还有丰富的形式供你选择，比如父子组件通过本地变量交换数据，除了父子组件之间通过分享数据接口实现组件的双向通信服务外，还有一些结构上不相关的组件，即组件通过服务来实现通信，那么本节将重点讲述如下的几种组件交互：

- 从父组件向子组件传递数据
- 子组件与父组件的数据交互
- 通过服务实现组件间的数据通信

### 2.4.1 父组件向子组件传递数据
本节将讲解父组件和子组件通过输入属性来完成组件间的交互，数据由父组件的输入属性绑定流入子组件，在子组件完成接收或拦截，以此实现了数据由上而下的数据传递。在本章前面的小节中有具体讲解到了输入输出（@Input & @Output）属性的具体使用方法，这里不再进行展开，接下来通过后面组件间数据交互例子的讲解来进一步加深理解这些概念。下面将用第一章中通讯录联系人及联系人详情页收藏的例子来学习使用输入属性绑定从父组件向子组件传递数据来讲解组件的数据交互。

#### 父到子组件间的数据传递
在前面章节中的通讯录联系人列表，该列表可能包含多个联系人，我们需要在该联系人列表中展示每条联系人的姓名、联系方式、收藏等具体数据。我们先看下面的代码示例：

```js
import { Component, OnInit } from '@angular/core';
import { ContactListComponent } from './contact-list.component';

@Component({
  selector: 'list',
  template: `
  	<ul class="list">
	  <contact-child *ngFor="let contact of contacts" [contact]="contact">
	  </contact-child>	
	</ul>
  `,
  directives: [ContactListComponent]
})

export class ListComponent implements OnInit {
  this.contacts = data; // data为获取到的联系人数据
}
```

父组件`ListComponent`通过`ngFor`属性指令（属性指令请参考下一章模板的具体详解）将每个联系人实例对象通过属性绑定的方式绑定到其属性`contact`中。该父组件通过元数据`directives`引入子组件`ContactListComponent`，数据由上而下流入子组件，在该子组件中通过@Input修饰器进行数据的接收。子组件的具体代码示例如下：

```js
import { Component, Input } from '@angular/core';

@Component({
  selector: 'contact-list',
  template: `
  	<li>
  	  <a (click)="goDetail(contact.id)">
		  <div class="contact-info">
		    <label class="contact-name">{{ contact.name }}</label>
		    <span class="contact-tel">{{ contact.telNum }}</span>
		  </div>
		</a>
	</li>
  `
})

export class ContactListComponent {
  @Input() contact:any = {};
  @Output() routerNavigate = new EventEmitter<number>();
  ...
  goDetail（） {
  	  this.routerNavigate.emit(num); //  跳转到具体的详情页面
  }
}
```

上面的例子是要在具体联系人中展示的信息为联系人姓名`name`和联系人电话号码`telNum`等，这两个属性在`contact`对象下，在这个组件中是没有任何获取`contact`对象的操作，数据的来源是通过由修饰器`@Input()`来获取，这个`contact`对象来自于其父组件`ListComponent`属性绑定的内容，通过输入属性绑定的方式将值赋值给这个属性表达式。

前面也讲解到Angular应用是由各式各样的组件组成，当应用被启动（即bootstrap）时，Angular会从根组件开始启动，并解析整棵组件树，数据由上而下的方式流向下一级子组件。不过需要注意的是，目标属性必须通过输入属性(@Input)明确的标记修饰才能接收到来自父组件的数据，对于此例，也就是说必须在子组件中用修饰器`@Input`修饰，才能通过模板属性绑定表达式把数据流入绑定的属性中，从而在子组件中完成数据的接收。

该小节例子通过上面两个父子组件的数据交互，通过使用输入属性绑定实现了从父组件向子组件传递数据，即数据由父组件流出，通过输入属性流入子组件，在子组件通过输入属性(@Input)完成数据的接收。

#### 拦截输入属性
##### setter和getter拦截输入属性
`getter`和`setter`是用来约束属性的设置和获取的，它们提供了一些属性读写的封装，可以让代码更便捷，更具可扩展性。其中`setter`可以对属性进行再封装处理，即把复杂的内部逻辑用访问权限来隔绝外部调用，以避免外部的错误调用影响到内部的状态，同时也是把内部复杂的逻辑结构封装成高度抽象可被简单调用属性，以方便使用者的调用。

上一节中讲到了通过输入属性来实现父子组件的数据交互，除此之外，组件还可以通过属性`setter`来拦截来自父组件的数据源，并对拦截到的数据进行再处理，使数据的输出更加合理和可控。下面的例子中，父组件将继续沿用前面的`ListComponent`组件，仅仅对子组件修改如下：

```js
@Component({
  selector: 'contact-list',
  template: `
  	<li>
	  	<a (click)="goDetail(contact.id)">
		  <div>
		    <label class="contact-name">{{ contact.name }}</label>
		    <span class="contact-tel">{{ contact.telNum }}</span>
		  </div>
		</a>
	</li>
  `
})

export class ContactListComponent {
  _contact: object = {};
  @Input()
  set contact(contact: object) {
    this._contact.name = (contact.name && contact.name.trim()) || 'no name set';
    this._contact.telNum = contact.telNum || '000-000';
  }
  get contact() { return this._contact; }
}
```
父组件`ListComponent`中的联系人通过属性绑定的方式将数据绑定到`contact`属性上，数据由上而下流入到其子组件中，`contact`属性的数据在子组件`ContactListComponent`中被`setter`拦截器拦截，对其进行数据的再加工处理，使得数据处理的自由度更高，数据的展示更符合预期等。在这个例子中，可以在子组件中对拦截到的数据源进行再处理，即使得联系人数据不会出现为空的情况，最终将数据展示到视图层。

##### ngOnChanges监听数据变化
在生命周期勾子的章节中已经了解过生命周期勾子的接口`OnChanges`，其中的方法`ngOnChanges`，通过该方法能够监测数据的变化并处理数据的变化，下面将举例来详细讲解`ngOnChanges`监听数据变化，请看下面编辑修改联系人数据的例子：
```js
import { Component } from '@angular/core';
import { ChangeLogComponent } from 'change-log.component';

@Component({
  selector: 'detail',
  templateUrl: `
   <a class="edit" (click)="editContact()">编辑</a>
  	...
  	<change-log [contact]="detail"></change-log>
  `
})

export class EditContactComponent {
  contact_id: number;
  detail:any = {};
  contacts:any = {};
  ngOnInit() {
    this.sub = this._activatedRoute.params.subscribe(params => {
      this.editId = params['id'];
      this.getById(this.editId);
    })
  }
  
  editeContact() {
    // 完成联系人编辑修改
    let edit_contact = {
      "id": this.editId,
      "name": this.contact.name,
      ...
    };
    ...
    this.contacts.splice(this.editId - 1, 1, edit_contact);
  }
  
  getById(id:number) {
    // 获取联系人详情信息
    this.detail = this.contacts[id-1];
  }
}
```

该例子中，通过点击“编辑”按钮来完成修改联系人数据操作，修改后的联系人数据通过子组件`change-log`进行输出，这里我们仅仅是输出修改数据的前后数据对比，即每次点击修改按钮，`editContact`方法完成联系人数据的修改，将数据通过输入属性绑定的方式绑定到`contact`属性中，在子组件中完成接收，以此来输出联系人修改前后的数据变化对比，子组件示例的代码如下：

```js
import { Component, Input, OnChanges, SimpleChange } from '@angular/core';

@Component({
  selector: 'change-log',
  template: `
    <h4>Change log:</h4>
    <ul>
      <li *ngFor="let change of changeLog">{{change}}</li>
    </ul>
  `
})
export class ContactChildComponent implements OnChanges {
  @Input() contact :any = {};
  changeLog: string[] = [];
  ngOnChanges(changes: {[propKey:string]: SimpleChange}){
    let log: string[] = [];
    for (let propName in changes) {
      let changedProp = changes[propName];
      let from = JSON.stringify(changedProp.previousValue);
      let to =   JSON.stringify(changedProp.currentValue);
      log.push( `${propName} changed from ${from} to ${to}`);
    }
    this.changeLog.push(log.join(', '));
  }
}
```

在子组件中，通过`ngOnChanges`钩子方法来监测数据变化前后的数据，`ngOnChanges`当且仅当组件输入数据变化时被调用，“输入数据”指的是通过@Input修饰器显式指定的那些数据。其中的`previousValue`是修改前的数据，`currentValue`是修改后当前联系人的数据。每次点击父组件的修改按钮，都会在changeLog中记录了数据的变化并以文本的形式输出到页面上。

在子组件中，我们能捕获到父组件中数据的变化，甚至变化的细节都可以通过`changedProp`的属性来监测变化的细节。该例子中会逐条输出变化的log，清晰的看到修改的数据变化。

### 2.4.2 子组件向父组件传送数据

#### 父组件监听子组件事件
Angular使用自定义事件来完成数据的传递接收，`EventEmitter`即实现了observable，又实现了observer接口(相关内容请见后面Rx.js小节)。本节将介绍子组件向父组件传送数据，子组件通过暴露一个`EventEmitter`属性，这个属性是一个输出属性，由修饰器@Output修饰，当有用户行为操作发生时该事件会被触发，父组件则通过事件的绑定方式来订阅来自子组件中触发的事件，当在子组件中具体事件触发时会反应在该父组件当中。下面实现的例子是在联系人列表中会有一个收藏的按钮，点击按钮会收藏该联系人，并完成联系人的收藏操作，具体代码示例如下：

```js
import { Component, EventEmitter, Input, Output } from '@angular/core';
@Component({
  selector: 'contact-collect',
  template: `
    {{ name }}
    <i [ngClass]="{collected: detail.collection}" (click)="collectTheContact()">收藏</i>
  `
})
export class ContactCollectComponent {
  @Input()  name: string;
  @Output() onCollected = new EventEmitter<boolean>();
  collectTheContact(){
    this.onCollectd.emit();
  }
}
```

子组件中通过数据绑定的方式实现了一个点击收藏的功能，点击“收藏”按钮后将触发通过输出属性自定义的事件`onCollected = new EventEmitter<boolean>()`，输出事件通过`emit()`方法被触发后，在父组件能够监听到来自子组件的输出属性绑定的自定义事件，以此来来处理数据的变化。具体父组件的示例代码如下：

```js
import { Component }      from '@angular/core';
import { ContactCollectComponent } from 'contact-collect.component';
@Component({
  selector: 'collect-taker',
  template: `
    <contact-collect [name]="contact.name" (onCollected)="onCollected($event)"></contact-collect>
  `,
  directives: [ContactCollectComponent]
})
export class CollectTakerComponent {
  detail:any = {};
  ...
  collectTheContact() {
    this.detail.collection == 0 ? this.detail.collection = 1 : this.detail.collection = 0;
    ...
  }
}
```

父组件`CollectTakerComponent`通过绑定自定义事件`onCollected`来订阅来自子组件触发的事件，即通过事件绑定的形式来监听是否有来自子组件对应的事件被触发，当对应的事件通过`emit`方法触发后，在父组件中能够监听到该事件，以此来完成收藏方法的的具体代码逻辑实现，从而完成收藏联系人的功能。

#### 父子组件通过局部变量实现数据交互
前面实现的组件间数据交互都是通过输入输出属性绑定的方式来实现数据双向流动，但是，父组件仅仅是将数据源流向下级的子组件，父组件不能拥有读取子组件的相关成员变量的权限，也不能调用子组件的相关成员变量方法。在下面的模板章节中，我们将会接触模板局部变量的概念，模板局部变量的作用域范围是定义该模板局部变量的整个子组件（相关模板局部变量请参考下一章模板中的相关表述），这里可以通过创建模板局部变量的方式来实现父组件与子组件数据交互这种场景，即在父组件的模板中为子组件的模板创建一个局部变量，那么这个父组件可以通过这个局部变量来获得读取子组件成员变量的权限，也可以获取到调用子组件中成员方法的权限，现在用通讯录例子中收藏的例子来说明，具体例子如下：

```js
import { Component, EventEmitter, Input, Output } from '@angular/core';
@Component({
  selector: 'contact-action',
  template: `
    <button (click)="collectTheContact()">收藏</button>
  `
})
export class CollectActionComponent {
  detail:any = {};
  ...
  collectTheContact() {
    this.detail.collection == 0 ? this.detail.collection = 1 : this.detail.collection = 0;
    ...
  }
}
```

这是一个联系人收藏的功能，该组件在`collectTheContact`方法实现了收藏的功能，但是在父组件中是没有调用`collectTheContact`的权限的，同样的也不可能获取到这个联系人`collection`的属性，这个时候可以通过定义局部模板变量`#collect`来实现，即在标签元素`<collect-action>`中放置一个局部变量`collect`，以此来获取到整个子组件的作用域，其本质是该变量获取到了这个子组件本身的一份参考，并能被父组件获取到该子组件中成员变量和方法的权限，父组件的代码示例如下：

```js
import { Component, EventEmitter, Input, Output } from '@angular/core';
@Component({
  selector: 'contact-collect',
  template: `
    <span class="contact-name">
        {{ detail.name }}
        <i [ngClass]="{collect: detail.collection}">收藏</i>
        <collect-action #collect></collect-action>
    </span>
  `，
  directives: [ContactCollectComponent]
})
export class ContactCollectComponent {}
```

在这整个例子中，通过点击收藏按钮来实现收藏功能，具体功能的实现在子组件中实现，在父组件中通过子组件元素`collect-action`绑定一个局部变量来获取到子组件的一份参考，从而获取到了联系人详情信息数据，并能将联系人详情数据展示在视图中，这就是一个完整的父子组件通过局部变量实现数据交互完整实现方式。

#### 使用`@viewChild`获取子组件的引用
使用局部变量实现父组件调用子组件的成员函数或者成员变量，这样看上去既简单也容易，但是这样也有它的一些局限性，就是必须在父组件的模板中对应上“父-子”关系的写法，这样代码的耦合性还是有一定的代价的，并且父组件并不是真正的获取到了子组件的成员变量和方法的权限，其本质是该变量获取到了这个子组件本身的一份参考。

当父组件需要获取到子组件中变量或者方法的读写权限时，可以通过注入的方式来实现，即在父组件中通过`ViewChild`注入子组件。下面的例子继续用上节中收藏的例子，要实现的功能一样，其中子组件的代码还是保留之前的，对父组件代码修改如下：

```js
import { Component } from '@angular/core';
@Component({
  selector: 'contact-collect',
  template: `
    <span class="contact-name">
        {{ detail.name }}
        <i [ngClass]="{collect: detail.collection}">收藏</i>
        <collect-action  (click)="collectTheContact()"></collect-action>
      </span>
  `
  directives: [CollectActionComponent]
})
export class ContactCollectComponent {
  @ViewChild(CollectActionComponent)
  private actionComponent: CollectActionComponent;
  
  collectTheContact() {
    this.actionComponent.collectTheContact();
  }
}
```
这种实现方式把按钮绑定到了父组件中，同时在父组件的组件类中来调用子组件中的方法，其中通过@ViewChild修饰器将`CollectActionComponent`子组件注入进来，并实现了一个私有的`actionComponent`属性。

// todo 需要移动到服务章节去，待和相关作者确定如何扔过去.
### 2.4.3 父组件和子组件通过服务进行交互
在前面两个小结中提到的组件交互，其实并没有真正实现实际的交互通信，这种数据的流动设计是由数据驱动，并由事件改变的。本节将重点讲解父子组件之间通过共享一个`service`的接口实现组件的双向通信服务,该服务实例的作用范围是父组件和它的孩子们，在这个组件树之外的组件没有权限接入到服务并进行通信的。

下面实现一个`SharedService`来供`parentComponent`和`ChildComponent`共享这个实例，通过在子组件中的输入框来添加数据，以此来实现组件中的交互通讯。这个公共的service代码如下所示：

```js
import {Injectable} from 'Angular/core';

@Injectable()
export class SharedService {
  dataArray: string[] = [];

  insertData(data: string){
    this.dataArray.unshift(data);
  }
}
```

在父组件`parentComponent`中，逐条展示每条数据，同时引入子组件`<child-component>`来处理数据源，父组件的代码示例如下：

```js
import {Component} from 'Angular/core';
import {SharedService} from './shared.service';
import {ChildComponent} from './child.component';
@Component({
  selector: 'parent-component',
  template: `
    <ul *ngFor="#data in data">
      <li>{{data}}</li>
    </ul>
    <child-component></child-component>
  `,
  providers: [SharedService],
  directives: [ChildComponent]
})
export class parentComponent{
  data: string[] = [];
  constructor(private _sharedService: SharedService) {}
  ngOnInit():any {
    this.data = this._sharedService.dataArray;
  }
} 
```
在子组件`ChildComponent`中，设置一个点击按钮来处理增加的数据，当在该组件中添加数据后，能在父组件中实时的反应出来。

```js
import {Component} from 'Angular/core';
import {SharedService} from './shared.service'

@Component({
  selector: 'child-component',
  template: `
    <input type="text" [(ngModel)]="data"/>
    <button (click)="addData()"></button>
  `
})
export class ChildComponent{
  data: string = 'Testing data';
  constructor(private _sharedService: SharedService){}
  addData(){
    this._sharedService.insertData(this.data);
      this.data = '';
  }
}
```

组件间通过共享一个service实例来进行数据的交互，在父组件的元数据中的`provide`引入这个共享的实例对象，而在子组件中则不需要这样做，但是在子组件中需要通过`import`来引入这个service，并且在构造函数`constructor`注入即可。

## 2.5 变化监测机制
在`Angular`中提供了数据绑定的功能（在模板章节会详细介绍），所谓数据绑定即将数据和页面DOM元素关联起来，当数据发生变化或者更改后，Angular能够检测到这些变化或者更改，并对其所绑定的DOM元素进行相应的更新，反之亦然。它的数据流向是单项的，通过属性绑定和事件绑定来实现数据的流入和流出，数据从属性绑定流入组件，从事件流出组件，`Angular`数据的双向绑定就是通过这样来实现的。

### 2.5.1 引起数据变化的源头
在Angular应用中，引起数据变化的应用场景无非就那么几种情况，一类是用户的行为操作，即页面操作所引发的用户事件，如click, change, hover等，对用户的操作做出响应；也有可能是前后端的数据交互，如从远端服务拉取页面所需要的接口数据，这是一个异步的过程，获取到一份较之前可能有变化的数据；最后一种是各类定时任务，在某个延时后触发来响应对应的操作，对页面数据做出改变等。

以上三种可能导致数据变化的共同特征很明显的共同点是它们都是异步的处理，即需要使用异步回调函数，这带给我们的结论就是，任意的一个异步操作，都有可能在数据层面上发生改变，这可能导致应用程序状态已经被改变，因此，如果可以在每一个异步回调函数执行结束后，能够通知Angular内核进行更改检测，那么任何数据的更改就可以被实时地反应出来。

下面举个简单的例子进行说明，可以在组件的模板元数据中添加如下代码片段：

```html
	<i [ngClass]="{collect: detail.collection}" (click)="collectTheContact()">收藏</i>
```

该例子是一个通讯录收藏的功能实现，当用户点击收藏按钮后，这将告诉`Angular`此时的联系人详情中的收藏数据发生改变，通知视图层做出相应的改变等。

在Angular现有的应用场景下，开发者们大致认为引起数据变化的源头有如下3类：`event`类、`xmlHTTPRequest/webSocket`类、`timeout`等页面的各类定时任务，如`setTimeout, setInterval, requestAnimationFrame`，都是在某个延时后触发。

### 2.5.2 变动通知机制
上一小节介绍了可能引起页面数据的几种场景，通过异步处理来通知页面重新更新数据源，因此，如果可以在每一个异步回调函数执行结束后，能够通知Angular内核进行更改检测，那么任何数据的更改就可以被实时地反应出来，但是，Angular本身是不具备这样的通知机制的，为了实现这种机制，引入了ngZone这个服务。

为了更好的让您理解ngZone这个服务，本文先介绍zone的原理。

#### zone的实现原理
Zone实际上是Dart的一种语言特性，其是对Javascript某些设计缺陷的一些补充，简单的可以概述成Zone是一个异步事件拦截器，也就是说Zone能够hook到异步任务的执行上下文，以此来处理一些操作，比如说，在每次启动或者完成一个异步的操作、进行堆栈的跟踪处理、某段功能代码进入或者离开Zone，可以在这些关键的节点重写所需处理的方法。

Zone中提供了各类勾子（hooks），允许在每一个回调函数的开始和结束时，去执行统一的自定义逻辑，其本身是不做任何事的，相反它是依赖其它的代码，获取到这些代码片段的执行上下文，通过勾子来完成相关的功能。Zone的另一值得一提的是它必须依赖异步操作，当一个异步操作在执行时，它是有必要去捕获的这个异步操作并在该异步功能开始或者完成时建立对应的回调函数，然后存储到当前的Zone，举个例子，如果一个代码片段在fork的Zone中执行，并且这段代码中包含一个`setTimeout`的异步任务，那么执行到和完成这个`setTimeout`方法需要包裹一个异步的回调函数，存储到当前zone，这样是确保每个异步操作之间的相互不受影响，也就是受保护的状态，例如一个页面由业务代码和一些第三方广告代码组成，这两份代码之间是相互独立的，需要的是业务代码的异常捕获数据提交到自己的后台服务器上，第三方广告代码的异常捕获提交到自己的服务器上。当fork了多个Zone之后，异步操作将会精准的执行其所在的子Zone上面方法。

Zone的一个重要意义在于，所以来的功能或者业务代码运行在了fork的一个Zone中，该子Zone有了对该代码块执行上下文的控制权。其中也提供了一些勾子(hook)来处理基本的业务情景需求，这里你需要了解的勾子函数大致有：

- `Zone.onZoneCreated`即在Zone被fork时运行
- `Zone.beforeTask`即在执行`zone.run`包裹的函数之前调用
- `Zone.afterTask`即在执行`zone.run`包裹的函数之后调用
- `Zone.onError`即`zone.run`方法中的任务抛出异常时的勾子函数

通过上面的讲述您应该对Zone的实现原理有个大致的理解了，下面举个例子来加深对Zone的理解：

```js
zone.fork({
    beforeTask: () => {
        console.log('hi, beforeTask in.');
    },
    afterTask: () => {
        console.log('hi, afterTask in.');
    }
}).run(function () {
  zone.inTheZone = true;

  setTimeout(function () {
    console.log('in the zone: ' + !!zone.inTheZone);
  }, 0);
});

console.log('in the zone: ' + !!zone.inTheZone);
```

这段代码按照执行上下文顺序的执行，在zone的`run`函数执行的开始和结束会有对应的勾子函数进行处理，在执行环境中按照代码的执行顺序，最新看到的是`beforeTask`中的打印，接下来是最后边的打印，待到`setTimeout`方法执行后，完成整个任务并执行`afterTask`方法，该JavaScript代码的执行结果如下：

```HTML
hi, beforeTask in.
in the zone: false
in the zone: true
hi, afterTask in.
```

现在来概括下什么是Zone，它们基本上是获取到了一个异步操作的执行上下文，并且证明了在错误处理和分析非常有用，通常情况下，这些的异步处理，比如说是服务端异步返回所需要的数据，或者是一些异步事件更改视图模型的数据等，通过`beforeTask`和`afterTask`等勾子函数能够很好的在异步事件发生或者结束的时候，允许在这样的异步任务节点执行一些分析代码。

在一些复杂的业务逻辑场景下，上面提及的这些可能远远不够用，很多时候应用场景要比这个例子要复杂的多，`zone.js`采用猴子补丁(Monkey-patched)的方式将JavaScript中的异步任务都进行了包裹，同样的这使得这些异步任务都将运行在Zone的执行上下文中，每一个异步的任务在zone.js都是一个任务，除了提供了一些供开发者使用的勾子(hook)函数外，默认情况下zone.js重写了并提供了如下的方法:

- Zone.setInterval() / Zone.setTimeout()
- Zone.alert()
- Zone.prompt()
- Zone.requestAnimationFrame()
- Zone.addEventListener()
- Zone.removeEventListener()

综上所述，应该能理解Zone的应用场景了，即实现了异步task的跟踪分析和错误记录以便更好的进行开发debug等。

#### Angular2中的ngZone
下面来介绍ngZone。实际上，ngZone是基于Zone.js来实现的，Angular2的ngZone从zone.js中fork了一份参考，它是Zone派生出来的一个子Zone，在Angular2环境内注册的异步事件都运行在这个子Zone上(因为ngZone拥有整个运行环境的执行上下文)，ngZone拓展了自己的一些API并添加了一些功能性的方法到它的执行上下文中，这些勾子方法如`onTurnStart`和`onTurnDone`事件也会在该子Zone的`run`方法中触发。另外值得提出的是，在ngZone的TypeScript定义中，并没有把这个子Zone给暴露出来，因此只能通过ngZone的提供的方法来间接地对该子Zone进行操作。

NgZone提供了一些我们能订阅的自定义事件，具体如下：

- `onTurnStart`即在Angular事件启动前通知订阅器，触发每一次是由Angular处理的浏览器任务事件。
- `onTurnDone`即在Angular zone完成当前任务时立即通知订阅者
- `onEventDone`在完成`onTurnDone()`回调之后在VM事件之前立即通知订阅者，常用来测试验证应用程序状态。

NgZone提供的这些自定义事件在跟踪定时器和其他微任务时是非常有用的，由于NgZone其实只是全局Zone的一个fork，Angular对于在Zone内需要或不需要执行变化检查，都具有完全的控制权，这为什么是有用的？因为我们并不总是希望Angular神奇地进行变化检测，具体我们会在下面的小节给您详细讲解。

综上所述，Zone几乎在任何浏览器的全局异步操作打上了猴子补丁，并且NgZone只是Zone fork出来的一份参考，当异步操作发生时就会通知框架进行变化检测，例如当类似于mousemove事件发生时，它也将引发变化检测。

在Angular源码中，有一个`ApplicationRef`类，其作用是用来监听ngZone中的onTurnDone事件，不论何时只要触发这个事件，那么将会执行一个tick()方法用来告诉Angular去执行变化监测。Angular变化检测的原理大致如此，具体的`ApplicationRef`类如下：

```js
  // very simplified version of actual source
  class ApplicationRef {
    changeDetectorRefs:ChangeDetectorRef[] = [];
    constructor(private zone: NgZone) {
      this.zone.onTurnDone.subscribe(() => this.zone.run(() => this.tick());
	 }
	 tick() {
	   this.changeDetectorRefs.forEach((ref) => ref.detectChanges());
	 }
  }
```

### 2.5.3 变化检测的响应处理
到目前为止，已经知道了何时会触发变化监测，但是变化检测是怎么响应处理的呢？这里需要理解的一个概念是，每个组件都会有它的变化监测器，一个Angular应用由一颗组件树组成，由此也将有一颗变化监测树，这种变化监测树是线性流向的，数据的流向是从上到下，这是因为变化检测的执行总是由根组件开始，从上到下的检测每一个组件的变化，单向的数据流相对环形数据流来说要更好预测的多，其实就更清楚视图中数据的来源，也就是说这些数据的变化是来自于哪个组件数据变化的结果。如前面所讲，当一个异步事件发生并导致数据的改变，在组件中绑定的相关处理事件将会被触发，NgZone将会去执行勾子函数并通知Angular执行一次变化检测。理论上在每一次变化检测不得不要去检测每一个组件的变化，但是执行这么一次完整的检测只需要几毫秒的时间就能完成。

#### 组件内部的变化检测的处理
Angular在整个运行期间都会为每一个组件创建监测类，用来监测每个组件在每个运行周期是否有异步操作发生。任何的一个Angular应用都是由大大小小的组件组成的，可以把它看成是一颗线性的组件树，重要的是，每一个组件都有自己的变化检测器，以此来组成了Angular应用的一颗组件树，通过下面的例子来说明：

```js
@Component({
  template: '<v-card [vData]="vData"></v-card>'
})
class VCardApp {
  constructor() {
    this.vData = {
      name: 'Jason',
      email: 'Jason@gf.com.cn'
    }
  }

  changeData() {
    this.vData.name = 'Jofix';
  }
}
```
`VCardApp`把`<v-card>`作为一个子组件，其中有一个输入属性`vData`，数据通过`VCardApp`的对象`vData`传递到子组件，同样的，在组件中有一个`changeData`方法提供用来修改对象`vData`中的`name`属性值。当变化监测被执行时会发生什么呢？假象一下`changeData()`方法在一个异步的操作之后被执行，那么`vData.name`被改变，然后被传递到<v-card [vData]="vData"></v-card>的变化检测器来和之前的数据对比是否有改变，如果和参照数据对比有变动的话，Angular将更新视图。

那么在这个组件中，变化检测器是如何处理的呢？在`changeData()`被执行之后，属性值`name`被修改，然后被传递到`<v-vard>`组件中，该组件的变化检测器立刻校验`vData`对象和之前的参照对比是否有改变，如果没有改变的话，保持原有的参照不变，当其中的属性变化后，Angular将会针对这个`vData`对象执行变化检测。因为在JavaScript语言中不提供给我们对象的变化通知，所以Angular必须保守的要对每一个组件的每一次运行结果执行变化检测，但其实很多组件的输入属性是没有变化的，没必要对这样的组件来一次变化监测，如何减少不必要的监测，下文将继续探讨。

### 2.5.4 深入理解（可选）
#### 变化检测性能优化
上节中有讨论到Angular在有引起数据变化的操作发生时，将不得不在单次的运行期间对每个组件经行变化监测，当然在组件中有相关的变化的话这些检测是有意义的，但是在整个应用中，很多时候只是组件的局部有变化或者数据更改，但是Angular还是会针对每一个组件执行变化检测，这样的检测显然是有些浪费的。

事实上，在组件中数据的变化与否是有数据结构给我们提供担保的，下面将介绍`Immutables`和`Observables`，如果我们使用这些结构和类型，在Angular中做相应的标识，变化检测将会执行组件中有变化的部分，这样对变化监测性能的提升是有重大意义的。

##### 使用`immutable`机制提升检测性能
不可变对象(Immutable Objects)给我们提供的保障是对象不会改变，即当其内部的属性发生变化时，相对旧有的对象，我们将会保存另一份新的参照。它仅仅依赖输入的属性，也就是当输入属性没有变动（没有变动即没有产生一份新的参照），Angular将跳过对该组件的全部变化监测，直到有输入属性（@input）变化为止。如果需要在Angular2中使用不可变对象，我们需要做的就是设置changeDetection: ChangeDetectionStrategy.OnPush，如下的例子：

```js
@Component({
  template: `
    <h2>{{vData.name}}</h2>
    <span>{{vData.email}}</span>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
class VCardCmp {
  @Input() vData;
}
```

例子中，`VCardCmp`仅仅依赖它的输入属性，同时我们也设定了`ChangeDetectionStrategy`变化监测策略为`OnPush`来告诉Angular如果输入属性没有任何变化的话，则跳过对该子组件的变化监测。

```js
@Component({
  template: `
    <h2>{{vData.name}}</h2>
    <span>{{vData.email}}</span>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
class VCardCmp {
  @Input() vData;
}
```

现在想象一下应用中的那个巨大的组件树，当设置了`ChangeDetectionStrategy`变化监测策略为`OnPush`后，在`immutable`对象的属性不被改变的情况下，我们会跳过子组件的变化检测，只检测有改变的部分，相对于整个组件树的变化检测可想而知会有质的提升。

##### 使用`Observables`机制提升检测性能
使用`Observables`机制提升检测性能和不可变(immutable)对象类似，但它们有相关变化的时候不会提供一份新的参照，可观测对象在输入属性发生变化的时候来触发一个事件来更新组件视图，同样的，我们也是添加`OnPush`来跳过子组件树的监测器，但是它不会像之前的不可变对象那样在输入属性有变化的时候修改数据参照，那它是如何通知是否需要进行变化检测的呢？Angular针对特定的事件有一种非常智能的方式来启用组件树的路径来被检测，这种情形是非常的精确的，下面给这样的一个例子来帮你加深理解：

```js
@Component({
  template: '{{counter}}',
  changeDetection: ChangeDetectionStrategy.OnPush
})
class CartBadgeCmp {

  @Input() addItemStream:Observable<any>;
  counter = 0;

  ngOnInit() {
    this.addItemStream.subscribe(() => {
      this.counter++; // application state changed
    })
  }
}
```

该组件是模拟的当用户触发一个事件后增加counter这样一个场景，确切的讲，`CartBadgeCmp`设置了一个插值`counter`和一个输入属性`addItemStream`，该组件在其`ngOnInit`生命周期勾子中订阅了一个事件流来增加`counter`的数值，当有异步操作需要更新`counter`的时候，将会触发这个事件流。

值得一提的是，在这个例子中设置了变化检测策略为`onPush`，正是因为`addItemStream`不会再生产一份新的参考，这样的话整个运行期间，都不会对子组件执行变化检测了，那么，在输入属性有变化的时候，变化检测器怎么执行变化检测呢？否则的话达不到这个例子想要的目的了。如下图5-2所示，整个组件树灰色代表在有数据变化事件发生后，没有任何的变化检测。
![](https://github.com/gf-rd/gf-Angular-book/blob/master/_images/chapters2-2/change-detect-1.png?raw=true)

图 5-1 

正如前面了解到的那样，变化检测总是由根组件到具体的子组件这样一个从上到下的顺序执行的，这里所说的变化检测优化其实是要准确的知道当前变化的子组件到根组件的具体路径，变化检测仅仅就只按照这个路径检测，而不是整个组件树全部检测一遍。Angular是不知道那一条路径有改变的，但是我们知道，我们可以通过依赖注入给组件来引入一个`ChangeDetectorRef`，其中包含该一个`markForCheck`的标记方法，这个方法正是我们所需要的，它能标记有数据变化的子组件到跟组件的具体路径，代码示例如下：

```js
class CartBadgeCmp {
    constructor(private cd: ChangeDetectorRef) {}

    @Input() addItemStream:Observable<any>;
    counter = 0;

    ngOnInit() {
        this.addItemStream.subscribe(() => {
            this.counter++; // application state changed
            this.cd.markForCheck(); // marks path
        })
    }
}
```
当这个可监测的`addItemStream`触发一个事件，该事件处理句柄将会从根路径到这个已经改变的`addItemStream`组件来处理监测，一旦变化监测跑遍整个监测路径，它将会存储OnPush状态到整个组件树。这样做的好处是，变化监测系统将会走遍整棵树，你可以利用他们来监测树在局部是否有真正的改变，以此来做出相应的改变。变化检测到的路径是如下图5-2所标记的那样。
![](https://github.com/gf-rd/gf-Angular-book/blob/master/_images/chapters2-2/change-detect-3.png?raw=true)

图 5-2

#### 深入理解Zone（可选）
通过上一小节可以看到，每一个Zone的勾子统一服务于该Zone下面的所有回调函数。在实际开发中，可能需要对回调函数分门别类，对不同类别的回调函数采用不用的处理方式。于是Zone.js引入了子Zone的概念：一个Zone可以包含多个子Zone，每个子Zone都有其独立的勾子，从而不同类别的回调函数就可以添加到不同的子Zone中去。

##### 创建子Zone
每个子Zone都是通过调用zone.fork()方法来创建，是父类Zone的一个实例，每一个Zone都有一个唯标识符，同时还可以通过parent属性来寻找上一级Zone。`zone.run()`方法接收一个方法作为参数，在该方法内，可以给异步事件添加回调函数，从而这些回调函数会被该zone所识别和统一管理，所有的业务代码都在`run`方法中执行，该`childZone`获取到了该业务代码的执行上下文并能通过勾子函数处理一些异步操作，还是用上面的例子说明如下：

```js
  // root zone
  console.log(zone.$id, zone.isRootZone());  // 打印输出为：1 true
  // 子zone
  var childZone = zone.fork({
    beforeTask: () => {
        console.log('hi, beforeTask in.');
    },
    afterTask: () => {
        console.log('hi, afterTask in.');
    }
}).run(function () {
  zone.inTheZone = true;

  setTimeout(function () {
    console.log('in the zone: ' + !!zone.inTheZone);
  }, 0);
});
  console.log(childZone.$id, childZone.isRootZone());  // 打印输出为：2 false
  // 通过parent属性来寻找上一级zone
  console.log(childZone.parent === zone);  //true
```

##### Zone的继承关系
Zone的父子关系除了通过parent属性来建立外，还遵循了JavaScript的原型继承，父Zone是子Zone的原型，每一个子Zone都可以直接访问其祖先zone的属性和方法，如下例子很好的说明了它们的继承关系。

```js
console.log(zone.isPrototypeOf(zone.fork()));  //true
```

再通过下面的例子来理解Zone的简单继承关系

```js
  zone.enqueueTask = function(){
    console.log(this === zone);  // this和zone变量均指向childZone
    console.log("enqueueTask hook of root zone");
  };
  let childZone = zone.fork();
  childZone.run(function(){
    setTimeout(() => {}, 30);
  });
```
`childZone`没有定义`enqueueTask`勾子，因此在用`setTimeout`添加回调函数的时候，会沿着原型链向上寻找，这里其实是调用跟（root）zone的勾子。值得注意的是，虽然调用的是跟zone的勾子，但是this指向的仍然是`childZone`。但是如下面的例子中在`childZone`中定义上`enqueueTask`勾子函数，那么在原型链上最先找到的就是子Zone中定义的`enqueueTask`勾子函数。

```js
  let childZone = zone.fork({
    enqueueTask: () => {
      console.log("enqueueTask hook of child zone");
    }
  });
```

除了简单的继承和覆盖，Zone.js还允许父子Zone的同名方法协同工作。Zone.js规定Zone的每一个方法都可以有四种状态，还是以`enqueueTask`为例，［enqueueTask］为标准状态，［-enqueueTask］为前置状态，［+enqueueTask］为后置状态，［$enqueueTask］为追溯状态，每一个zone的每一个方法只能定义一种状态，通过［+, -］来表示先后关系，其执行顺序为：前置`->`标准`->`后置。

下面的例子给子zone定义了一个后置钩子，因此在添加回调函数时，父zone的标准钩子先执行，然后再执行子zone的后置钩子。

```js
  zone.enqueueTask = function(){
    console.log("enqueueTask hook of root zone");
  };
  let childZone = zone.fork({
    "+enqueueTask": () => {
      console.log("enqueueTask hook of child zone");
    }
  });
  childZone.run(() => {
    setTimeout(() => {});
  });
```
代码执行结果如下：

```
enqueueTask hook of root zone
enqueueTask hook of child zone
```

通过前面的介绍可以了解到，Zone.js以同样的接口，不同的方式实现并替换了一系列与事件相关的标准方法。因此，当开发者使用标准接口的时候，实际上会先调用Zone.js的替换方法，再由这些方法调用底层的标准方法，不过这一对开发者透明的设计，使得可以在引入Zone的功能的时候，不需要对原有代码做太大改动成为可能。

### 变化检测总结
- Angular2应用是一个是相应系统
- 变化检测系统是从根到叶的传播绑定
- 不像Angular1.x，变化监测图是一颗有向树，该系统使得性能表现更好和更可预测的
- 默认情况下，变化监测系统将会走遍整棵树，但是如果你使用不可变属性或者可观测对象，你可以利用他们来监测树在局部是否有真正的改变
- 这些优化组合不会扰乱提供的变化监测保障






