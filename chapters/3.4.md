### 9.4 项目实施
经过上一个小节，我们对项目进行了细致的需求分析。相信读者对该问卷系统要实现的功能有了比较清晰的认识。接下来，我们要开始正式的编码工作，使用Angular2实现整个问卷系统。在开始之前，我们需要介绍一下项目中使用到的相关技术或工具，以及如何进行项目配置和启动。然后我们对系统进行组件化的拆解、数据建模以及讲述每个页面和组件的开发。

#### 9.4.1 使用的技术
项目中使用到的相关技术如下：

 - angular2-seed
 
angular2-seed是一个angular2的脚手架。脚手架是基于某种技术搭建项目的基本代码骨架。脚手架本身不包含任何跟业务逻辑相关的代码，它只是一个构建项目的框架，但他基本上包含了所有具体应用中需要使用到的核心库或依赖。可以通俗的理解为动物的骨骼，在骨骼之上的肌肉就是我们需要编写的业务代码。angular2-seed为我们快速构建基于angular2的应用提供了极大的便利，免去了很多繁杂的初始化搭建工作。

angular2-seed提供了很多非常好的特性，其中有几项比较重要。由于我们使用TypeScript进行angular2开发（官方推荐），它使用gulp配合gulp-typescript插件进行自动编译。同时，也提供了开发模式和生产模式的两种环境构建。它还支持开发模式下的自动热加载，通过监听文件的变化，实现文件修改时自动重新加载页面，使我们在开发的时候的任何修改都能及时反映到页面上，不需要反复的进行页面刷新。angular2-seed还集成了Jasmine和Karma，同时还包含了单元测试代码覆盖率检测工具istanbul，我们只需要关心测试用例的编写。

angular2-seed使用也非常简单，只需要三步。

```javascript
//1. 从github上克隆angular2-seed到本地
git clone --depth 1 https://github.com/mgechev/angular2-seed.git

//2. 安装依赖包
cd angular2-seed
npm install

//3. 启动
//如果只想进行开发模式和生产模式的构建，只需要分别执行npm run build.dev和npm run build.prod即可
npm start



```

执行npm start后，浏览器会自动打开http://localhost:5555，表明angular2-seed安装成功。我们会基于此脚手架来完成问卷系统的开发。

 - angular2-bootstrap

可能大部分前端开发工程师都使用或者了解过bootstrap，它是Twitter推出的一款前端UI框架，使用bootstrap可以快速的开发漂亮的网页。angular2-bootstrap是一些angular2的指令集合，提供了类似bootstrap的漂亮的UI， 例如轮播图、警告框等。
 
 
 - json-server

json-server是一个简易的node server，用来模拟后端服务器。在真实的应用场景中，我们通常会使用express+mongodb或者php+mysql等来作为后端http服务，提供API与前端进行通信和数据持久化。但在本项目中，我们的重点是通过项目实例的方式介绍Angular2的应用，因此后端的开发我们尽量使用最简化的方式。json-server就是用来模拟server提供api服务的。它没有实际的数据库，采用纯json文本的方式保持数据，通过很少的代码就能搭建一个REST API server。关于json-server的具体用法，读者可以参考官方github上的文档，后面也会详细介绍在本项目中如何使用，这里展开介绍了。
 
 - rxjs

Rxjs即Reactive Extention for JavaScript。谈及Rxjs，我们首先需要介绍一下响应式编程（Reactive Programming）。
响应式编程不是某种具体的技术，而是一种编程范式，是一种对异步数据流进行编程的编程思维。在前端开发领域，异步事件是我们每时每刻都会接触到的东西，例如鼠标点击事件、页面load完成事件、Ajax请求完成事件等等。因为JavaScript是单线程语言，为了让页面在做数据处理的同时，能及时响应用户的操作，所以JavaScript采用了事件监听的方式来解决这个问题。而响应式编程就是基于这种想法的编程方式。从另外一个角度看，响应式编程是从**时间维度**对数据进行操作的编程方式。为了便于理解，我们可以拿数组作为对比。对数组我们可以进行很多操作，例如map、filter等等。在我们对数组进行上述操作时，数组的数据不会因时间操作时间的不同而不同。而响应式编程操作的对象是流（Stream），随着时间的推移，会不断的有新的数据从流中产生。流就是一个将要发生的以时间为序的事件序列。在响应式编程的世界中，一切都可以是流，或者被转换成流，而不仅仅是我们熟悉的鼠标点击事件等。一个事件发生往往伴随着数据（data）或错误（error）或完成信号（completed）的产生。我们只能异步捕获的这些事件，当有数据或错误或者完成信号产生时，分别执行不同的处理函数。熟悉设计模式的读者可能已经知道这是观察者模式。对异步事件的监听就是事件订阅（subscribe），我们定义的各种处理函数就是观察者（Observer），被订阅的流就是观察的主体（Observable）。
![鼠标点击事件流 3.4.1][3.4.1]

Rxjs是Reactive Programming的JavaScript实现。它提供了一系列的函数来对流进行操作，让一个或多个流（输入流）转换成另一个流（目标流）。目的就是为了方便我们对目标流的监听。以上图鼠标点击事件为例，如果页面上有个按钮，我们需要响应用户对按钮的点击事件，那么我们通常只需要注册按钮的click事件即可。

```javascript
var button = document.getElementById('button');
button.addEventListener('click', function(){
    console.log('click!!!');
}, true);
```

那如果我们现在需要响应的是按钮的双击事件呢？这时候问题就会变得稍微复杂了一点。当然，我们仍然可以使用注册dbclick的方式解决。但是假如原生并没有这个事件，我们自己该如何处理呢？

这里有几个问题需要考虑：
1、两次点击之间的事件间隔需要小于某个值（假如250ms）才认为是连续点击
2、对于连续三次或以上的点击，不应该响应

如果我们不使用Rxjs，解决这两个问题会变得比较复杂，至少我们需要计算并记录每两次点击事件发生的事件间隔，同时，在连续两次点击之后，还需要一个计时器判断是否有第三次点击发生，以及发生第三次点击时的时间间隔是否大于250ms。这个处理逻辑的复杂度可想而知。
使用Rxjs可以轻松的解决这个问题。使用Rxjs提供的buffer和throttle函数，可以将流中多个连续的间隔时间小于某个值的事件转换成一个列表数据流，然后再使用map函数，可以得到列表长度（也就是连续点击次数）的数据流，最后使用filter函数过滤列表长度为2的数据，得到一个新的数据流。这个就是我们需要监听的流。流的转换过程可以用下面的图来表示。

![单击流转换为双击流 3.4.2][3.4.2]

用代码表示可能看上去会简洁很多。
```javascript
var button = document.getElementById('button');
//将点击事件转换成点击流
var clickStream = Rx.Observable.fromEvent(button, 'click');
//将点击流转换成双击流（目标流）
var doubleClickStream = clickStream
    .buffer(function() {
        return clickStream.throttle(250);
    })
    .map(function(list) {
        return list.length;
    })
    .filter(function(x) {
        return x == 2;
    });

//对目标流监听处理
doubleClickStream.subscribe(function (event) {
    //TODO：双击处理逻辑
});

```
相信通过这个例子，读者已经认识到了Rxjs的强大之处。关于Rxjs的更多API用法，读者可以参考官方文档。

 - immutable.js

在JavaScript中，对象是可变的（mutable），因为数据使用引用赋值。例如一个赋值语句`var a = {num: 1}；`，`a`是一个指向对象`{num: 1}`的指针（引用）。如果此时我们将对象`a`再赋值给`b`，即`var b = a；`，然后修改`b.num = 2`，此时`a.num`的值也被修改为2了，因为`a`和`b`都是指向同一个对象的引用。这就是JavaScript原生对象的可变性，他的优点是可以避免代码执行过程中造成过多的中间对象而造成内存浪费。但他的缺点也很明显，当应用复杂后，我们并不能准确知道一个对象在一段代码执行前后是否保持不变，例如：
```javascript
var person = {
    name: '张三'，
    age: '23'
}；
doSomething(person);
//person对象还是原来的值吗？
console.log(person);
```

以上代码，在不清楚doSomething具体做了什么的时候，我们无从得知person对象是否被修改过，如果doSomething是一个第三方库的API，就更需要谨慎的对待person对象的值了。
jQuery提供了对象拷贝的API可以帮助解决这个问题，例如：
```javascript
var person1 = {
    name: '张三',
    age: '23'
};
var person2 = $.extend(true，{}, person1);

//person2是person1的副本，具有相同的值但不是同一个对象
console.log(person1);
console.log(person2);
console.log(person1 === person2); // false

```
jQuery的extend方法第一个参数可以是一个boolean值，表明是深拷贝（deepCopy）还是浅拷贝(shallowCopy)。如果为true，则深拷贝（person1中如果有元素为对象，也一并递归拷贝）。虽然对象拷贝可以解决问题，但他是一种性能较差的方式，因为他造成了CPU和内存的很大浪费。而immutable是解决此问题的一种更加优秀的方式。
immutable对象是一种一旦创建就不能再被修改的数据，对immutable对象的修改都会返回一个新的immutable对象。他采用了持久化数据结构（Persistent Data Structure），在使用旧数据创建新数据时，旧数据同样可用且不可变。同时，为了避免使用deepCopy带来的性能问题，他采用结构共享（Structural Sharing），即在immutable对象树的某个节点发生变化时，只修改这个节点和受其影响的父节点，来创建新的immutable对象，其他节点与原immutable对象共享。例如如下代码：
```javascript
import {Map} from 'immutable';
//创建一个immutable对象a，类型为map
let a = Map({
  category: 'users',
  list: Map({ name: 'james' })
})；

//修改a的category属性
let b = a.set('category', 'students');

//b是一个新的immutable对象
a === b; // false

//但a和b共享了没有被修改的list属性
a.get('list') === b.get('list'); // true

```

上面的例子可以帮助我们很容易的理解Structural Sharing。
通过上面的介绍，相信读者可以理解使用immutable对于降低mutable数据带来的复杂性和不确定性的重要意义。关于immutable.js的数据类型和数据操作等相关API，读者可以参考官方文档，这里不详细展开。

[3.4.1]: https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapters3/3.4.1.png
[3.4.2]: https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapters3/3.4.2.png

##### 9.4.2 配置 & 启动

- 环境配置：介绍基础的依赖，，后台的数据存储方式以及配置后台接口调用相关的知识。
- 启动步骤：分为前后台，后台启动步骤简单说明下json-server的启动方式，前台简单说明下gulp的使用，以及通过gulp启动前端代理服务器的方式等。

##### 9.4.3 组件拆解

- 根据上一节的产品设计，绘制项目的组件树。（组件树截图： 9-9）
- 通过组件树完成对项目各个模块组件的拆解，针对每个组件的功能做详细的说明。主要包括：

	- 根组件
	- 首页和帮助页组件
	- 问卷列表组件
	- 问卷组件
	- 问题组件
	- 用户管理组件
	- 问卷大纲组件
	- 问卷详情组件

##### 9.4.4 数据建模

本例中主要涉及到两类核心的数据模型，问卷模型和问题模型。在正式开始组件的开发之前，将首先介绍下它们包含的属性及属性的含义。

###### 问卷模型

问卷模型是描述一个调查问卷的基本数据结构，包含了问卷所有的核心要素。完整的数据结构定义如下：

	export interface QuestionnaireModel{
  	  id?:number;	//问卷ID
  	  title:string;	//问卷标题
   	  owner:number;	//作者ID
	  starter:string;	//开始问候语
  	  ending:string;	//结束问候语
	  state:QuestionnaireState;	//问卷状态
	  questionList: QuestionModel[];	//问题列表
	  createDate?:string;	//创建日期
 	}

 这里我们使用了接口去定义一个问卷模型，接下来将针对这些属性做逐一说明。

 id的类型是数值型，是问卷的唯一性标识，属性后?号标识在使用接口的时候，该属性是非必须的，因为在问卷的id是在问卷保存的时候由后台自动生成的，所以在创建问卷阶段问卷的id是未知的。

 owner是问卷作者的ID标识，可以根据该标识获取到问卷创建者的详细信息。

 state是指问卷当前所处的状态，QuestionnaireState是一个枚举类型，每个枚举项分别对应着问卷的创建状态、编辑状态、发布回收状态和完成状态。其中发布回收状态表示问卷已经对外发布，处于回收问卷填写信息阶段，完成状态表示问卷已经结束回收，调查通道也已关闭。问卷状态的定义如下：

	export const enum QuestionnaireState{
  	  Create,
	  Edit,
 	  Published,
  	  Finished
	}

 title、starter、ending以及创建时间都是简单的字符串类型，分别表示问卷的标题、开始问候语、结束问候语和问卷创建日期。

questionList是构成问卷的问题列表，是一个数组类型。每个数组元素对应一个问题，QuestionModel是问题的类型定义，接下来就针对此类型做详细说明。

###### 问题模型

问题是构建一个问卷的基础，问卷模型详细的描述了一个完整的问题所需的基本要素。问卷的数据结构定义如下：

	export interface QuestionModel{
  	  title:string;	//问题标题（描述）
  	  type:QuestionType;	//问题类型
  	  options?:any[];	//答案选项
  	  answer:any;	//问题答案
	}

和问卷模型类似，我们同样使用接口去定义一个问题模型。

title是问题的标题，类型是字符串类型，用来描述一个问题。

type属性标识问题的类型，或者可以说是问题控件的类型，这里使用了枚举类型QuestionType作为type的数据类型。目前程序支持的问题类型主要有文本题、单选题、多选题和分值题四类。QuestionType的枚举定义如下：

	export const enum QuestionType{
	  Text,
	  SingleSelect,
	  MultiSelect,
	  Score
	}

options属性对应着答案的选项，因为不是所有的问题都具备可选择的答案选项，所以该属性是一个可选属性。在我们的例子中，单选题和多选题都具有可选的答案选型，而文本题和分值题则无此属性。这里需要特别说明的是为了方便扩展，我们并没有为options属性设置特定的数据类型，而是使用了any关键字标识。
