### 9.4 用户管理功能
前面已经提到了，用户管理部分是系统最基础的功能之一，在很多系统中都是必不可少的一部分，具有一定的代表性。同时，用户管理涉及到的表单操作也是项目实战中很有代表性的功能之一。

从功能上来讲，用户管理可以用户注册、用户登录、管理员对用户的管理，其中管理员对用户的管理也是权限管理的一部分，与本书要讲的内容没有太大关联，在这里就不展开来讲了。下面将主要以用户注册来说明表单的结构、表单的校验等问题。

#### 表单控件组件
表单是处理用户输入最基础控件，常见的表单是包括 input textarea select 等，将表单抽象成一个个组件，既有利于统一页面的风格、也有利于提升开发效率，同时也能统一维护和扩展表单。一下是表单控件组件 `+field` 的目录结构：
```
.
├── field-base.ts
├── field-radio.ts
├── field-select.ts
├── field-text.ts
├── field-validators.ts
├── field.component.css
├── field.component.html
└── field.component.ts
```

从目录结构上来讲，`field-base.ts` 是表单的基础，在这里定义了，表单控件应该包含的属性：
```ts
value: T; // 取值，泛型
key: string; // 名称，唯一识别一个表单控件，字符串
label: string; // 标签，与 key 对应，字符串
required: boolean; // 是否必填，布尔值
pattern: string; // 检验规则，字符串
order: number; // 排序，数值
controlType: string; // 控件类型，字符串
```
以最常见的 input 标签为例:
```ts
import { FieldBase } from './field-base';
// 继承自 field-base
export class FieldText extends FieldBase<string> {
  controlType = 'text';
  // 在这里扩展了一个新的属性叫 type，取值包括 text、password 等
  type: string;

  constructor(options: any) {
    super(options);
    this.type = options['type'];
  }
}
```

示例当中还包含 `field-radio.ts` 和 `field-select.ts`，在这里就不贴代码说明了。

前面已经提到校验规则 `pattern`，事实上，只要是表单，或多或少都涉及到校验，校验包括前端校验和后台校验，这里所说的的校验都是指前端校验，前端校验的好处很明显： 一方面可以提升用户体验，让用户知道该输入什么，哪里输错了；另一方面可以减少无效的提交，并且提高提交的成功率。不管是用户体验还是成功率，校验都是必不可少的。一般说来，浏览器原生就会支持部分校验，比如 `required` 和 `maxlength`。不过，原生提供的校验一般都不能满足需求，为此，我们还需要自定义一些校验规则，以满足特定的需求，并且给出更友好的错误提示，这里的 `pattern` 就是用来指定校验规则的，自定义一个校验规则可参考 `field-validators.ts`：
```ts
import { FormControl } from '@angular/forms';
// 定义校验的正则表达式
const REG = {
  USERNAME: /^\w{1,20}$/,
  PASSWORD: /^\w{6,20}$/
};
// 定义校验结果的结构
interface ValidationResult {
  [key: string]: boolean;
}
export class FieldValidators {
  // 定义 username 校验规则
  public static username(control: FormControl): ValidationResult {
    if (control.value.length === 0) {
      return { empty: true };
    }
    if (REG.USERNAME.test(control.value)) {
      return null;
    }
    return { invalid: true };
  }
  // 定义 password 校验规则
  public static password(control: FormControl): ValidationResult {
    // ...
  }
}
```

再看看组件的定义 `field.component.ts`：
```ts
import { Component, Input } from '@angular/core';
import { FormGroup, REACTIVE_FORM_DIRECTIVES } from '@angular/forms';
import { FieldBase } from './field-base';

@Component({
  selector: 'field',
  // 组件对应的模版，模板的写法在第二章有详细介绍，这里就不展开来说了
  templateUrl: 'app/+field/field.component.html',
  // 组件对应的样式，样式的写法不是本书要讲的内容，这里就不展开来说了
  styleUrls: ['app/+field/field.component.css'],
  directives: [REACTIVE_FORM_DIRECTIVES]
});
export class FieldComponent {
  @Input() field: FieldBase<any>;
  @Input() form: FormGroup;
  // 通过 isValid 判断是否校验通过
  get isValid() {
    return this.form.controls[this.field.key].valid;
  }
  // 在这里对表单为空的时候做了特殊处理，因为在输入框为空的时候需要显示输入提示文本
  // 一般表单校验有三种状态：提示、正确、错误
  get isEmpty() {
    return this.form.controls[this.field.key].errors || {}['empty'];
  }
}
```

到这里定义表单控件已经讲完了，如果需要扩展一个新的控件，只需要定义一个新的类 `field-xxx`，并在 `field.component.html` 里根据模版语法编写模版即可。如果需要新增一个校验规则，只需要在 `field.validators.html` 里扩展一个新的方法即可。 

#### 用户注册组件
注册要解决如何在系统里面标识一个用户的问题，最简单也是最常用的办法就是让用户先注册，并提交部分身份信息。上一小节已经完成了表单控件的开发，接下来讲一下注册组件该如何开发。那么，首先来看一下注册 `+register` 组件的代码目录结构：
```
.
├── index.ts
├── register.component.css
├── register.component.html
├── register.component.ts
└── register.service.ts
```

整个组件是一个整体，这里分别讲一下各个文件的作用以及相互是怎么工作的。

+ register.service.ts
在这里定义一个用户对象，并在这里指定注册时要填写的信息，本例中只定义了用户名 `username` 和密码 `password`，需要指出的是，在不同系统里要求填写的信息可能不一样，考虑到找回密码的情况，一般还会要求填写邮箱等信息，但不管怎样，用户名（有的系统会把邮箱作为用户名）和密码都是必不可少的，这里为了简化问题没有加入邮箱填写，因为完整的邮箱注册还包括发送邮件验证邮箱正确性等步骤，而这些步骤跟本书要讲的内容没有直接关系。
```ts
class User {
  constructor(
    public username: string,
    public password: string
  ) { }
}
```

在 `Service` 里面，首先要指定接口和组件的控件，同时通过 `toFormGroup` 初始化 `FormGroup`，并设置响应的校验规则，需要指出的是，如果需要同时应用多个校验规则时，只需要在 `new FormControl` 时使用 `Validators.compose([...pattern])` 将多个规则作为参数传入：
```ts
@Injectable()
export class RegisterService {
  constructor(private http: Http) { }
  private add_user_url = 'http://localhost:8100/user/add';
  getFields() {
    let fields: FieldBase<any>[] = [
      // 用户名
      new FieldText({
        key: 'username',v
        label: '用户名',
        value: '',
        required: true,
        pattern: 'username',
        order: 1
      }),
      // ...
    ];
    // 通过 order 排序控件
    return fields.sort((a, b) => a.order - b.order);
  }
  // 初始化 FormGroup
  toFormGroup(fields: FieldBase<any>[]) {
    let group: any = {};
    fields.forEach(field => {
      group[field.key] =
        field.pattern ?
          new FormControl(field.value || '', FieldValidators[field.pattern]) :
          field.required ?
            new FormControl(field.value || '', Validators.required) :
            new FormControl(field.value || '');
    });
    return new FormGroup(group);
  }
  // 调用注册接口
  addUser(data: Object) {
    let body = JSON.stringify(data);
    let headers = new Headers();
    headers.append('Content-Type', 'application/json');
    return this.http
      .post(this.add_user_url, body, { headers });
  }
}
```

+ register.component.ts

这是组件的逻辑部分，参考：
```ts
// 引入上面定义的 Service
import { RegisterService } from './register.service';
// 定义一个 Component，并关联相应的模版和样式
@Component({
  selector: 'register',
  templateUrl: 'app/+register/register.component.html',
  styleUrls: ['app/+register/register.component.css'],
  directives: [FieldComponent, REACTIVE_FORM_DIRECTIVES],
  providers:  [RegisterService]
})
export class RegisterComponent implements OnInit {
  form: FormGroup;
  registered = false;
  fields: FieldBase<any>[] = [];
  constructor(private rs: RegisterService) {
    // 初始化组件的控件
    this.fields = rs.getFields();
  }
  ngOnInit() {
    // 使用控件初始化表单
    this.form = this.rs.toFormGroup(this.fields);
  }
  // 在这里定义一个现实密码的方法
  showPassword () {
    this.fields.forEach(field => {
      if (field.key === 'password') {
        field.type = field.type === 'password' ? 'text' : 'password';
      }
    });
  }
  // 提交注册
  register() {
    this.rs
      .addUser(this.form.value)
      .subscribe(res => {
        let body = res.json();
        if (body && body.success) {
          this.registered = true;
        }
      }, error => {
        console.error(error);
      });
  }
}
```
