#4 指令
在Angular2中，指令是一个重要的概念，它作用在特定的DOM元素上，可以扩展这个元素的功能，为元素增加新的行为。

在第二章节我们学习了组件的知识，本质上，我们可以将组件理解为一种带有视图的指令。组件从属于指令，是指令的一个子类，通常被用来构造UI控件。

本章节我们将聚焦在指令，学习指令在Angular2中的相关内容。

##4.1 指令概述
作为Web开发者的我们，对HTML都有基本的认识，让我们对HTML元素和HTML属性做一个简单的回顾。

* HTML文档

	HTML文档是一个纯文本文件，包含了页面的结构和由CSS定义的样式，以及JavaScript代码。

* HTML元素

	HTML文档是由HTML元素定义的。HTML元素指的是从开始标签到结束标签的所有代码，元素的内容是开始标签与结束标签之间的内容。


| 开始标签 | 元素内容   | 结束标签 |
| ------- | :----- | ------: |
| \<a href="default.htm"> | This is a link | \</a>|
		
		

* HTML属性

	属性为HTML元素提供附加信息。HTML标签可以拥有属性，属性提供了有关HTML元素的更多的信息。属性一般以名称/值对的形式出现，比如：name="value"，也可只设置名称。
	
我们知道，HTML超链接由`<a>`标签定义。链接的地址在`href`属性中指定：

```
<a href="http://www.google.com">Click me to go to Google</a>
```

超链接标签创建了从一个页面到另一个页面的链接，href属性好比超链接标签的参数，定义了链接的目标地址。当用户点击这个超链接时，浏览器地址栏的URL被修改为www.google.com并加载Google的首页。

上述行为的发生，依赖于浏览器在解析HTML文档时，可以正确理解HTML元素`<a>`标签的内容。浏览器遵循HTML标准，理解`<a>`标签声明了一个超链接，href属性值指定了链接的目标。

设想我们给`<a>`标签加上背景高亮效果，我们可以通过在标签中设置样式属性值实现这一效果

```
<a href="http://www.google.com" style="background-color:yellow">Click me to go to Google</a>
```

学习本章内容后，我们可以用指令实现上述效果。假设我们实现了一个背景高亮指令`HighlightDirective`，在超链接`<a>`标签中，我们可以这样使用

```
<a href="http://www.google.com" myHighlight>Click me to go to Google</a>
```

我们为`<a>`标签增加了一个属性`myHighlight`，通过这样的形式，来使用我们定义好的`HighlightDirective`指令。在这里我们还不打算深入`HighlightDirective`指令的完整实现，仅需了解它实现的效果，正是将HTML元素的背景色设置为高亮的颜色。

通过上述内容我们了解到，指令的使用并不复杂，它与我们使用HTML元素的属性方式一致。不同的是，HTML语法标准为HTML元素预定义了特定的属性，浏览器遵循这一语法标准，实现了这些属性的内置行为。语法标准预定义的属性是有限的、不可扩展的，而Angular2 中的指令是自定义的、可任意扩展的，本章让我们学习使用指令来扩展HTML元素的功能。


### 4.1.1 指令分类

在Angular2 中包含以下三种类型的指令：

1. 属性指令

	属性指令可以改变一个元素的外观和行为。以内置的指令`NgClass`为例，它们可以同时改变DOM元素的多个样式
	
	我们通常通过添加和删除CSS类来动态的控制DOM元素的样式，这里，我们可以使用内置的属性指令`NgClass`来同时的增加或删除多个CSS类。
	
	我们将`NgClass`指令绑定到一个key：value的对象，每一个key表示一个CSS类名，value值是true或false。value值为true时元素被添加这个CSS类，value值为false时类被移除。
	
	假设我们在组建方法中有一个控制CSS类的状态的方法`setClasses()`如下
	
	```
	setClasses(){
		let classes = {
			saveable: this.canSave,      // true
    		modified: !this.isUnchanged, // false
    		special: this.isSpecial,     // true
		}
		return classes;
	}
	```
	
	现在我们可以为`NgClass`属性绑定`setClass`调用并且以此来设置元素的CSS类
	
	```
	<div [ngClass]="setClasses()">This div is saveable and special</div>
	```
	
	这样我们就完成了使用`NgClass`属性指令来设置DOM元素多个CSS类的效果。

2. 结构指令

	结构指令可以通过增加或删除DOM元素、改变DOM的布局。`NgFor`和`NgIf`是两个常见的结构指令。
	
	我们可以给`NgIf`指令绑定一个变量，变量值为true时，该DOM元素及其子元素被添加至DOM中；变量值为false时，元素被从DOM中移除。
	
	```	
	<div *ngIf="trueOrFalseFlag">Text content here</div>

	```
	通过`NgIf`这一结构指令，根据绑定到指令上的变量值的不同，我们可以改变增加或删除DOM元素。
	
3. 组件

	组件本质上是一个带有模板的指令。它是三种指令中最常用的，通常被用来构造UI组件。
	
	一个最简单的组件示例可以如下所示
	
	```
	import { Component } from '@angular/core';
	
	@Component({
  		selector: 'my-app',
  		template: '<h1>My First Angular 2 App</h1>'
	})
	export class AppComponent { }

	```
	
	在`index.html`中，我们这样来使用这一组件
	
	```
	<body>
    	<my-app>Loading...</my-app>
  	</body>
	```
	我们构造了一个简单的组件，匹配`my-app`选择器，并以My First Angular 2 App 内容为模板输出，最终将原HTML代码替换为如下的代码片断：
	
	```
	<body>
    	<my-app>
    		<h1>My First Angular 2 App</h1>
		</my-app>
  	</body>
	```

	组件作为指令的一个子类，其部分生命周期方法与指令共有
		
	| 钩子方法 | 作用 |
| ------- | ------- |
| ngOnInit | 在Angular完成初始化输入属性的数据绑定后，初始化指令/组件 |
| ngOnChanges | 在Angular为输入属性设置一个数据绑定后响应，这个方法接收一个包含当前和之前数据的`changes`对象|
| ngDoCheck | 检查并执行那些Angular会检查或者自身不检查的变更，在每个变更检查执行期间被调用|
| ngOnDestroy |在Angular销毁zhil/组件之前执行清理工作。注销之前的观察并且解绑之前绑定的事件处理器以避免内存泄漏|

	
	
	与此同时，组件与指令也有下列一些差异:

	* ngAfterContentInit、ngAfterContentChecked、ngAfterViewInit、ngAfterViewChecked这四个生命周期方法是组件独有而指令没有的
	* 指令被用于为现有DOM元素增加行为;组件被用于创建新的经封装的视图控件
	* 我们使用@Directive修饰符注册指令;@Component修饰符注册组件
	* 指令不包含视图部分;组件必须包含视图部分
	* 一个DOM元素可以使用任意个指令;一个DOM元素只能表示一个组件		
	
### 4.1.2 集合指令概述
Angular 2为我们内置了各种指令，依据这些的指令的使用场景，Angular为我们提供了以下几个指令集合

1.	通用指令
	通用指令是在Angular应用中经常会用到的Angular核心指令集合，包括了核心指令（如`NgIf`,`NgFor`）和表单指令（如`NgModel`）。
	
	这一集合被用来在组件的`directives`属性中快速的枚举所有内置指令。
	
	不使用通用指令集合时，我们需要显示引入所有需要的指令
	
	
	```	
	import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, NgModel, NgForm} from 'angular2/common';
	import {OtherDirective} from './myDirectives';
	
	@Component({
		selector: 'my-component',
		templateUrl: 'myComponent.html',
		directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, NgModel, NgForm, OtherDirective]
	})
	export class MyComponent {
		...
	}
	
	```
 
 	通过使用通用指令集合，我们可以方便的一次引入所有的通用指令
 	
 	```
 	import {COMMON_DIRECTIVES} from 'angular2/common';
 	import {OtherDirective} from './myDirectives';
 	
 	@Component({
    	selector: 'my-component',
    	templateUrl: 'myComponent.html',
    	directives: [COMMON_DIRECTIVES, OtherDirective]
  	}) 
  	export class MyComponent {
 		...
 	}
  
 	```
 	
	
2.	核心指令
	与通用指令类似，核心指令也是在Angular应用中经常会用到的核心指令集合。这一集合被用来在`@Component`注解的 `directives`指令中快速的枚举所有内置的核心指令。
	
	不适用核心指令集合时，我们需要显示引入需要的核心指令
	
	```
	import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from 'angular2/common';
	import {OtherDirective} from './myDirectives';
	
	@Component({
    	selector: 'my-component',
    	templateUrl: 'myComponent.html',
    	directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]
  	})
  	export class MyComponent {
    	...
  	}
	```
	
	通过使用核心指令集合，我们可以方便的一次引入所有的核心指令
	
	```
	import {CORE_DIRECTIVES} from 'angular2/common';
 	import {OtherDirective} from './myDirectives';
 
  	@Component({
    	selector: 'my-component',
    	templateUrl: 'myComponent.html',
    	directives: [CORE_DIRECTIVES, OtherDirective]
  	})
  	export class MyComponent {
    	...
  	}
	```

	核心指令集合包含以下指令
	* `NgClass`指令
	
		`NgClass`指令根据条件表达式的结果为HTML元素增加或删除CSS类
		
		依据表达式结果的数据类型，表达式的结果被翻译为不同表现结果
		
		- `string`类型，字符串中所有列举的CSS类会被添加
		- `Array`类型，数组中所有CSS类会被添加
		- `Object`类型，每个key代表一个CSS类名，value的表达式被翻译为`Boolean`类型。如果表达式值为`true`则该CSS类被添加，否则该类被删除
		
		
		尽管`NgClass`指令可以将表达式结果范围为`string`,`Array`,`Object`,基于`Object`的方式是最常用的，并且具有将所有的CSS类名展示在模板中这一优点。
		
		`NgClass`语法如下
		
		```
		<div [ngClass]="{className-1: value1,..., classNameN: valueN}">...</div>
		```
				
			
	* `NgFor`指令
	
		`NgFor`指令在迭代过程中为每一个元素实例化一个模板。实例化的模板具有继承自外部的上下文，在迭代中这一上下文被设置了赋给当前元素的循环变量。
		
		`NgFor`指令提供了几个局部变量以供使用
		* `index`被设置给当前循环中每个模板上下文
		* `first`被设置给一个`boolean`变量以标示该元素是否是当前循环中的第一个元素
		* `last`被设置给一个`boolean`变量以标示该元素是否是当前循环中的第一个元素
		* `even`被设置给一个`boolean`变量以标示该元素是否是第偶数个元素
		* `odd`被设置给一个`boolean`变量以标示该元素是否是第奇数个元素
		
		`*ngFor`是`NgFor`指令的便捷语法糖，`NgFor`指令语法如下
		
		```
	<li *ngFor="#item of items; #i = index">...</li>
	<li template="ngFor #item of items; #i = index">...</li>
	<template ngFor #item [ngForOf]="items" #i="index"><li>...</li></template>
		```
	
	* `NgIf`指令
	
		`NgIf`指令根据表达式结果删除或重新创建DOM树中的特定部分。如果`NgIf`指令的表达式值为false,元素会被从DOM树中删除，否则这一元素的复制版本会被重新插入DOM树种。
	
		`*ngIf`是`NgIf`指令的便捷语法糖，`NgIf`指令语法如下	
	
		```
	<div *ngIf="condition">...</div>
 	<div template="ngIf condition">...</div>
 	<template [ngIf]="condition"><div>...</div></template>
		```
	* `NgTemplateOutlet`指令
		
		`NgTemplateOutlet`指令依据`TemplateRef`属性，在DOM树种创建并插入嵌入的视图。
	
		`NgTemplateOutlet`指令语法如下
	
		```
	<template [ngTemplateOutlet]="templateRefExpression"></template>
	```
	
	
	* `NgStyle`指令
	
		`NgStylte`指令根据表达式的计算结果更新元素的样式。`ngStyle`属性关联的表达式计算结果必须是一个对象，并且相应元素的样式根据这个对象的变更来被更新。对象的键是待更新的样式的名称，键对应的值是待更新样式的值。
		
		`NgStylte`指令语法如下
		
		```
	<div [ngStyle]="{'font-style': style}"></div>
 	<div [ngStyle]="styleExp"></div> //这里的`styleExp`必须是一个对象
		```
	
	* `NgSwitch`指令、`NgSwitchWhen`指令、`NgSwitchDefault`指令
	
		`NgSwitch`指令根据`switch表达式`计算的结果匹配哪一声明结果，在DOM树中插入元素。
		
		`NgSwitchWhen`指令在`switch表达式`计算结果和`ngSwitchWhen`表达式结果一致时将子树插入DOM树中。
		
		`NgSwitchDefault`指令作为默认声明，在没有`ngSwitchWhen`表达式匹配`switch表达式`计算结果时，被插入到DOM树中。
		
		我们定义一个外围元素，声明`NgSwitch`指令并为属性赋值一个表达式如`[ngSwitch]="..."`，在指令内部定义任意元素并且为元素设置`[ngSwitchWhen]`属性。
		
		`ngSwitchWhen`属性用来通知`NgSwitch`指令`switch表达式`匹配哪个元素。如果`switch表达式`计算结果，没有`ngSwitchWhen`属性被匹配，则设置为`ngSwitchDefault`属性的元素被默认展示。
		
		`*ngSwitchWhen`是`NgSwitchWhen`指令的便捷语法，而`*ngSwitchDefault`是`NgSwitchDefault`指令的便捷语法，`NgSwitch`指令示例如下
		
		```
		@Component({
 	   		selector: 'app',
 	   		template: `
 	   			<p>Value = {{value}}</p>
 	   			<button (click)="inc()">Increment</button>
 
 
      			<div [ngSwitch]="value">
        			<p *ngSwitchWhen="'init'">increment to start</p>
        			<p *ngSwitchWhen="0">0, increment again</p>
        			<p *ngSwitchWhen="1">1, increment again</p>
        			<p *ngSwitchWhen="2">2, stop incrementing</p>
        			<p *ngSwitchDefault>&gt; 2, STOP!</p>
      			</div>
 
      			<!-- alternate syntax -->
 
      			<p [ngSwitch]="value">
        			<template ngSwitchWhen="init">increment to start</template>
        			<template [ngSwitchWhen]="0">0, increment again</template>
        			<template [ngSwitchWhen]="1">1, increment again</template>
        			<template [ngSwitchWhen]="2">2, stop incrementing</template>
        			<template ngSwitchDefault>&gt; 2, STOP!</template>
      			</p>
    			`,
    		directives: [NgSwitch, NgSwitchWhen, NgSwitchDefault]
  		})
  		export class App {
    		value = 'init';
 
    		inc() {
      		this.value = this.value === 'init' ? 0 : this.value + 1;
    		}
  		}
 
  		bootstrap(App).catch(err => console.error(err));
		```
	
	
	* `NgPlural`指令、`NgPluralCase`指令
	
		`NgPlural`是一个国际化指令，指令首先以`switch表达式`去完全匹配`[ngPluralCase]`中表达式的值并展示DOM子树，匹配失败时，继续匹配`[ngPluralCase]`表达式的多元化类别。
		
		
		为了使用这个指令，我们需要提供一个`NgLocalization`的扩展来匹配类别名称，随后定义一个容器元素并为`[ngPlural]`属性设置一个`switch表达式`。

		* 内部元素定义一个`[ngPluralCase]`属性，根据表达式值决定显示与否
		* 如果`[ngPluralCase]`被设置为以`=`开始的值，需要`switch表达式`和该值完全匹配时才显示该元素
		* 否则，视图会被以“类别匹配”对待，在不存在完全匹配时，而且值与`getPluralCategory`方法提供的类别匹配时，显示该视图。
		
		
		如果`switch表达式`没有与之匹配的视图，则被标记为`[ngPluralCase]="other"`的内部元素会被显示。
		
		`NgPlural`指令使用示例如下
		
		
		```
			class MyLocalization extends NgLocalization {
     			getPluralCategory(value: any) {
        			if(value < 5) {
           				return 'few';
        			}
     			}
  			}
 
  			@Component({
     			selector: 'app',
     			providers: [provide(NgLocalization, {useClass: MyLocalization})]
  			})
  			@View({
    			template: `
      				<p>Value = {{value}}</p>
      				<button (click)="inc()">Increment</button>
 
      				<div [ngPlural]="value">
        				<template ngPluralCase="=0">there is nothing</template>
        				<template ngPluralCase="=1">there is one</template>
        				<template ngPluralCase="few">there are a few</template>
        				<template ngPluralCase="other">there is some number</template>
      				</div>
    					`,
    			directives: [NgPlural, NgPluralCase]
  			})
  			export class App {
    			value = 'init';
 
    			inc() {
      				this.value = this.value === 'init' ? 0 : this.value + 1;
    			}
  			}
		```
		
		
			
	
3.	表单指令

	表单指令是一个所有表单指令的集合，可以被作为快捷方式来引用全部的表单指令。
	
	```
 	@Component({
    	selector: 'my-app',
    	directives: [FORM_DIRECTIVES]
  	})
  	class MyApp {}
  	```
  
  	表单指令包含以下指令：
  	
  	* `NgControlName`指令
  		
  		`NgControlName`指令将命令绑定给DOM元素的特定的名字，其选择器为`[ngControl]`，只能作为`NgForm`或者`NgFormModel`的子命令使用。
  		
  		下面示例中，我们使用`[ngControl]`将`login`和`password`绑定到表单。
  		
  		```
  	@Component({
   		selector: "login-comp",
   		directives: [FORM_DIRECTIVES],
   		template: `
     		<form #f="ngForm" (submit)='onLogIn(f.value)'>
       			Login <input type='text' ngControl='login' #l="form">
       			<div ngIf="!l.valid">Login is invalid</div>

       			Password <input type='password' ngControl='password'>
       			<button type='submit'>Log in!</button>
     		</form>
   		`})
	class LoginComp {
		onLogIn(value): void {
	 	// value === {login: 'some login', password: 'some password'}
		}
	}
  		```
  	
  	* `NgFormControl`指令
  	
  		`NgFormControl`指令将已有的命令绑定到DOM元素
  		
  		下面示例中，我们将组件中声明的一个命令绑定给输入元素。输入元素的值改变时，命令的值相应改变；与此同时，指令的值改变时，输入元素的值也改变。
  		
  		```
  	@Component({
    	selector: 'my-app',
    	template: `
      		<div>
        		<h2>NgFormControl Example</h2>
        		<form>
          			<p>Element with existing control:
          			<input type="text"
  [ngFormControl]="loginControl"></p>
          			<p>Value of existing control: {{loginControl.value}}</p>
        		</form>
      		</div>
    		`,
    	directives: [CORE_DIRECTIVES, FORM_DIRECTIVES]
  	})
  	export class App {
    	loginControl: Control = new Control('');
  	}
  		```

  		
  	* `NgModel`指令
  	
  		`NgModel`指令将一个已有的领域模型对象绑定给一个表单命令，使用`[(ngModel)]`可以实现数据的双向绑定。
  		
  		使用示例如下
  		
  		```
  	@Component({
    	selector: "search-comp",
    	directives: [FORM_DIRECTIVES],
    	template: `
    		<input type='text' [(ngModel)]="searchQuery">`
       })
  	class SearchComp {
   		searchQuery: string;
  	}
  		```
  		
  	* `NgControlGroup`指令
  	
  		`NgControlGroup`指令讲一个命令集合绑定到DOM元素，只能作为`NgForm`或者`NgFormModel`的子命令使用。
  		
  		如下示例中,我们为用户的名字定义了一个命令集合，集合的值和验证状态也可以从表单中被分别获取到。
  		
  		```
  		  @Component({
    selector: 'my-app',
    directives: [FORM_DIRECTIVES],
    template: `
      <div>
        <h2>Angular Control & ControlGroup Example</h2>
        <form #f="ngForm">
          <div ngControlGroup="name" #cg-name="form">
            <h3>Enter your name:</h3>
            <p>First: <input ngControl="first" required></p>
            <p>Middle: <input ngControl="middle"></p>
            <p>Last: <input ngControl="last" required></p>
          </div>
          <h3>Name value:</h3>
          <pre>{{valueOf(cgName)}}</pre>
          <p>Name is {{cgName?.control?.valid ? "valid" : "invalid"}}</p>
          <h3>What's your favorite food?</h3>
          <p><input ngControl="food"></p>
          <h3>Form value</h3>
          <pre>{{valueOf(f)}}</pre>
        </form>
      </div>
    `
  })
  export class App {
    valueOf(cg: NgControlGroup): string {
      if (cg.control == null) {
        return null;
      }
      return JSON.stringify(cg.control.value, null, 2);
    }
  }
  ```
  		```
  		
  		
  	* `NgFormModel`指令
  	
  		`NgFormModel`指令将一个已有的命令集合绑定到DOM元素
  		
  		如下示例中，我们使用`ngFormModel`指令，将在组件中声明的命令集合绑定到表单元素上，然后我们将`login`和`password`命令绑定到`login`和`password`元素上。
  		
  		```
  	@Component({
  		selector: 'my-app',
    	template: `
    		<div>
        		<h2>NgFormModel Example</h2>
        		<form [ngFormModel]="loginForm">
          		<p>Login: <input type="text" ngControl="login"></p>
          		<p>Password: <input type="password" ngControl="password"></p>
        		</form>
        		<p>Value:</p>
        		<pre>{{value}}</pre>
      		</div>
    	  `,
    	directives: [FORM_DIRECTIVES]
  	})
  	export class App {
    	loginForm: ControlGroup;
    	constructor() {
      		this.loginForm = new ControlGroup({
        		login: new Control(""),
        		password: new Control("")
      		});
    	}
    	get value(): string {
      		return JSON.stringify(this.loginForm.value, null, 2);
    	}
  	}
  		```
  		
  	* `NgForm`指令
  	
  		当`NgForm`指令被绑定至组件中时，组件中的`<form>`元素将可以使用Angular表单指令。
  		
  		Angular表单是一系列带有继承关系的命令的集合。可以使用单个的命令，或者将命令组织在`ControlGroup`、`ControlArray`中使用。表单的`value`对象是一个JSON格式的对象，它可以反映表单结构。
  		
  		  	
  	* `DefaultValueAccessor`指令
  	
  		`DefaultValueAccessor`指令实现`ControlValueAccessor`接口，在`NgModel`、`NgFormControl`、`NgControlName`指令中被用作输入值和监听变更的默认访问器。
  		
  		示例如下
  		
  		```
  		<input type="text" ngControl="searchQuery">
  		``` 			
 
 
  		
  	* `CheckboxControlValueAccessor`指令
  	
  		`CheckboxControlValueAccessor`指令实现`ControlValueAccessor`接口，在复选框元素中被用作输入值和监听变更的访问器。
  		
  		示例如下
  		
  		```
  		<input type="checkbox" ngControl="rememberLogin">
  		```
  	
  	* `RadioControlValueAccessor`,`RadioButtonState`指令
  		
  		`RadioControlValueAccessor`指令实现`ControlValueAccessor`接口，在单选框元素中被用作输入值和监听变更的访问器。

		`RadioButtonState`指令为单选按钮提供的状态设置方法，通过`RadioButtonState`可以设置元素的选中状态和值。
  		
  		示例如下
  		
  		```
  		   @Component({
     template: `
       <input type="radio" name="food" [(ngModel)]="foodChicken">
       <input type="radio" name="food" [(ngModel)]="foodFish">
     `
   })
   class FoodCmp {
     foodChicken = new RadioButtonState(true, "chicken");
     foodFish = new RadioButtonState(false, "fish");
   }
  		```
  		
  		
  	* `NumberValueAccessor`指令
  	
  		`NumberValueAccessor`指令实现`ControlValueAccessor`接口，在数字类型输入元素中被用作输入值和监听变更的访问器。
  		
  		示例如下
  		
  		```
  		<input type="number" [(ngModel)]="age">
  		```
  		
  		
  	* `NgControlStatus`指令
  	
  		在Angular表单中，`NgControlStatus`指令根据命令状态（有效/失效/脏数据/等等）自动设置CSS样式。
  		
  		指令会为已触摸、未触摸、验证通过、验证失败、脏数据、原始状态这几个不同的状态，自动设置对应的样式类。
  	
  		
  		
  	* `SelectControlValueAccessor`,`NgSelectOption`指令
  			
  		`SelectControlValueAccessor`指令实现`ControlValueAccessor`接口，在选中类型输入元素中被用作输入值和监听变更的访问器。
  		
  		`NgSelectOption`指令动态的标记`<option>`，使得选择变更时，Angular可以被通知。
  		
  		示例如下
  		
  		```
  		<select ngControl="city">
  			<option *ngFor="let c of cities" [value]="c"></option>
  		</select>
  		```

  	* `RequiredValidator`,`MinLengthValidator`,`MaxLengthValidator`,`PatternValidator`指令
  	
  		`RequiredValidator`指令表单输入元素增加`required`约束。表单输入元素均使用`ngControl, `ngFormControl`或者`ngModel`，`RequiredValidator`指令为元素增加`required`属性。
  		
  		示例如下
  		
  		```
  		<input ngControl="fullName" required>
  		```
  		
  		`MinLengthValidator`指令为表单输入元素增加`minlength`约束。相应的，`MaxLengthValidator`指令增加`maxlength`约束。

  		示例如下
  		
  		```
  		<input ngControl="fullName" maxlength = "10" minlength = "3">
  		```
  		
  		`PatternValidator`指令给表单元素增加正则表达式约束，输入内容必须符合正则表达式定义的模式。
  		
		示例如下
  		
  		```
		<input type="text" ng-control="test" pattern="[a-zA-Z ]*">
  		```
  		
  	* `NgControl`
  	
  		`NgControl`指令是所有控制指令用以继承的基类，它在Angular表单中使用，用以将一个控制指令绑定到一个DOM元素上。
  		
  	* `ControlValueAccessor`
  	
  		`ControlValueAccessor`指令是一个命令和原生元素之间的桥接，它是一个接口，以输入命令形式抽象了将新值写入DOM元素的操作。  		
	
4.	平台指令

	在我们以往的使用中，为了使用某一指令，我们需要在组件的`directives`中定义引用。当我们需要在应用中无需定义即可自动获取使用某些指令时，可以使用平台指令的特性。
	
	平台指令是一个标识，可以在应用启动时，设置为一组指令，使得这些指令在应用的任意组件中可以使用。
	
	如下示例中，通过在`bootstrap`方法中为平台指令指定`OtherDirective`指令，在组件中无需再定义需要引用的指令即可直接使用。
	
	```
	import {PLATFORM_DIRECTIVES} from 'angular2/core';
  import {OtherDirective} from './myDirectives';
  @Component({
    selector: 'my-component',
    template: `
      <!-- can use other directive even though the component does not list it in `directives` -->
      <other-directive></other-directive>
    `
  })
  export class MyComponent {
    ...
  }
   bootstrap(MyComponent, [provide(PLATFORM_DIRECTIVES, {useValue: [OtherDirective], multi:true})]);
	```



5.	路由指令

	路由指令是一个指令集合，为了使用`RouterOutlet`,`RouterLink`这类路由指令，需要在组件中添加指令集合
	
	示例如下
	
	```
	import {Component} from 'angular2/core';
import {ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
@Component({directives: [ROUTER_DIRECTIVES]})
@RouteConfig([
 {...},
])
class AppCmp {
   // ...
}
bootstrap(AppCmp, [ROUTER_PROVIDERS]);
	```
	
	路由指令包含下列指令
	
	* `RouterLink`指令
	
		`RouterLink`指令可以让你链接到应用的特定部分。
		
		以下面路由配置为例
		
		```
  @Routes([
    { path: '/user', component: UserCmp }
  ]);
  class MyComp {}
		```
		
		当我们需要链接到`User`路由时，可以如下使用
		
		```
		<a [routerLink]="['/user']">link to user component</a>
		```
		
		`RouterLink`指令的值是一个数组，数组中元素是一个路径和该层级路由的参数。例如，`['/team', {teamId: 1}, 'user', {userId: 2}]`意味着我们想要构造一个`/team;teamId=1/user;userId=2`这样的链接。
		
		第一个路由片段名可以加上`/`, `./`或者 `../`这样的前缀。如果片段以`/`开始，路由会从当前应用的根路径查询目标地址。如果片段以`./`开始，或者没有以斜线做前缀，路由会从当前组件的子节点查询目标地址。如果片段以`../`开始，路由会跳转到当前路径的上一层。

	
	* `RouterOutlet`指令
		
		`RouterOutlet`指令是一个占位符，Angular会根据应用路径，使用当前路径匹配的组件填充它。
		
		指令使用方式如下
		
		```
		<!-- Routed views go here -->
		<router-outlet></router-outlet>
		```
	
		指令可以被命名
		
		```
		<router-outlet name="right"></router-outlet>
		```
		
	
## 4.2 属性指令


## 4.3 结构指令


## 本章总结

	



