## 7. 路由

### 7.1 概述

&emsp;&emsp;众所周知，理论上，URL能够定位到互联网上的任何资源。同理，对于一个web应用而言，使用URL，可以表示该应用的任意状态。比如当前所处页面，显示内容，搜索条件，操作历史，甚至可以细化到页面上每一个DOM节点的任何属性。不过所想表示的状态越多越细，相应的URL就会越长。虽然RFC2616并没有对URL的长度作出限制，但是在现实中，一般认为2000个字符以下的URL，才能够被大部分浏览器和服务器正确识别。因此，由于这个限制，使用URL并不能够表示web应用的每一个细节，通常也没有必要。

&emsp;&emsp;假设在一个简单的非单页应用中，每一个页面都做为一个单独的文件存在于服务器端，根据文件在服务器上的不同路径，每一个页面很自然地获得了一个与其对应的URL。在单页应用中，只存在一个主页面，通过Ajax请求向服务器获取不同的页面内容和数据，来对主页面进行更新，但自始至终，主页面在服务器端只有一个URL。如果想要让主页面的不同状态对应不同的URL，需要做到两点：第一，在主页面的内容发生改变时，能够在浏览器上生成相应的URL；第二，当在浏览器上输入任意状态的URL时，能够将相应的内容生成出来。路由这种机制，就是为了解决这两点而被设计出来的。

&emsp;&emsp;和其他主流前端框架一样，Angular2也实现了路由机制。在Angular2中，一个页面由一个或多个Component组合而成，不同的Component组合生成了不同的页面。因此可以给每一种Component组合指定相应的URL（数目不限），当浏览器上URL发生改变时，Angular2会捕捉到相应的事件，从而渲染出相应的页面。

### 7.2 路由的基本用法
下面先来简单介绍一下Angular2中关于路由的基本概念
* 路由指令

在第四章指令章节介绍过，路由指令是Angular2指令的一个分类，包含了router-outlet，routerLink，routerLinkActive这3个指令。路由指令可以统一使用集合ROUTER_DIRECTIVES进行加载：
```javascript
import { ROUTER_DIRECTIVES } from '@angular/router';
```

* 路由组件

模版中使用了router-outlet指令的组件，称为路由组件。路由组件的作用是根据不同的URL，将不同的子组件显示出来。因此，需要为路由组件建立URL和子组件之间的对应关系。

* 路由定义

路由定义的最基本功能是建立URL和子组件之间的对应关系。一个URL模式只能对应一个子组件，但一个子组件可以对应多个URL模式。

* 路由配置

所有的路由定义构成了路由配置，用于初始化路由服务。

### 7.3 路由的基本用法
在Angular中使用路由的功能，有3个最为基本的步骤：注入路由服务，定义路由组件和子组件，定义路由配置。本小节将从一个没有任何路由的页面开始，演示如何完成这几个步骤。并将以此为基础，在接下来的各小节中深入阐述路由的其它功能。

main.ts
```javascript
import { bootstrap }    from '@angular/platform-browser-dynamic';
import { AppComponent } from './app.component';
bootstrap(AppComponent);
```
app.component.ts
```javascript
import { Component } from '@angular/core';

@Component({
  selector: 'my-app',
  template: '<h1>Master Page</h1>'
})
export class AppComponent {}
```


#### 注入路由服务
Angular提供的所有路由服务，都封装在一个独立的模块@angular/router中。如果一个Angular应用需要使用路由服务，则必须对此模块进行加载；反之，则可以不加载。下面的例子，在完成路由模块的加载后，首先使用RouterConfig定义一个数组作为路由配置（由于当前还没有进行任何路由定义，因此该数组为空）；然后以该路由配置为参数，调用provideRouter方法来获取angular提供的一系列默认路由服务（包括PathLocationStrategy，DefaultUrlSerializer等）；并通过bootstrap方法对各默认服务依次进行注入。

main.ts
```javascript
import { bootstrap }    from '@angular/platform-browser-dynamic';
import { AppComponent } from './app.component';
import { provideRouter, RouterConfig } from '@angular/router';

const router: RouterConfig = [];
bootstrap(AppComponent, [provideRouter(router)]);
```

通过调用provideRouter方法所获取的angular默认路由服务中，包含了默认的路由策略PathLocationStrategy。使用该策略的应用，需要为其定义一个base路径，用于作为前缀来生成和解析URL（路由策略的详细内容将会在某小节中提到，在此先行略过）。Angular提供了两种方式来对base路径进行设置：
第一种是在html页面中设置base元素的href属性（值得提出的是，根据HTML标准的定义，如果设置了元素的href属性，则该页面中所有的相对路径都将基于该属性来解析）。

index.html
```html
<head>
  <title></title>
  <!--base路径为http://localhost/-->
  <base href="/">
  <!--相对于base路径，解析为http://localhost/styles.css-->
  <link rel="stylesheet" href="styles.css">
</head>
```

第二种是直接向变量APP_BASE_HREF注入。

main.ts
```javascript
import {APP_BASE_HREF} from '@angular/common';

bootstrap(AppComponent, [provideRouter(router), {provide: APP_BASE_HREF, useValue: '/'}]);
```
当两种方式同时使用的时候，第二种具有更高优先级。


#### 定义路由组件和子组件
Angular将模版中使用了router-outlet指令的组件，称为路由组件。router-outlet指令的作用相当于一个占位节点，在模版中开辟出一块区域，每个路由定义所对应的组件都将在这个区域内显示出来。一个路由组件有且只能有一个主outlet，同时可以有任意多个从outlet。下面的例子先考虑最简单的情况：只有一个主outlet。

app.component.ts
```javascript
import { Component } from '@angular/core';
import { ROUTER_DIRECTIVES } from '@angular/router';

@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
export class AppComponent{}
```

接下来再定义两个子组件ComponentA和ComponentB。希望达到的效果是，当URL为http://localhost/component-a时在路由组件中显示ComponentA，当URL为http://localhost/component-b时则显示ComponentB。为了达到这个效果，还需要进行路由配置。

a.component.ts
```javascript
import { Component } from '@angular/core';

@Component({
  selector: 'component-a',
  template: '<div>Component A</div>'
})
export class ComponentA {}
```

b.components.ts
```javascript
import { Component } from '@angular/core';

@Component({
  selector: 'component-b',
  template: '<div>Component B</div>'
})
export class ComponentB {}
```

#### 定义路由配置
前面介绍过，路由配置可以包含任意多个路由定义。在注入路由服务的步骤中，已经定义了一个空数组作为路由配置，现在需要做的是往该空数组添加路由定义。路由定义最基本的作用是将URL模式和子组件关联起来，所以一个最简单的路由定义，包含了path和component两个属性，分别表示URL模式和子组件。本例中的路由配置包含了3个路由定义。此时在浏览器中输入各自的URL，及可以看到对应的子组件被显示出来。

main.ts
```javascript
//...
import { ComponentA } from './a.component';
import { ComponentB } from './b.component';

const router: RouterConfig = [
  { path: '', component: ComponentA },  /* http://localhost */
  { path: 'component-a', component: ComponentA },  /* http://localhost/component-a */
  { path: 'component-b', component: ComponentB }  /* http://localhost/component-b */
];
//...
```

比如，对于http://localhost/component-a，最终生成的HTML代码为
```html
<my-app>
  <h1>Master Page</h1>
  <router-outlet></router-outlet>
  <component-a>
    <div>Component A</div>
  </component-a>
</my-app>
```

值得一提的是，不同的URL可以指向同一个Component。因此对于下面的定义，两个URL都将使ComponentA被显示出来。
```javascript
const router: RouterConfig = [
  { path: 'component-a', component: ComponentA },
  { path: 'component-b', component: ComponentA }
];
```
如果同一个URL模式被多次定义，则以第一次定义为最高优先级，其后的定义不会将其覆盖。下面的定义，对于URL http://localhost/component-a，将会显示ComponentA而不是ComponentB。
```javascript
const router: RouterConfig = [
  { path: 'component-a', component: ComponentA },
  { path: 'component-a', component: ComponentB }
];
```

除了使用path和component属性来定义路由外，另外一种比较常见的方式是使用path和redirectTo属性，将一个URL模式重定向到另外一个URL模式上。在例子中，如果将第一条路由定义改成下面的形式，那当用户在浏览器上输入http://localhost后，URL将会自动变为http://localhost/component-b,并且将ComponentB显示出来。
```javascript
{ path: '', redirectTo: 'component-b' }
```

### 7.4 子路由和从outlet

#### 子路由
所谓子路由，简而言之，就是子组件也是一个路由组件的情形。接下来定义一个路由组件ComponentC做为AppComponent的子组件，然后再定义两个组件ComponentC1和ComponentC2做为ComponentC的子组件。

c.component.ts
```javascript
import { Component } from '@angular/core';
import { ROUTER_DIRECTIVES } from '@angular/router';

@Component({
  selector: 'component-c',
  template: `
    <div>子路由组件</div>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
export class ComponentC {}
```

c1.component.ts
```javascript
import { Component } from '@angular/core';

@Component({
  selector: 'component-c1',
  template: `<div>Component C1</div>`
})
export class ComponentC1 {}
```

c2.component.ts
```javascript
import { Component } from '@angular/core';

@Component({
  selector: 'component-c2',
  template: `<div>Component C2</div>`
})
export class ComponentC2 {}
```

在路由定义中，使用children属性来给ComponentC定义子路由。
```javascript
//...
import { ComponentC } from './c.component';
import { ComponentC1 } from './c1.component';
import { ComponentC2 } from './c2.component';

const router: RouterConfig = [
  //...
  {
    path: 'component-c', component: ComponentC, children: [
      { path: 'c1', component: ComponentC1 },  /* http://localhost/component-c/c1 */
      { path: 'c2', component: ComponentC2 }  /* http://localhost/component-c/c2 */
    ]
  }
];
//...
```

此时，便可以使用定义的URL将对应的组件显示出来。比如http://localhost/component-c/c1会显示ComponentC和ComponentC1：
```html
<my-app>
    <h1>Master Page</h1>
    <router-outlet></router-outlet>
    <component-c>
      <div>子路由组件</div>
      <router-outlet></router-outlet>
      <component-c1>
        <div>Component C1</div>
      </component-c1>
    </component-c>
</my-app>
```

#### 从outlet
上一小节提到过，对于一个路由组件来说，除了必须拥有一个主outlet之外，还可以有任意多个从outlet （Auxiliary Route），从而使得一个路由组件可以同时显示多个相互独立的子组件。从outlet同样使用<router-outlet>指令来定义，与主outlet的不同之处在于必须对从outlet进行命名。下面的代码展示了如何在根组件中添加了两个从outlet。

app.component.ts
```javascript
@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <router-outlet></router-outlet>
    <router-outlet name="aux1"></router-outlet>
    <router-outlet name="aux2"></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
```
下面再添加两个路由定义，分别表示当从outlet aux1上的URL模式为c1时，在从outlet上显示ComponentC1;当从outlet aux2上的URL模式为c2时，在从outlet上显示ComponentC2。
main.ts
```javascript
const router: RouterConfig = [
  //...
  { path: 'c1', component: ComponentC1, outlet: 'aux1'},
  { path: 'c2', component: ComponentC2, outlet: 'aux2'}
];
```
如果想在主页面上同时显示ComponentA，ComponentC1, ComponentC2，可以使用如下的URL。
```
http://localhost/component-a(aux1:c1//aux2:c2)
```
对应生成的HTML代码为
```html
<my-app>
  <h1>Master Page</h1>
  <router-outlet></router-outlet>
    <component-a>
    <div>Component A</div>
    </component-a>
  <router-outlet name="aux1"></router-outlet>
  <component-c1>
    <div>Component C1</div>
  </component-c1>
  <router-outlet name="aux2"></router-outlet>
  <component-c2>
    <div>Component C2</div>
  </component-c2>
</my-app>
```
如果只想显示ComponentA，ComponentC1，相应的URL则为
```
http://localhost/component-a(aux1:c1)
```

#### 在子路由中使用从outlet

c.component.ts
```javascript
@Component({
  selector: 'component-c',
  template: `
    <div>子路由组件</div>
    <router-outlet></router-outlet>
    <router-outlet name="aux1"></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
```

main.ts
```javascript
const router: RouterConfig = [
  {
    path: 'component-c', component: ComponentC, children: [
      { path: 'c1', component: ComponentC1, outlet: 'aux1'}
    ]
  }
];
```

下面的URL，将显示ComponentC，ComponentC1，ComponentC2:
```
http://localhost/component-c/(c2//aux1:c1)
```

#### 在从outlet中使用子路由

添加如下路由定义
main.ts
```javascript
const router: RouterConfig = [
  //...
  {
    path: 'c', outlet: 'aux1', component: ComponentC, children: [
      { path: 'c1', component: ComponentC1 },
      { path: 'c2', component: ComponentC2 }
    ]
  }
  //...
];
```
再使用如下URL，即可在从outlet aux1上显示ComponentC及ComponentC1
```
http://localhost/component-a(aux1:c/c1)
```


### 7.5 页面跳转
前面两个小节的例子，都是通过直接在浏览器上输入URL来显示对应的页面；而在日常生活中，用户更多地是通过点击页面上的超链接来从一个页面跳转到另外一个页面，从一个网站跳转到另外一个网站。页面跳转最为常见的实现方式是使用HTML的锚点元素<a>来创建超链接，Angular不仅支持这种方式，还专为为<a>提供了routerLink指令，对<a>的行为进行优化。此外，Angular还提供了接口，可以在不使用超链接的情况下，进行动态跳转。本小姐将对这两种方式加以介绍，希望大家喜欢～

#### 超链接跳转
下面的例子，在主页面上添加两个超链接：第一个超链接使用了相对路径component-a，由于在7.3小节将index.html的base路径设置为了当前目录，因此该超链接的最终指向为http://localhost/component-a。第二个由于使用变量替换，其指向会随着变量path值的改变而改变（比如在页面加载完毕时，其指向component-a；当点击了“更改路由”按钮后，将会改为指向component-a）。

app.component.ts
```javascript
import { Component } from '@angular/core';
import { ROUTER_DIRECTIVES } from '@angular/router';

@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <div>
      <a href="/component-a">Component A</a>  <!-- http://localhost/component-a -->
      <a href="{{path}}">Component B</a>  <!-- http://localhost/? -->
      <button (click)="path = '/component-a'">更改路由</button>
    </div>
    <router-outlet></router-outlet>
    <router-outlet name="aux1"></router-outlet>
    <router-outlet name="aux2"></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})

export class AppComponent{
  path = '/component-b';
}
```

一个值得提出的地方是，在点击超链接之后，浏览器都会给后台服务器发一个请求，从而整个app会被重新加载一遍。虽然说加载完成后，路由所对应的相关组件也会被正确地显示出来，但这种加载是完全可以避免的，因为这些组件早已经在启动文件main.ts中被加载了进来：
```javascript
import { ComponentA } from './a.component';
import { ComponentB } from './b.component';
import { ComponentC } from './c.component';
import { ComponentC1 } from './c1.component';
import { ComponentC2 } from './c2.component';
```
Angular为<a>元素特别定制的routerLink指令，就是用来解决这个问题的。下面的代码用routerLink指令代替了href属性来创建超链接。此时点击超链接来进行页面跳转，将不会触发重新加载。

app.component.ts
```javascript
@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <div>
      <a [routerLink]="['/component-a']">Component A</a>
      <a [routerLink]="[path]">Component B</a>
      <button (click)="path = '/component-a'">更改路由</button>
    </div>
    <router-outlet></router-outlet>
    <router-outlet name="aux1"></router-outlet>
    <router-outlet name="aux2"></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
```
这两个<a>元素经Angular编译后的代码如下。可以看出，Angular会根据routerLink指令的值来为<a>生成相应的href属性。但令人遗憾的是，生成的属性不具备变量替换的功能，因此对于第二个超链接来说，点击了“更改路由”按钮后，其指向并不会发生改变...
```html
<a ng-reflect-router-link="/component-a" ng-reflect-href="/component-a" href="/component-a">Component A</a>
<a ng-reflect-router-link="/component-b" ng-reflect-href="/component-b" href="/component-b">Component B</a>
```

#### 自动跳转（动态跳转？帮忙想个名字）
超链接跳转一般是用户手动来触发的（在此不考虑通过JavaScript模拟点击事件的情况）。除此之外，还存在需要自动进行跳转的情况，比如用户在一定时间内无任何操作则自动退出登录。Angular提供了两个接口来进行自动跳转：Router.navigate和Router.navigateByUrl。下面的例子，实现了在进入主页面1秒钟后，自动跳转到路由component-b的效果。

app.component.ts
```javascript
import { ROUTER_DIRECTIVES, Router } from '@angular/router';
//...
export class AppComponent{
  //...
  constructor(private router: Router) {
    setTimeout(()=>{
      router.navigate(['/component-b']);
      //router.navigateByUrl('/component-b');
    }, 1000);
  }
}
```
通过分析源代码可知，这两个方法对于跳转的处理方式完全一致，只是各自接收的参数不同。具体说来，Router.navigateByUrl接收的参数是URL字符串；而Router.navigate接收的参数是一系列命令（commands参数)和配置（extras参数），Angular会根据这些命令和配置生成一个相应的URL，再进行跳转。下面是使用Router.navigate进行子路由跳转的例子：
```javascript
router.navigate(['/component-c', 'c1']);
//router.navigateByUrl('/component-c/c1');
```
笔者目前仍未找到进行从outlet跳转的方法...

### 7.6 路由拦截
在路由跳转中，从离开当前路由到进入下一个路由的过程中，会经过Angular2设定的一系列的钩子函数。这些钩子函数的作用相当于把跳转拦截下来，并对其进行各类检查校验，只有满足钩子函数设定的条件的跳转才予以放行。只有满足了所有的拦截钩子的跳转，才能够成功地进入下一个路由。

#### CanActivate
Angular 2提供了CanActivate接口。该接口只定义了一个方法canActivate()。当该方法返回true或者Observable<true>时，表示准许进入下一路由；反之，当返回false或者Observable<false>时，则继续停留在当前路由。下面的代码实现了一个最简单的拦截服务，直接对路由跳转放行。
CanActivateGuard.ts
```javascript
import { CanActivate } from '@angular/router';

export class CanActivateGuard implements CanActivate {
  canActivate() {
    console.log('CanActivate拦截!');
    return true;
  }
}
```

实现该接口的类，均可以通过依赖注入的方式注册到CanActivate钩子上。下面对app.routes.ts的代码稍作修改，将CanActivateGuard服务添加到路由定义上，并注入到app中。
app.routes.ts
```javascript
...
import { CanActivateGuard } from './CanActivateGuard';

export const routes: RouterConfig = [
  ...
  { path: 'component-b', component: ComponentB, canActivate: [CanActivateGuard] }
];

export const APP_ROUTER_PROVIDERS = [
  provideRouter(routes),
  [CanActivateGuard]
];
```

当能否进入下一个路由是根据异步操作的结果来决定时，那么CanActivate()方法就应该返回一个Observable<boolean>类型的实例，并且将异步操作放在该实例中执行。该实例可以对异步操作的结果加以分析判断，如果结果符合设定的条件，则发布一个true的消息，告知Angular2准许进入下一个路由；反之则发布一个false的消息，停留在当前路由。

下面的代码，在进入ComponentB之前，会出现一个弹窗让用户进行确认。我们将弹窗这个异步操作写进了Observable的实例中，并且直接将其结果通过observer.next()方法进行发布（注意，window.confirm()方法的返回值就是boolean类型，所以可以直接发布；对于返回值非boolean类型的异步操作，需要将其结果根据具体业务逻辑转化为boolean类型）。 
CanActivateGuard.ts
```javascript
import { CanActivate } from '@angular/router';
import { Observable } from 'rxjs/Observable';

export class CanActivateGuard implements CanActivate {
  canActivate() {
    return new Observable<boolean>(observer => {
      let result = window.confirm('是否确定进入ComponentB？');
      observer.next(result);
      observer.complete();
    });
  }
}
```

除了进入下一路由和停留在当前路由，路由拦截还允许跳转到另外的路由。
CanActivateGuard.ts
```javascript
import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';

@Injectable()
export class CanActivateGuard implements CanActivate {
  constructor(private router: Router){}

  canActivate() {
    this.router.navigate(['']);
  }
}
```

#### CanDeactivate
在通过了下一个路由的CanActivate拦截后，接下来会进入当前路由的CanDeactivate拦截，用于确定是否可以离开当前路由。同样，Angular 2提供了CanDeactivate接口。该接口只定义了一个方法canDeactivate()。当该方法返回true或者Observable<true>时，表示准许离开当前路由；反之，当返回false或者Observable<false>时，则继续停留在当前路由。下面的代码实现了一个最简单的拦截服务，直接对路由跳转放行。

与CanActivate的例子相似，下面的例子定义了一个CanDeactivate服务，将其添加到响应的路由定义上，并注入到app中。
CanDeactivateGuard.ts
```javascript
import { CanDeactivate } from '@angular/router';
import { Observable } from 'rxjs/Observable';

export class CanDeactivateGuard implements CanDeactivate<any> {
  canDeactivate() {
    return new Observable<boolean>(observer => {
      let result = window.confirm('是否确定离开ComponentA？');
      observer.next(result);
      observer.complete();
    });
  }
}
```
app.routes.ts
```javascript
...
import { CanDeactivateGuard } from './CanDeactivateGuard';

export const routes: RouterConfig = [
  ...
  { path: 'component-a', component: ComponentA, canDeactivate: [CanDeactivateGuard] },
  ...
];

export const APP_ROUTER_PROVIDERS = [
  ...
  [CanDeactivateGuard]
];
```

### 7.7 路由参数
到目前为止，已经实现了一个简单的路由，即可以通过静态URL将其对应的Component显示出来。但是对于动态页面而言，Component的内容不是固定不变的，因此URL除了需要指定显示哪个Component之外，还需要向Component传递参数，使其根据参数来生成所要显示的具体内容。

#### 路由参数
##### 定义
路由参数通过路由定义中的path属性来定义。在解析path属性的时候，Angular2会以／为分隔符对path属性进行分段，如果一个分段以:开头，则该分段表示路由参数。下面的例子，新添加了一条路由，包含了一个名为framework的参数。
app.routes.ts
```javascript
export const routes: RouterConfig = [
  { path: '', component: ComponentA },
  { path: 'component-a', component: ComponentA },
  { path: 'component-b', component: ComponentB },
  { path: 'component-b/:framework', component: ComponentB }
];
```

在进行路由匹配的时候，要求URL解析出来的分段数必须和path属性的分段数一致，否则将匹配不到。比如，http://localhost/component-b/Angular2 可以匹配到第4条路由，路由参 framework的值为"Angular2"。http://localhost/component-b和http://localhost/component-b/Angular2/xxx 则匹配不到该路由。

上面的例子，对路由参数的赋值，是通过在URL的对应分段上直接输入参数值来完成的。除此之外，还可以通过routerLink指令或者Router.navigate()方法来给路由参数赋值。
```
<a [routerLink]="['/component-b', 'Angular2']">Component A</a>
this.router.navigate(['/component-b', 'Angular2']);
```

##### 获取参数
在将URL匹配到对应的路由定义后，Angular2会生成一个路由快照，该快照包含了该次路由匹配的相关信息（包括URL，路由定义，以及从URL解析出来的路由参数等）。该快照可以通过ActivatedRoute服务的snapshot属性来访问。

为了更好地展示快照的行为，现在对主页面稍作修改，添加3个链接。第一个链接不带有任何参数，指向路由{ path: 'component-a', component: ComponentA }。第二和第三个链接各自带有不同的参数，指向同一个路由{ path: 'component-b/:framework', component: ComponentB }。
app.component.ts
```javascript
import { Component } from '@angular/core';
import { ROUTER_DIRECTIVES, Router } from '@angular/router';

@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <nav>
      <a [routerLink]="['/component-a']">Component A</a>
      <a [routerLink]="['/component-b', 'Angular1']">Component B1</a>
      <a [routerLink]="['/component-b', 'Angular2']">Component B2</a>
    </nav>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
export class AppComponent {}
```

接下来，在ComponentA和ComponentB的构造函数中注入ActivatedRoute服务，便可以通过其snapshot属性获取framework参数。依次点击主页面上的三个链接，便可以看到每条路由对应的参数在页面上显示出来（第一条路由没有参数，故页面上没有显示）。
a.component.ts
```javascript
import { Component } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  template: `
    <div>Component A</div>
    <div>路由参数: {{route.snapshot.params['framework']}}</div>
  `
})
export class ComponentA{
  constructor(private route: ActivatedRoute) {
    console.log('创建ComponentA实例!');
  }
}
```
b.component.ts
```javascript
import { Component } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  template: `
    <div>Component B</div>
    <div>路由参数: {{route.snapshot.params['framework']}}</div>
  `
})
export class ComponentB{
  constructor(private route: ActivatedRoute) {
    console.log('创建ComponentB实例!');
  }
}
```

从上面的例子还可以看出，如果从一条路由跳转到另外一条路由，Angular2会为新路由的Component重新创建一个实例；如果是在同一条路由内发生跳转，则不会重新创建实例。比如，在Component B1和Component B2两个链接之间相互跳转时，仅仅是URL上的路由参数发生了变化，两个URL依然指向同一个路由定义，此时两个URL共用同一个ComponentB的实例。这样的设计，避免了重新渲染ComponentB的模版所可能引起的页面闪烁。

此外，在实际开发中，通常需要执行特定的业务逻辑来对路由参数的变化做出响应。比如在上面的例子中，想实现一个功能，当路由参数的值为"Angular2"时，出现一个弹窗。如果是在不同路由间跳转（比如从链接Component A跳转到链接Component B2），由于会为ComponentB生成一个新实例，所以这段逻辑可以写在ComponentB的构造函数中：
b.component.ts
```javascript
export class ComponentB{
  constructor(private route: ActivatedRoute) {
    console.log('创建ComponentB');

    if(route.snapshot.params['framework'] === 'Angular2'){
      window.alert('你好，Angular2!');
    }
  }
}
```
但以上方法并不适用于在同一个路由间跳转的情况，因为ComponentB的构造函数不会被再次调用。为了解决这个问题，ActivatedRoute服务为路由参数提供了一个Observable对象，当路由参数发生改变时，该对象便可以通知其subscriber。
b.component.ts
```javascript
import { Component, OnInit, OnDestroy } from '@angular/core';
...
export class ComponentB implements OnInit, OnDestroy {
  private routeParams: any;

  constructor(private route: ActivatedRoute) {
    console.log('创建ComponentB');
  }

  ngOnInit() {
    this.routeParams = this.route.params.subscribe(params => {
      if(params['framework'] === 'Angular2'){
        window.alert('你好，Angular2!');
      }
    });
  }

  ngOnDestroy() {
    this.routeParams.unsubscribe();
  }
}
```

#### 查询参数
##### 定义
除了路由参数外，Angular2还允许通过URL查询字符串来传递查询参数。与路由参数不同的是，查询参数并不参与路由匹配。因此，可以给任意路由传递任意数目的查询参数。下面是一个包含查询字符串（?framework=Angular&version=2）的URL。该字符串定义了framework和version两个参数，其值分别为Angular和2；参数之间以&字符分隔。访问该链接的结果和访问http://localhost/component-a一样，都是将ComponentA显示出来。
```
http://localhost/component-a?framework=Angular&version=2
```
除了在浏览器上直接输入之外，这个链接还可以由Router.navigate()方法来生成。下面的代码在主页面上添加了一个按钮，点击按钮后触发一个同时带有路由参数和查询参数的跳转：
app.component.ts
```javascript
@Component({
  selector: 'my-app',
  template: `
    ...
    <button (click)="onClick()">Component B</button>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
export class AppComponent {
  constructor(private router: Router){ }

  onClick() {
    this.router.navigate(['/component-b', 'Angular2'], {queryParams: {framework: "Angular", version: 2}});
  }
}
```
>!!!!目前暂不知使用routerLink指令来生成查询参数的办法

##### 获取
查询参数的获取，可以通过Router服务提供的Observable对象来完成。通过下面的例子，我们可以看到，ActivatedRoute服务与Router服务各司其职，相互独立，和平共处，互不侵犯。
b.component.ts
```javascript
import { Component, OnInit, OnDestroy } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';

@Component({
  template: `
    <div>Component B</div>
    <div>路由参数: {{routeParams.framework}}</div>
    <div>查询参数: framework-{{queryParams.framework}} | version-{{queryParams.version}}</div>
  `
})
export class ComponentB implements OnInit, OnDestroy {
  private routeParamsSub: any;
  private queryParamsSub: any;
  private routeParams = {};
  private queryParams = {};

    constructor(private route: ActivatedRoute, private router: Router ) {
    console.log('创建ComponentB');
  }

  ngOnInit() {
    this.routeParamsSub = this.route.params.subscribe(params => {
      this.routeParams['framework'] = params['framework'];
    });

    this.queryParamsSub = this.router.routerState.queryParams.subscribe(params => {
      this.queryParams['framework'] = params['framework'];
      this.queryParams['version'] = params['version'];
    });
  }

  ngOnDestroy() {
    this.routeParamsSub.unsubscribe();
    this.queryParamsSub.unsubscribe();
  }
}
```

### 路由数据
!!!新路由没有这个功能了？


## 7.8 路由策略
路由策略定义了每一个路由所对应的URL的生成方式。Angular2提供了两种路由策略，分别为PathLocationStrategy和HashLocationStrategy。

### PathLocationStrategy
该策略是Angular2的默认路由策略，在本章刚开始时提到过，它要求必须为app设定一个base路径。在构造URL的时候，会将base路径和路由定义中的path值拼接起来，得到该路由对应的URL。在上面的例子中，base路径设置为了／，路由Component-A的path值为/component-a，则该路由的URL为http://localhost/component-a。如果base路径改为/foo，则URL相应地变为http://localhost/foo/component-a。

设置base路径的方式有两种：

第一，使用html的<base>元素。这个元素的作用是给整个页面设置了一个base路径，页面上所有的相对路径都将基于此base路径来解析。Angular2在初始化路由策略的时候，会尝试在页面上寻找该元素，并将其href属性的值作为app的base路径。
根据HTML5标准的规定，<base>元素只能做为<head>元素的子元素。下面在index.html中添加一个值为／的base路径。
```html
<head>
  <title></title>
  <base href="/">
  <!--其他-->
<head>
```
第二，APP_BASE_HREF
第一种方式是Angular2官方推荐的，但是如果现实中项目不适宜使用<base>元素，或者开发者无权限改动index.html的时候，Angular2还提供了一种方式，使用APP_BASE_HREF token。如果既设置了<base>元素，也使用了APP_BASE_HREF token，则后者的值会被用作base路径。

app.component.ts
```javascript
import { Component, provide } from 'angular2/core';
import { RouteConfig, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, APP_BASE_HREF } from 'angular2/router';

bootstrap(AppComponent, [
  ROUTER_PROVIDERS,
  provide(APP_BASE_HREF, {useValue : '/' })
]);
```

### HashLocationStrategy
使用PathLocationStrategy策略所生成的URL，在服务器上并不存在与其对应的文件目录结构，因此如果直接刷新页面，服务器会返回404错误。要解决这个问题，需要在服务器上做配置，将无法识别的URL重定向到主页。这样主页在加载完Angular2之后，就可以根据URL来跳转到相应的页面。

对于无法在服务器上进行上述配置的情形，angular2还提供了HashLocationStrategy策略。 该策略不需要设置base路径。在构造URL的时候，会使用#字符和路由定义中的path值拼接起来，得到该路由对应的URL。因此，路由Component-A的URL为http://localhost/#/component-a。根据URL的定义，#及其后的字符都不会发送给服务器。所以，在浏览器上输入上述链接的时候，实际上发送给服务器的URL只有http://localhost/，服务器会直接返回主页。之后再由angular2根据#后的值，来进行页面跳转。

要想使用HashLocationStrategy，只需要将其对应的类加载即可
```javascript
import { …, LocationStrategy, HashLocationStrategy } from 'angular2/router';

bootstrap(AppComponent, [ROUTER_PROVIDERS,
  provide(LocationStrategy, {useClass: HashLocationStrategy})]);
```

## 7.9 路由组件的懒加载
到目前为止，所有的路由组件都是在路由定义处被加载了进来。在下面的例子中，如果以URL http://localhost/ 访问应用，则ComponentA不会被显示，但是a.component.ts依然被加载。

app.component.ts
```javascript
import { ComponentA } from './a.component';

@RouteConfig([
  {
    path: '/component-a',
    name: 'Component-A',
    component: ComponentA
  }
])
```
对于一个大型web应用而言，可能会包括几十到上百个路由组件，如果一开始便把所有的路由组件都加载进来，对于用户体验和性能来说，都不是一个好的选择。Angular2允许进行路由组件的懒加载。下面的代码使用AsyncRoute定义了一个异步路由，并给异步路由的loader属性注册了一个方法。loader方法要求返回一个Promise，而用于解析该Promise的组件，便是该异步路由所要显示的组件。例子中首先通过对ComponentA的源文件进行加载来创建一个Promise，如果源文件能够被成功加载，便可使用ComponentA来解析该Promise，进而将ComponentA的内容显示出来。另外，loader方法在初次进入异步路由时才会被调用，并且只会被调用一次。
```javascript
import { …, AsyncRoute } from 'angular2/router';
//import { ComponentA } from './a.component';  //已在异步路由中加载，此处可省略

@RouteConfig([
  new AsyncRoute({
    path: '/component-a',
    name: 'Component-A',
    loader: () => System.import('app/a.component').then(m => m.ComponentA)
  })
])
```

## 7.9 本章小结
有道是九九归一，这是本章的第九小节，也是最后一个小节。在这最后的时刻，笔者怀着万分的不舍，饱含着深情的泪水，想给各位尊敬的读者朋友做个简单的小结。在web开发中，路由的概念由来已久，简而言之，就是利用URL的唯一性来指定特定的事物，这个事物可以是文件，状态，数据等等。服务器端路由早已有之，随着近几年REST理念的流行，为更多的人接受和使用。而浏览器客户端路由，则是随着单页应用的兴起，才被越来越多的前端框架所实现。本章首先介绍了如何使用Angular2来开发基本的路由功能，包括与URL对应的Component显示，路由跳转，参数传递。然后再进一步深入介绍了子路由，路由策略以及如何使用路由实现懒加载。希望通过本章的介绍，能够让大家对路由有一个基本的了解，并能快速地运用到实际项目中去。最后，祝大家加班愉快！

