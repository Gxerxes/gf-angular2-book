## 7. 路由

### 7.1 概述

&emsp;&emsp;众所周知，理论上，URL能够定位到互联网上的任何资源。同理，对于一个web应用而言，使用URL，可以表示该应用的任意状态。比如当前所处页面，显示内容，搜索条件，操作历史，甚至可以细化到页面上每一个DOM节点的任何属性。不过所想表示的状态越多越细，相应的URL就会越长。虽然RFC2616并没有对URL的长度作出限制，但是在现实中，一般认为2000个字符以下的URL，才能够被大部分浏览器和服务器正确识别。因此，由于这个限制，使用URL并不能够表示web应用的每一个细节，通常也没有必要。

&emsp;&emsp;假设在一个简单的非单页应用中，每一个页面都做为一个单独的文件存在于服务器端，根据文件在服务器上的不同路径，每一个页面很自然地获得了一个与其对应的URL。在单页应用中，只存在一个主页面，通过Ajax请求向服务器获取不同的页面内容和数据，来对主页面进行更新，但自始至终，主页面在服务器端只有一个URL。如果想要让主页面的不同状态对应不同的URL，需要做到两点：第一，在主页面的内容发生改变时，能够在浏览器上生成相应的URL；第二，当在浏览器上输入任意状态的URL时，能够将相应的内容生成出来。路由这种机制，就是为了解决这两点而被设计出来的。

&emsp;&emsp;和其他主流前端框架一样，Angular2也实现了路由机制。在Angular2中，一个页面由一个或多个Component组合而成，不同的Component组合生成了不同的页面。因此可以给每一种Component组合指定相应的URL（数目不限），当浏览器上URL发生改变时，Angular2会捕捉到相应的事件，从而渲染出相应的页面。

### 7.2 路由的基本用法
下面先来简单介绍一下Angular2中关于路由的基本概念

|  |  |
| ------- | ----- |
| 路由器 | 实现了整套路由机制，主要包括两个功能：第一，显示不同URL对应的Component；第二，控制不用路由之间的跳转。|
| 路由组件 | 带有路由功能的angular2组件，其模版中包含了<router-outlet>指令。一般为单页应用中的主页面。|
| 路由配置 | 路由配置包含了任意数目的路由定义，路由器将根据路由配置来进行工作。|
| 路由定义 | 定义URL和Component之间的映射关系。|
| 路由指令 | Angular2提供了3个路由指令，在组件模版中使用路由指令。|

### 7.3 路由的基本用法
接下来将通过具体的例子由浅入深地展示路由功能的全貌。这个例子包含了一个主页面和两个Component，将使用路由来控制两个Component在主页面上的展现。

main.ts
```javascript
import { bootstrap }    from '@angular/platform-browser-dynamic';
import { AppComponent } from './app.component';
bootstrap(AppComponent);
```
app.component.ts
```javascript
import { Component } from '@angular/core';

@Component({
  selector: 'my-app',
  template: '<h1>Master Page</h1>'
})
export class AppComponent {}
```
a.component.ts
```javascript
import { Component } from '@angular/core';

@Component({
  template: '<div>Component A</div>'
})
export class ComponentA {}
```
b.components.ts
```javascript
import { Component } from '@angular/core';

@Component({
  template: '<div>Component B</div>'
})
export class ComponentB {}
```

#### 设置base路径
Angular2默认的路由策略是PathLocationStrategy（路由策略的详细内容将会在某小节中提到，在此先行略过），该策略要求必须给app设置一个base路径。该路径可以通过在index.html中设置<base>元素的href属性来完成（附带一提，根据HTML标准的定义，如果设置了<base>元素的href属性，则该页面中所有的相对路径都将基于该属性来解析）。

index.html
```html
<head>
  <title></title>
  <!--base路径为http://localhost/-->
  <base href="/">
  <!--相对于base路径，解析为http://localhost/styles.css-->
  <link rel="stylesheet" href="styles.css">
</head>
```

#### 加载路由模块
由于并不是所有的web app都需要使用路由的功能，因此Angular2没有把其包含在核心模块@angular2/core之中，而是将其设计成了一个独立的模块@angular/router，以便按需加载。

##### 注入路由服务
provideRouter方法用于返回路由功能所必需用到的一系列服务。通过阅读源码可知，Angular2为大部分路由服务都提供了默认值（例如默认的路由策略为PathLocationStrategy），唯一需要用户提供的是路由定义。下面的例子，向provideRouter提供了一个空路由定义，并通过bootstrap对各路由服务依次进行注入。
main.ts
```javascript
import { bootstrap }    from '@angular/platform-browser-dynamic';
import { provideRouter, RouterConfig } from '@angular/router';
import { AppComponent } from './app.component';

const router: RouterConfig = [];
bootstrap(AppComponent, [provideRouter(router)]);
````

#### 定义路由
路由定义最基本的作用是将URL和Component关联起来，所以在定义路由的时候，这两者是必须的要素，分别由path和component属性来定义。下面的代码首先定义了一条默认路由，在主页面加载完成后即显示ComponentA；然后分别给ComponentA和ComponentB定义了各自的路由，当URL为http://localhost/component-a时应该显示ComponentA，当URL为http://localhost/component-b则应该显示ComponentB。
main.ts
```javascript
import { ComponentA } from './a.component';
import { ComponentB } from './b.component';

const router: RouterConfig = [
  { path: '', component: ComponentA },  /* http://localhost */
  { path: 'component-a', component: ComponentA },  /* http://localhost/component-a */
  { path: 'component-b', component: ComponentB }  /* http://localhost/component-b */
];
```
值得一提的是，不同的URL可以指向同一个Component。因此对于下面的定义，两个URL都将使ComponentA被显示出来。
```javascript
const router: RouterConfig = [
  { path: 'component-a', component: ComponentA },
  { path: 'component-b', component: ComponentA }
];
```
如果同一个URL被多次定义，则以第一次定义为最高优先级，其后的定义不会将其覆盖。下面的定义，对于URL http://localhost/component-a，将会显示ComponentA而不是ComponentB。
```javascript
const router: RouterConfig = [
  { path: 'component-a', component: ComponentA },
  { path: 'component-a', component: ComponentB }
];
```

上面的代码，为了达到循序渐进的效果，故而将路由服务的注入与定义都写在了main.ts之中。Angular2官方推荐的代码组织方式是用一个独立的文件来负责进行路由配置，从而使得main.ts能专注于整个app的启动。
app.routes.ts
```javascript
import { provideRouter, RouterConfig } from '@angular/router';
import { ComponentA } from './a.component';
import { ComponentB } from './b.component';

export const routes: RouterConfig = [
  { path: '', component: ComponentA },
  { path: 'component-a', component: ComponentA },
  { path: 'component-b', component: ComponentB }
];

export const APP_ROUTER_PROVIDERS = [
  provideRouter(routes)
];
```
main.ts
```javascript
import { bootstrap }    from '@angular/platform-browser-dynamic';
import { AppComponent } from './app.component';
import { APP_ROUTER_PROVIDERS } from './app.routes';

bootstrap(AppComponent, [APP_ROUTER_PROVIDERS]);
```

#### 显示组件
上面的路由定义，已经把URL和Component关联了起来，但是并没有指定Component应该在哪里显示，所以Angular2还不能将相应Component的内容显示在页面上。如果对ComponentA的代码做如下改动，会看到在输入http://localhost/component-a的时候，他的构造函数没有被调用到。

a.component.ts
```javascript
export class ComponentA {
  //此构造函数还不会被调用
  constructor() {
    console.log("创建ComponentA实例!");
  }
}
```

要想显示Component，需要在路由组件的模版中使用&lt;router-outlet&gt;指令。这个指令的作用相当于一个占位节点，在模版中开辟出一块区域，每个路由所对应的Component都将在这个区域内显示出来。一个模版只能定义一个匿名的&lt;router-outlet&gt;元素，但是可以定义任意多个命名的&lt;router-outlet&gt;元素。详细内容会在从路由部分深入展开。
>！！！从路由有着滔天的bug，还不确定是不是要提到！！！

下面的代码首先加载了ROUTER_DIRECTIVES，之后便可以在主页模版中使用&lt;router-outlet&gt;指令。此时在浏览器上输入两个不同路由的URL（http://localhost/component-a和http://localhost/component-b），便可以看到其所对应的Component被渲染出来。
app.component.ts
```javascript
import { ROUTER_DIRECTIVES } from '@angular/router';

@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
```

#### 路由跳转
##### 静态链接
大多数情况下，页面的跳转是通过超链接元素<a>来完成的，所以上例的模版可以进一步扩展如下。其中第二个超链接使用了Angular2的变量替换，这意味着URL的指向可以被动态更改，使得app可以根据用户的不同操作而提供指向不同Component的链接（在下例中，点击了“更改路由”按钮后，第二个超链接便会指向ComponentA）。
app.component.ts
```javascript
@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <nav>
      <a href="component-a">Component A</a>
      <a href="{{path_b}}">Component B</a>
    </nav>
    <button (click)="path_b = '/component-a'">更改路由</button>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
export class AppComponent {
  path_b = '/component-b';
}
```

上面的例子，有一个值得注意的地方，就是点击超链接之后，浏览器都会给后台服务器发一个请求，从而整个app会被重新加载一遍。虽然说加载完成后，路由所对应的Component也会被正确地显示出来，但这种加载是完全可以避免的，因为路由所需要的Component早已经在路由配置app.routes.ts中被加载了进来：
```javascript
import { ComponentA } from './a.component';
import { ComponentB } from './b.component';
```
要避免这种重新加载，可以使用[routerLink]指令。
app.component.ts
```javascript
@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <nav>
      <a [routerLink]="['/component-a']">Component A</a>
      <a [routerLink]="[path_b]">Component B</a>
    </nav>
    <button (click)="path_b = '/component-a'">更改路由</button>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
```

##### 动态跳转
除了直接修改浏览器URL和点击<a>元素，Angular2还提供了API接口，允许动态触发路由跳转。下面的例子首先加载了Router类，在点击按钮后执行Router.navigate()方法触发跳转。
app.component.ts
```javascript
import { Component } from '@angular/core';
import { ROUTER_DIRECTIVES, Router } from '@angular/router';

@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <nav>
      <a [routerLink]="['/component-a']">Component A</a>
    </nav>
    <button (click)="onClick()">Component B</button>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
export class AppComponent {
  constructor(private router: Router){ }

  onClick(){
    this.router.navigate(['/component-b']);
  }
}
```

### 7.4 路由拦截
在路由跳转中，从离开当前路由到进入下一个路由的过程中，会经过Angular2设定的一系列的钩子函数。这些钩子函数的作用相当于把跳转拦截下来，并对其进行各类检查校验，只有满足钩子函数设定的条件的跳转才予以放行。只有满足了所有的拦截钩子的跳转，才能够成功地进入下一个路由。

#### CanActivate
Angular 2提供了CanActivate接口。该接口只定义了一个方法canActivate()。当该方法返回true或者Observable<true>时，表示准许进入下一路由；反之，当返回false或者Observable<false>时，则继续停留在当前路由。下面的代码实现了一个最简单的拦截服务，直接对路由跳转放行。
CanActivateGuard.ts
```javascript
import { CanActivate } from '@angular/router';

export class CanActivateGuard implements CanActivate {
  canActivate() {
    console.log('CanActivate拦截!');
    return true;
  }
}
```

实现该接口的类，均可以通过依赖注入的方式注册到CanActivate钩子上。下面对app.routes.ts的代码稍作修改，将CanActivateGuard服务添加到路由定义上，并注入到app中。
app.routes.ts
```javascript
...
import { CanActivateGuard } from './CanActivateGuard';

export const routes: RouterConfig = [
  ...
  { path: 'component-b', component: ComponentB, canActivate: [CanActivateGuard] }
];

export const APP_ROUTER_PROVIDERS = [
  provideRouter(routes),
  [CanActivateGuard]
];
```

当能否进入下一个路由是根据异步操作的结果来决定时，那么CanActivate()方法就应该返回一个Observable<boolean>类型的实例，并且将异步操作放在该实例中执行。该实例可以对异步操作的结果加以分析判断，如果结果符合设定的条件，则发布一个true的消息，告知Angular2准许进入下一个路由；反之则发布一个false的消息，停留在当前路由。

下面的代码，在进入ComponentB之前，会出现一个弹窗让用户进行确认。我们将弹窗这个异步操作写进了Observable的实例中，并且直接将其结果通过observer.next()方法进行发布（注意，window.confirm()方法的返回值就是boolean类型，所以可以直接发布；对于返回值非boolean类型的异步操作，需要将其结果根据具体业务逻辑转化为boolean类型）。 
CanActivateGuard.ts
```javascript
import { CanActivate } from '@angular/router';
import { Observable } from 'rxjs/Observable';

export class CanActivateGuard implements CanActivate {
  canActivate() {
    return new Observable<boolean>(observer => {
      let result = window.confirm('是否确定进入ComponentB？');
      observer.next(result);
      observer.complete();
    });
  }
}
```

除了进入下一路由和停留在当前路由，路由拦截还允许跳转到另外的路由。
CanActivateGuard.ts
```javascript
import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';

@Injectable()
export class CanActivateGuard implements CanActivate {
  constructor(private router: Router){}

  canActivate() {
    this.router.navigate(['']);
  }
}
```

#### CanDeactivate
在通过了下一个路由的CanActivate拦截后，接下来会进入当前路由的CanDeactivate拦截，用于确定是否可以离开当前路由。同样，Angular 2提供了CanDeactivate接口。该接口只定义了一个方法canDeactivate()。当该方法返回true或者Observable<true>时，表示准许离开当前路由；反之，当返回false或者Observable<false>时，则继续停留在当前路由。下面的代码实现了一个最简单的拦截服务，直接对路由跳转放行。

与CanActivate的例子相似，下面的例子定义了一个CanDeactivate服务，将其添加到响应的路由定义上，并注入到app中。
CanDeactivateGuard.ts
```javascript
import { CanDeactivate } from '@angular/router';
import { Observable } from 'rxjs/Observable';

export class CanDeactivateGuard implements CanDeactivate<any> {
  canDeactivate() {
    return new Observable<boolean>(observer => {
      let result = window.confirm('是否确定离开ComponentA？');
      observer.next(result);
      observer.complete();
    });
  }
}
```
app.routes.ts
```javascript
...
import { CanDeactivateGuard } from './CanDeactivateGuard';

export const routes: RouterConfig = [
  ...
  { path: 'component-a', component: ComponentA, canDeactivate: [CanDeactivateGuard] },
  ...
];

export const APP_ROUTER_PROVIDERS = [
  ...
  [CanDeactivateGuard]
];
```

### 7.5 路由参数
到目前为止，已经实现了一个简单的路由，即可以通过静态URL将其对应的Component显示出来。但是对于动态页面而言，Component的内容不是固定不变的，因此URL除了需要指定显示哪个Component之外，还需要向Component传递参数，使其根据参数来生成所要显示的具体内容。

#### 路由参数
##### 定义
路由参数通过路由定义中的path属性来定义。在解析path属性的时候，Angular2会以／为分隔符对path属性进行分段，如果一个分段以:开头，则该分段表示路由参数。下面的例子，新添加了一条路由，包含了一个名为framework的参数。
app.routes.ts
```javascript
export const routes: RouterConfig = [
  { path: '', component: ComponentA },
  { path: 'component-a', component: ComponentA },
  { path: 'component-b', component: ComponentB },
  { path: 'component-b/:framework', component: ComponentB }
];
```

在进行路由匹配的时候，要求URL解析出来的分段数必须和path属性的分段数一致，否则将匹配不到。比如，http://localhost/component-b/Angular2 可以匹配到第4条路由，路由参 framework的值为"Angular2"。http://localhost/component-b和http://localhost/component-b/Angular2/xxx 则匹配不到该路由。

上面的例子，对路由参数的赋值，是通过在URL的对应分段上直接输入参数值来完成的。除此之外，还可以通过routerLink指令或者Router.navigate()方法来给路由参数赋值。
```
<a [routerLink]="['/component-b', 'Angular2']">Component A</a>
this.router.navigate(['/component-b', 'Angular2']);
```

##### 获取参数
在将URL匹配到对应的路由定义后，Angular2会生成一个路由快照，该快照包含了该次路由匹配的相关信息（包括URL，路由定义，以及从URL解析出来的路由参数等）。该快照可以通过ActivatedRoute服务的snapshot属性来访问。

为了更好地展示快照的行为，现在对主页面稍作修改，添加3个链接。第一个链接不带有任何参数，指向路由{ path: 'component-a', component: ComponentA }。第二和第三个链接各自带有不同的参数，指向同一个路由{ path: 'component-b/:framework', component: ComponentB }。
app.component.ts
```javascript
import { Component } from '@angular/core';
import { ROUTER_DIRECTIVES, Router } from '@angular/router';

@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <nav>
      <a [routerLink]="['/component-a']">Component A</a>
      <a [routerLink]="['/component-b', 'Angular1']">Component B1</a>
      <a [routerLink]="['/component-b', 'Angular2']">Component B2</a>
    </nav>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
export class AppComponent {}
```

接下来，在ComponentA和ComponentB的构造函数中注入ActivatedRoute服务，便可以通过其snapshot属性获取framework参数。依次点击主页面上的三个链接，便可以看到每条路由对应的参数在页面上显示出来（第一条路由没有参数，故页面上没有显示）。
a.component.ts
```javascript
import { Component } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  template: `
    <div>Component A</div>
    <div>路由参数: {{route.snapshot.params['framework']}}</div>
  `
})
export class ComponentA{
  constructor(private route: ActivatedRoute) {
    console.log('创建ComponentA实例!');
  }
}
```
b.component.ts
```javascript
import { Component } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  template: `
    <div>Component B</div>
    <div>路由参数: {{route.snapshot.params['framework']}}</div>
  `
})
export class ComponentB{
  constructor(private route: ActivatedRoute) {
    console.log('创建ComponentB实例!');
  }
}
```

从上面的例子还可以看出，如果从一条路由跳转到另外一条路由，Angular2会为新路由的Component重新创建一个实例；如果是在同一条路由内发生跳转，则不会重新创建实例。比如，在Component B1和Component B2两个链接之间相互跳转时，仅仅是URL上的路由参数发生了变化，两个URL依然指向同一个路由定义，此时两个URL共用同一个ComponentB的实例。这样的设计，避免了重新渲染ComponentB的模版所可能引起的页面闪烁。

此外，在实际开发中，通常需要执行特定的业务逻辑来对路由参数的变化做出响应。比如在上面的例子中，想实现一个功能，当路由参数的值为"Angular2"时，出现一个弹窗。如果是在不同路由间跳转（比如从链接Component A跳转到链接Component B2），由于会为ComponentB生成一个新实例，所以这段逻辑可以写在ComponentB的构造函数中：
b.component.ts
```javascript
export class ComponentB{
  constructor(private route: ActivatedRoute) {
    console.log('创建ComponentB');

    if(route.snapshot.params['framework'] === 'Angular2'){
      window.alert('你好，Angular2!');
    }
  }
}
```
但以上方法并不适用于在同一个路由间跳转的情况，因为ComponentB的构造函数不会被再次调用。为了解决这个问题，ActivatedRoute服务为路由参数提供了一个Observable对象，当路由参数发生改变时，该对象便可以通知其subscriber。
b.component.ts
```javascript
import { Component, OnInit, OnDestroy } from '@angular/core';
...
export class ComponentB implements OnInit, OnDestroy {
  private routeParams: any;

  constructor(private route: ActivatedRoute) {
    console.log('创建ComponentB');
  }

  ngOnInit() {
    this.routeParams = this.route.params.subscribe(params => {
      if(params['framework'] === 'Angular2'){
        window.alert('你好，Angular2!');
      }
    });
  }

  ngOnDestroy() {
    this.routeParams.unsubscribe();
  }
}
```

#### 查询参数
##### 定义
除了路由参数外，Angular2还允许通过URL查询字符串来传递查询参数。与路由参数不同的是，查询参数并不参与路由匹配。因此，可以给任意路由传递任意数目的查询参数。下面是一个包含查询字符串（?framework=Angular&version=2）的URL。该字符串定义了framework和version两个参数，其值分别为Angular和2；参数之间以&字符分隔。访问该链接的结果和访问http://localhost/component-a一样，都是将ComponentA显示出来。
```
http://localhost/component-a?framework=Angular&version=2
```
除了在浏览器上直接输入之外，这个链接还可以由Router.navigate()方法来生成。下面的代码在主页面上添加了一个按钮，点击按钮后触发一个同时带有路由参数和查询参数的跳转：
app.component.ts
```javascript
@Component({
  selector: 'my-app',
  template: `
    ...
    <button (click)="onClick()">Component B</button>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
export class AppComponent {
  constructor(private router: Router){ }

  onClick() {
    this.router.navigate(['/component-b', 'Angular2'], {queryParams: {framework: "Angular", version: 2}});
  }
}
```
>!!!!目前暂不知使用routerLink指令来生成查询参数的办法

##### 获取
查询参数的获取，可以通过Router服务提供的Observable对象来完成。通过下面的例子，我们可以看到，ActivatedRoute服务与Router服务各司其职，相互独立，和平共处，互不侵犯。
b.component.ts
```javascript
import { Component, OnInit, OnDestroy } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';

@Component({
  template: `
    <div>Component B</div>
    <div>路由参数: {{routeParams.framework}}</div>
    <div>查询参数: framework-{{queryParams.framework}} | version-{{queryParams.version}}</div>
  `
})
export class ComponentB implements OnInit, OnDestroy {
  private routeParamsSub: any;
  private queryParamsSub: any;
  private routeParams = {};
  private queryParams = {};

    constructor(private route: ActivatedRoute, private router: Router ) {
    console.log('创建ComponentB');
  }

  ngOnInit() {
    this.routeParamsSub = this.route.params.subscribe(params => {
      this.routeParams['framework'] = params['framework'];
    });

    this.queryParamsSub = this.router.routerState.queryParams.subscribe(params => {
      this.queryParams['framework'] = params['framework'];
      this.queryParams['version'] = params['version'];
    });
  }

  ngOnDestroy() {
    this.routeParamsSub.unsubscribe();
    this.queryParamsSub.unsubscribe();
  }
}
```

### 路由数据
!!!新路由没有这个功能了？

### 7.6 子路由


## 7.7 路由策略
路由策略定义了每一个路由所对应的URL的生成方式。Angular2提供了两种路由策略，分别为PathLocationStrategy和HashLocationStrategy。

### PathLocationStrategy
该策略是Angular2的默认路由策略，在本章刚开始时提到过，它要求必须为app设定一个base路径。在构造URL的时候，会将base路径和路由定义中的path值拼接起来，得到该路由对应的URL。在上面的例子中，base路径设置为了／，路由Component-A的path值为/component-a，则该路由的URL为http://localhost/component-a。如果base路径改为/foo，则URL相应地变为http://localhost/foo/component-a。

设置base路径的方式有两种：

第一，使用html的<base>元素。这个元素的作用是给整个页面设置了一个base路径，页面上所有的相对路径都将基于此base路径来解析。Angular2在初始化路由策略的时候，会尝试在页面上寻找该元素，并将其href属性的值作为app的base路径。
根据HTML5标准的规定，<base>元素只能做为<head>元素的子元素。下面在index.html中添加一个值为／的base路径。
```html
<head>
  <title></title>
  <base href="/">
  <!--其他-->
<head>
```
第二，APP_BASE_HREF
第一种方式是Angular2官方推荐的，但是如果现实中项目不适宜使用<base>元素，或者开发者无权限改动index.html的时候，Angular2还提供了一种方式，使用APP_BASE_HREF token。如果既设置了<base>元素，也使用了APP_BASE_HREF token，则后者的值会被用作base路径。

app.component.ts
```javascript
import { Component, provide } from 'angular2/core';
import { RouteConfig, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, APP_BASE_HREF } from 'angular2/router';

bootstrap(AppComponent, [
  ROUTER_PROVIDERS,
  provide(APP_BASE_HREF, {useValue : '/' })
]);
```

### HashLocationStrategy
使用PathLocationStrategy策略所生成的URL，在服务器上并不存在与其对应的文件目录结构，因此如果直接刷新页面，服务器会返回404错误。要解决这个问题，需要在服务器上做配置，将无法识别的URL重定向到主页。这样主页在加载完Angular2之后，就可以根据URL来跳转到相应的页面。

对于无法在服务器上进行上述配置的情形，angular2还提供了HashLocationStrategy策略。 该策略不需要设置base路径。在构造URL的时候，会使用#字符和路由定义中的path值拼接起来，得到该路由对应的URL。因此，路由Component-A的URL为http://localhost/#/component-a。根据URL的定义，#及其后的字符都不会发送给服务器。所以，在浏览器上输入上述链接的时候，实际上发送给服务器的URL只有http://localhost/，服务器会直接返回主页。之后再由angular2根据#后的值，来进行页面跳转。

要想使用HashLocationStrategy，只需要将其对应的类加载即可
```javascript
import { …, LocationStrategy, HashLocationStrategy } from 'angular2/router';

bootstrap(AppComponent, [ROUTER_PROVIDERS,
  provide(LocationStrategy, {useClass: HashLocationStrategy})]);
```

## 7.8 路由组件的懒加载
到目前为止，所有的路由组件都是在路由定义处被加载了进来。在下面的例子中，如果以URL http://localhost/ 访问应用，则ComponentA不会被显示，但是a.component.ts依然被加载。

app.component.ts
```javascript
import { ComponentA } from './a.component';

@RouteConfig([
  {
    path: '/component-a',
    name: 'Component-A',
    component: ComponentA
  }
])
```
对于一个大型web应用而言，可能会包括几十到上百个路由组件，如果一开始便把所有的路由组件都加载进来，对于用户体验和性能来说，都不是一个好的选择。Angular2允许进行路由组件的懒加载。下面的代码使用AsyncRoute定义了一个异步路由，并给异步路由的loader属性注册了一个方法。loader方法要求返回一个Promise，而用于解析该Promise的组件，便是该异步路由所要显示的组件。例子中首先通过对ComponentA的源文件进行加载来创建一个Promise，如果源文件能够被成功加载，便可使用ComponentA来解析该Promise，进而将ComponentA的内容显示出来。另外，loader方法在初次进入异步路由时才会被调用，并且只会被调用一次。
```javascript
import { …, AsyncRoute } from 'angular2/router';
//import { ComponentA } from './a.component';  //已在异步路由中加载，此处可省略

@RouteConfig([
  new AsyncRoute({
    path: '/component-a',
    name: 'Component-A',
    loader: () => System.import('app/a.component').then(m => m.ComponentA)
  })
])
```

## 7.9 本章小结
有道是九九归一，这是本章的第九小节，也是最后一个小节。在这最后的时刻，笔者怀着万分的不舍，饱含着深情的泪水，想给各位尊敬的读者朋友做个简单的小结。在web开发中，路由的概念由来已久，简而言之，就是利用URL的唯一性来指定特定的事物，这个事物可以是文件，状态，数据等等。服务器端路由早已有之，随着近几年REST理念的流行，为更多的人接受和使用。而浏览器客户端路由，则是随着单页应用的兴起，才被越来越多的前端框架所实现。本章首先介绍了如何使用Angular2来开发基本的路由功能，包括与URL对应的Component显示，路由跳转，参数传递。然后再进一步深入介绍了子路由，路由策略以及如何使用路由实现懒加载。希望通过本章的介绍，能够让大家对路由有一个基本的了解，并能快速地运用到实际项目中去。最后，祝大家加班愉快！

