#3 模板

## 引言
HTML是模板的主要形式，Angular模板的默认语言就是HTML。几乎所有的HTML语法在模板中都是适用的。但`<script>`元素是被禁止的，主要是为了防止Javascript脚本的注入。同时一些HTML元素在模板中并不起什么作用，比如`<html>`，`<body>`，`<base>`。除此之外，Angular2中可以通过组件和指令对模板的HTML词汇进行扩展，这些扩展作为新的元素和属性出现。
## 3.1 插值
数据绑定最常见的形式就是插值，在Angular中，默认使用的是双大括号作为插值语法。使用插值可以在HTML元素标签和属性值内将变量输出，如

```
<h3>
{{title}}
<img src="{{ImageUrl}}">
</h3>
```
大括号中间的通常是一个组件属性的变量名，Angular使用了相应组件属性的值来替换这个变量。在这个例子中，Angular就是对`title`和`ImageUrl`求值并替换后，最终在页面中展示出来。
更普遍的做法是，大括号里面还可以是一个合法的表达式，Angular首先进行求值，再转换成一个字符串，如

```
<!-- "1+1=2" -->
<p>1+1={{1+1}}</p>
```
表达式甚至可以调用宿主组件的函数，如

```
<!-- "1+1的和不是4" -->
<p>1+1的和不是{{1 + 1 + getVal()}}</p
```
Angular对于双大括号里面的表达式都会求值，转化成字符串的结果，然后和附近的字符串组合在一起。最终，将这个结果分配给元素或者指令的属性。
表面上看，插值的作用是将`{{`和`}}`里面的内容计算转化成字符串后，“替换”`{{...}}`这里的内容，这样的理解在使用上并没有问题，但是实际在Angular中，插值的本质是转化成`属性绑定`的一种特殊语法，`{{`和`}}`里面的内容，在Angular中称为`模板表达式`，接下来先来了解一下模板表达式，然后再继续学习属性绑定。

### 3.1.1 模板表达式
一个模板表达式产生一个值。Angular会执行这个表达式并将值分配给一个绑定目标的属性上。这个目标可能是一个HTML元素，一个组件或者一个指令。
目标表达式书写在插值语法中，在属性绑定那里将再次看到模板表达式的出现，`[属性]="模板表达式"`。
模板表达式写起来就像是Javascript，很多Javascript表达式都是合法的模板表达式，但不是全部。
有或促进副作用的Javascript表达式是被禁止的，包括：
* 赋值表达式（`=`，`+=`，`-=`...）
* new操作符
* 带有`;`或者`'`的连接表达式
* 自增和自减操作（`++`和`--`）
其他与Javascript语法不同的值得注意的包括：
* 不支持位运算符（`|`和`&`）
* 模板表达式的操作符，如`|`和`?.`等，被赋予了新的含义
模板表达式不能引用任何全局命名空间中的成员，如window何document，也不能调用`console.log`或者`Math.max`等方法，仅限于引用表达式上下文的成员。表达式的上下文典型的是绑定目标的值的组件实例。当看到被双大括号包裹的*title*—{{title}}，就会知道`title`是数据绑定组件的一个属性。当看到`[disabled]="ischange"`中的*ischange*，就会知道引用了组件的`ischange`属性。组件本身通常是表达式的上下文，这就是模板表达式通常引用那个组件的原因。表达式上下文除了组件外还可以是一个对象，一个模板引用变量可以是这样的一个可供替代的上下文对象。
__模板表达式的书写原则__
模板表达式能够制作或者毁坏一个应用，所以请遵守这些原则：
* 没有副作用——一个模板表达式除了改变目标属性的值以外不应该改变任何应用状态，这是基于Angular2的“单向数据路”准则。不用担心在读组件值的时候改变其他的一些展示值。视图应当通过一个单向传递来保持稳定。
* 快速执行——Angular执行表达式的频率远超我们的想象。每一次的键盘或者鼠标事件这些表达式都会被执行。如果表达式执行缓慢，将会大大降低用户的体验。当计算复杂时，可以考虑从其他计算的值缓存来计算。
* 简单——尽管可以写一些相当复杂的模板表达式，但是通常不要这么做。属性名字和方法调用应当成为规范。偶尔有个布尔值否定（!）也是可以的。否则，限制应用和业务逻辑都放到组件自身，这样也会令开发和测试变得容易。
* 幂等性——一个幂等性表达式是理想的，因为幂等性表达式是单边影响并且提高了Angular的改变检测性能。在Angular中，幂等性表达式通常在他依赖的值改变之前都会返回一个准确的相同的值。

### 3.1.2 模板声明
模板声明通过绑定目标（比如元素、组件或者指令）来响应一个事件。在事件绑定部分也将会有模板声明的介绍，模板声明出现在`=`的右侧，如`(事件)="模板声明"`
和模板表达式一样，模板声明和Javascript语句类似。模板表达式和模板声明的解析器不同，模板声明支持`=`赋值操作，也支持多条语句（用;或者,分隔）。但是，一些Javascript语句还是不被支持的：
* new操作符
* 自增和自减操作（`++`和`--`）
* 赋值操作，如`+=`和`-=`
* 不支持位运算符（`|`和`&`）
模板表达式操作和模板表达式一样，模板声明只能引用其上下文环境的成员变量，模板声明的上下文环境就是绑定事件的组件实例。模板声明不能引用任何全局命名空间中的成员，不能引用`window`或者`document`，也不能引用`console.log`或者`Math.max`。`(click)="onSave()"`里面的*onSave*肯定是宿主组件的实例函数。模板声明的上下文除了组件外可以包括一个对象。一个模板引用变量就是一个可以替代的上下文对象。在事件绑定声明中将会频繁的看到`$event`保留字的使用，这是DOM事件本身的一个扩展引用。
#### 模板声明的书写原则
和模板表达式一样，避免写得太复杂，推荐的写法是一个简单的函数调用，或者是一次赋值操作。


## 3.2 数据绑定
### 3.2.1 概览
数据绑定为应用程序提供了一种简单而一致的方法来显示数据以及数据交互，它是管理应用程序里面数值的一种机制。通过这种机制，可以从HTML里面取值和赋值，使得数据的读写，数据的持久化操作变得更加简单快捷。仅仅需要在绑定源和目标HTML元素之间声明绑定，其他的交给框架去做就可以了。
Angular提供了多种数据绑定方式，可以根据数据流向将它们分为三种，每一种都有各自的语法：

数据流向 | 语法 | 绑定类型
------ | ------ | ------
单向：从数据源到目标视图 | ```{{expression}}<br>[target] = "expression"<br>bind-target = "expression"``` | DOM对象属性(property)<br>HTML标签特性(attribute)<br>类<br>样式
单向：从视图目标到数据源 | ```(target) = "statement" on-target = "statement"``` | 事件
双向 | ```[(target)] = "expression" bindon-target = "expression"``` | 双向


绑定类型除了插值外在`=`的左侧都会有一个目标名称，或者被标点符号包裹（`[]`，`()`），或者有一个前缀（`bind-`，`on-`，`bindon-`）。那么什么是绑定目标呢？在这之前，先挑战自己用一种新的方式来重新理解HTML模板。

Angular2扩展了HTML标签，我们可以称之为HTML+，但是HTML+与经常使用的HTML也有着显著的区别，理解它需要一种新的思维模式。在正常的HTML环境中，用HTML元素可以创建一个可视化结构，并且通过使用字符串常量来设置元素属性可以改变这些元素。如：

```HTML
<div class="special">Mental Model</div>
<img src="images/hero.png">
<button disabled>Save</button>
```

在Angular模板中依然使用这种方式创建这种结构并且初始化属性的值。然后开始通过封装了HTML的组件来创建新的元素，这个组件会将封装的HTML丢进模板中就好像它们是本地的HTML元素。如：

```HTML
<!-- 正常的 HTML元素 -->
<div class="special">Mental Model</div>
<!-- 新元素 -->
<hero-detail></hero-detail>
```

这就是HTML+。现在开始学习数据绑定，看如下代码：

```HTML
<button [disabled]="isUnchanged">Save</button>
```

有那么一瞬间，你的直觉会告诉你这段代码绑定了button的disabled属性，并且通过组件的isUnchanged属性来设置disabled属性的值。不幸的是，你的直觉错了。平时的HTML思维模式误导了你。实际上，当开始数据绑定时，我们就不再设置HTML标签特性（HTML attribute）了，而是设置DOM对象属性（DOM property）、组件以及指令的对象成员变量。

DOM对象属性(property)与HTML标签特性(attribute) 
property和attribute都可以译为”属性“，名字相同，意义却大有不同。理解这两个属性的不同是理解Angular如何进行数据绑定的关键。首先，attribute就是DOM节点自带的属性，是在HTML里定义的，例如HTML中常用的id、class、align等，而property则是这个DOM元素作为对象，其附加的内容，是在文档对象模型里定义的，如childNodes、firstChild等。即只要是DOM标签中出现的属性（HTML代码）都是attribute，但有些常用特性（id、title、class等）会”脚踏两只船“被转化为property。
__图片占位__
其次，attribute的作用是用来初始化DOM对象属性，建立完DOM树后，attribute的使用就结束了，但DOM对象属性会被改变，attribute就不会。
举个例子，当浏览器渲染`<input type="text" value="Bob">`时，浏览器会用value创建一个对应的DOM节点并初始化值为”Bob”。当用户在该输入框里输入”Sally”，DOM对象属性值就变成”Sally”，但HTML元素属性值依然是”Bob”（input.getAttribute('value')  //return ”Bob“）。所以HTML元素属性值是指定初始化的值，DOM对象属性值当前值。
再举个例子，disabled attribute是另一个特有的例子。按钮会有一个默认值为`false`的`disabled`属性，所以按钮默认是激活状态。当给按钮添加`disabled`属性时，仅仅是单独添加`disabled`便会自动初始化该属性值为`true`，按钮便会变为禁用状态。添加或者移除`disabled`属性来禁用和激活按钮，而这个属性的值是毫不相关的，这就是为什么通过设置`disabled`的值不能改变按钮的状态的原因，如`<button disabled="false">Still Disabled</button>`。
注意，理解这两个的区别很重要。强调一下，模板绑定是作用在DOM对象属性和事件上，而不是HTML标签特性上。在Angular2的世界里，HTML标签特性的唯一作用就是用来初始化元素和指令的状态，而数据绑定时，仅仅解决元素、指令属性和事件，HTML标签特性消失在这里。请牢记这一思维模式。

#### 绑定目标

数据的绑定目标是DOM元素的某些东西。根据绑定类型的不同，绑定目标可以是一个（元素|组件|指令）的对象属性，或者一个（元素|组件|指令）的事件，或者一个HTML标签特性的名字。

绑定类型 | 目标 | 例子
--------- | ------------- | --------------
DOM对象属性 | 元素属性<br>组件属性<br>指令属性 | ```<img [src] = "heroImageUrl"><br><hero-detail [hero]="currentHero"></hero-detail><br><div [ngClass] = "{selected: isSelected}"></div>```
事件 | 元素事件<br>组件事件<br>指令事件 | ```<button (click) = "onSave()">Save</button><br><hero-detail (deleteRequest)="deleteHero()"></hero-detail><br><div (myClick)="clicked=$event">click me</div>```
双向 | 事件和DOM对象属性 | ```<input [(ngModel)]="heroName">```
HTML标签特性 | HTML标签特性（特例） | ```<button [attr.aria-label]="help">help</button>```
类 | 类属性 | ```<div [class.special]="isSpecial">Special</div>```
样式 | 样式属性 | ```<button [style.color] = "isSpecial ? 'red' : 'green'">```

### 3.2.2 属性绑定
当要把一个视图元素的属性设置为模板表达式时，就需要模板的属性绑定。最常用的模板属性是把元素的属性设置为组件中属性的值。来看下面几个例子，image元素的src属性会被绑定到组件的`heroImageUrl`属性上：

```HTML
<img [src]="heroImageUrl">
```

当组件说它`isUnchanged`（未改变）时禁用一个按钮：

```HTML
<button [disabled]="isUnchanged">Cancel is disabled</button>
```

设置指令的属性：
```HTML
<div [ngClass]="classes">[ngClass] binding to the classes property</div>
```

设置一个自定义组件的属性（这是父子组件间通讯的重要途径）：
```HTML
<hero-detail [hero]="currentHero"></hero-detail>
```
#### 单向输入

因为值的流动方向是单向的，所以大家经常把属性绑定描述成单向数据，即值是从组件中的属性数据流向到目标元素的属性。属性绑定不能用来从目标元素拉取值，也不能从绑定到目标元素的属性来读取它，只能设置它。如果DOM对象触发了一个事件，可以用事件绑定来处理。*（如果非要读取目标元素属性或者调用它的函数，需要使用另一种技术，可以参考viewChild和contentChile）*

#### 属性绑定的中括号&绑定目标
中括号（`[]`）内的属性就是绑定目标，也可以使用bind-前缀的形式，bind-前缀也成为 __规范形式__ 。如目标属性是image元素的src属性可以是下面的两种形式：

```HTML
<img [src]="heroImageUrl">
<img bind-src="heroImageUrl">
```
通常情况下目标的名称就是DOM对象属性的名称。如上面例子中的src，注意，src并不是image元素的HTML标签特性(attribute)，而是image元素的DOM对象属性(property)。DOM对象属性是最常见的绑定目标，不过Angular会首先判断目标名称是否是一个定义好的指令的属性名，也就是说指令属性处理的优先级大于DOM对象属性。如：

```HTML
<div [ngClass]="classes">[ngClass] binding to the classes property</div>
```
如果名字没有匹配上一个已知指令或元素的属性， Angular 就会报告一个“未知指令”的错误。
中括号也会告诉Angular要计算模板表达式。如果忘记了中括号，Angular就会把这个表达式当做一个字符串常量看待，并且用该字符串来 __初始化目标属性__ ，而不会计算这个字符串。所以不要出现这样的错误：

```HTML
<!-- ERROR: HeroDetailComponent.hero expects a
     Hero object, not the string "currentHero" -->
  <hero-detail hero="currentHero"></hero-detail>
```
但是当满足下面三个条件时，可以 __省略中括号__ 。

* 目标属性接受字符串值
* 这个字符串是一个固定的值
* 初始值永不改变

在标准的HTML中经常用用这种方式初始化HTML标签特性（Attribute），这种方式也可以用在初始化指令和组件的属性。下面这个例子把`HeroDetailComponent`的`prefix`属性初始化成了一个固定的字符串，而不是模板表达式。注意与`hero`的对比，`hero`是可以改变的。

```HTML
<hero-detail prefix="You are my" [hero]="currentHero"></hero-detail>
```

#### 避免副作用
如前所述，模板表达式不能有可见的副作用，在属性绑定表达式中不能对任何东西赋值，也不能进行自增自减运算。当然，表达式也可能会调用一个具有副作用的属性或方法。但Angular不可能知道这一点，更不能防止我们误用。比如表达式中可以调用像`getFoo()`这样的方法，只有你才知道`getFoo()`做了什么。如果这个方法改变了什么，而你却把它绑定在什么地方，那么，你可能就把自己坑了。因为Angular可能显示也可能不显示变化后的值。Angular也可能检测到变化，并抛出一个警告性错误。但普遍性的建议是：只使用数据属性和那些只返回值而不做其他事情的方法。
同时，模板表达式应该返回一个目标属性所需类型的值。如果目标属性想要个字符串，就返回字符串。如果目标属性想要个数字，就返回数字。 如果目标属性想要个对象，就返回对象。

#### 属性绑定与插值的区别和联系
开发人员通常会在插值和属性绑定之间做选择。如下面的例子，插值和属性绑定两者起到了相同的效果。

```HTML
<p><img src="{{heroImageUrl}}"> is the <i>interpolated</i> image.</p>
<p><img [src]="heroImageUrl"> is the <i>property bound</i> image.</p>

<p><span>"{{title}}" is the <i>interpolated</i> title.</span></p>
<p>"<span [innerHTML]="title"></span>" is the <i>property bound</i> title.</p>
```
在多数情况下，插值是一个更方便的选择。实际上，在渲染视图之前， Angular就会把这些插值表达式翻译成为对应的属性绑定形式。从技术上看无法决定哪种形式更好。但从可读性角度出发，建议使用插值表达式的方式。建议建立组织级的代码风格规定，然后选择一种形式，既能遵循规则，又能让手头的任务做起来更自然。
不论哪种方式，Angular都会对危险的HTML有所防备。在显示它们之前，Angular会先对内容进行“消毒”，不会允许带有`script`标签的HTML泄露到浏览器中。如：

```HTML
evilTitle = 'Template <script>alert("evil never sleeps")</script>Syntax';
```

#### HTML标签特性绑定、css类绑定与style样式绑定
##### HTML标签特性绑定
在Angular2的世界中，推荐使用DOM元素属性绑定，但为何还会有HTML标签特性绑定呢？这是因为当元素没有属性可绑的时候，就不能不使用HTML标签特性（Attribute）绑定（这是“绑定到目标属性”这一规则中唯一的例外，是唯一一个能够创建和设置Attribute的绑定形式）。比如，ARIA,SVG和table中的colspan/rowspan等HTML标签特性，是纯粹的Attribute，并没有相对于的属性可供绑定，如果写出类似下面的东西，就会非常糟糕：

```HTML
<tr><td colspan="{{1 + 1}}">Three-Four</td></tr>
```
还会得到这个错误

```
Template parse errors:
Can't bind to 'colspan' since it isn't a known native property
```
模板解析错误：不能绑定到'colspan'，因为它不是已知的原生属性

正如错误提示所说，`<td>`元素没有`colspan`标签特性（Attribute）。插值和属性绑定只能设置DOM元素属性，而不是HTML标签特性，所以需HTML标签特性绑定类创建和绑定类似的Attribute。HTML标签特性绑定在语法上类似于属性绑定，但中括号中的部分不是一个元素的属性名，而是由一个`attr.`的前缀和HTML标签特性的名字组成，然后通过一个能求值为字符串的表达式来设置HTML标签特性的值。如：

```HTML
<table border=1>
  <tr><td [attr.colspan]="1 + 1">One-Two</td></tr>
  <tr><td>Five</td><td>Six</td></tr>
</table>
```
HTML标签特性绑定的主要用途之一就是用来设置ARIA Attribute（ARIA指用于给残障人士访问互联网提供便利）。如：

```HTML
<!-- 为无障碍浏览创建并设置aria标签特性 -->
<button [attr.aria-label]="actionName">{{actionName}} with Aria</button>
```

##### css类绑定

借助css类绑定可以很方便的从`class`元素特性上添加和移除css类名。css类绑定在语法上类似于属性绑定，但中括号中的部分不是一个元素的属性名，css类绑定由一个`class`前缀紧跟一个点`.`，再跟着css类的名字组成，其中后两部分可选，类似于：`[class.class-name]`。下面的例子展示了如何通过css类绑定类添加和移除“special”类：

```HTML
<!-- 标准HTML样式类设置 -->
<div class="bad curly special">Bad curly special</div>
<!-- 通过绑定重设或覆盖样式类  -->
<div class="bad curly special" [class]="badCurly">Bad curly</div>
<!-- 通过一个属性值来添加或移除special样式类 -->
<div [class.special]="isSpecial">The class binding is special</div>
```
虽然通过css类绑定是一个切换单一类名的好办法，但还是建议使用`NgClass指令`来管理类名。

##### style样式绑定

通过样式绑定，可以设置内联样式。样式绑定语法上类似于类似于属性绑定，但中括号中的部分不是一个元素的属性名，样式绑定包括一个`style`前缀，紧跟一个点`.`，再跟着css样式的属性名，形如`[style.style-property]`。如：

```HTML
<button [style.color] = "isSpecial ? 'red': 'green'">Red</button>
<button [style.background-color]="canSave ? 'cyan': 'grey'" >Save</button>

<!-- 带有单位的样式绑定 -->
<button [style.font-size.em]="isSpecial ? 3 : 1" >Big</button>
<button [style.font-size.%]="!isSpecial ? 150 : 50" >Small</button>
```

样式属性可以是中线命名法（font-size），也可以是驼峰是命名法（fontSize）。虽然样式绑定可以很好的设置单一样式，但还是建议使用`NgStyle指令`来设置内联样式。

### 3.2.3 事件绑定
前面所说的数据流向都是从组件到元素单方向的，但是用户不会仅仅盯着屏幕看，他们会在文本框内输入文字，会从下拉框中选取条目，会点击按钮等等动作，这类用户的动作可能导致反向的数据流向： __从元素到组件__ 。
监听事件是知道用户动作的唯一方式，比如键盘事件、鼠标事件、触屏事件。在Angular2中可以通过事件绑定来定义那些对用户感兴趣的动作。事件绑定的语法是由等号左侧小括号内的 __目标事件__ 和右侧引号中的 __模板语句__ 组成。比如下面这个例子，是事件绑定监听按钮的点击事件。无论什么时候点击，都会调用组件的 `onSave()`方法。

```HTML
<button (click)="onSave()">Save</button>
```

#### 目标事件

小括号`()`中的名称即标记出了目标事件，如下，目标是按钮的click事件：

```HTML
<button (click)="onSave()">Save</button>
```
除了小括号，也可以使用规范形式来标记目标事件，即`on-`前缀，如：

```HTML
<button on-click="onSave()">On Save</button>
```
元素事件是更常见的目标事件，但Angular2会先看这个名字是否能够匹配已知指令的事件，如果事件名称既不是元素事件，也不是某个已知指令的事件，Angular2就会抛出一个“未知指令”的错误。

#### $event对象和事件处理器

在事件绑定中，Angular2会为目标事件设置事件处理器。当事件发生时，这个处理器便会执行模板语句。典型的模板语句通常涉及到那些针对事件想做出相应处理的接收器，如从一个HTML控件中取得一个值，并存入一个模型中。这种绑定会通过一个名叫`$event`的事件对象来传递有关这个事件的信息（包括数据值）。

事件对象的形态取决于目标事件本身。如果目标事件是一个原生的DOM元素事件，$event就是一个DOM事件对象，有如`target`和`target.value`这样的属性。如：

```HTML
<input [value]="currentHero.firstName" (input)="currentHero.firstName=$event.target.value" >
```
这个例子会把输入框的value绑定到firstName属性，并通过绑定到输入框的input事件来监听更改。当用户更改输入框的文本时，input事件就会被触发，对应的模板声明就会被执行，且该模板声明的上下文里包含了一个DOM事件对象变量（`$event`），要更改firstName属性，就必须通过$event.target.value来获取更改后的值。
如果这个事件属于指令（切记，组件是指令的一种），那么$event便具有指令所生成的形态（如inputs）。

#### 自定义事件

指令通过Angular2提供的EventEmitter对象来触发自定义事件。指令创建一个EventEmitter实例，并将其作为一个属性暴露出来。指令调用EventEmitter.emit(payload)来触发一个事件，其中payload可以传入任何值，父指令通过绑定这个属性来监听这个事件，并通过$event对象来获取payload。
假设有一个通讯录，里面记载了联系人信息，并响应用户的动作。虽然`UseraDetailComponent`有一个删除按钮，但它自己并不知道该如何删除这个联系人。最好的做法就是触发一个事件来报告“删除联系人”的请求。

```JAVASCRIPT
//UseraDetailComponent(节选)
template: `
<div>
  <img src="{{userImageUrl}}">
  <span [style.text-decoration]="lineThrough">
    {{prefix}} {{hero?.fullName}}
  </span>
  <button (click)="delete()">Delete</button>
</div>`

deleteRequest = new EventEmitter<Hero>();

delete() {
  this.deleteRequest.emit(this.hero);
}
```

组件定义了一个`deleteRequest`属性，这是一个`EventEmitter`实例。当点击删除按钮时，组件就会调用`delete()`方法，这个方法告诉`EventEmitter`，传递一个`User`对象。假设作为宿主的父组件绑定到了`UserDetailComponent`的`deleteRequest`事件：

```HTML
<user-detail (deleteRequest)="deleteUser($event)" [user]="currentUser"></user-detail>
```

当`deleteRequest`事件触发时，Angular就会调用父组件的`deleteUser`方法，在`$event`中传入要删除的联系人（来自`UserDetail`）即可。deleteUser方法删除联系人会更新模型，也可能触发其他修改，包括向远端服务器的查询和保存。这些变更会通过系统进行扩散，并最终显示到当前以及其他视图中。

### 3.2.4 双向绑定

当开发数据输入表单时，期望的结果是既能将组件的数据显示到表单上，也能在用户修改时更新组件的数据。之前了解到的属性绑定和事件绑定已经可以实现了这种双向绑定效果：

```HTML
<input [value]="currentHero.firstName"
       (input)="currentHero.firstName=$event.target.value" >
```

这样看起来很笨拙，谁能记住哪个元素属性用于设置，哪个用于汇报用户更改？又该如何从输入框中提取出当前显示的文本，以便更新数据属性？谁想每次都去查一遍？幸运的是，Angular2里的NgModel指令可以更便捷的进行双向绑定。

```HTML
<input
  [ngModel]="currentHero.firstName"
  (ngModelChange)="currentHero.firstName=$event">
```

ngModel指令通过它自己的`ngModel`输入属性和`ngModelChange`输出属性隐藏了这些繁琐的细节。这样看起来虽然好一点，但还是不够，没必要对同一个数据源进行两次数据绑定，于是Angular2指定了一种新语法来支持数据绑定`[()]`。

```HTML
<input [(ngModel)]="currentHero.firstName">
```

就是这么简单。`[]`实现了数据流从组件到模板，`()`实现了数据流从模板到组件，两者一结合`[()]`就实现了双向绑定，形象的形容这种语法就叫做“盒子里的香蕉”。也可以用前缀形式的语法：

```HTML
<input bindon-ngModel="currentHero.firstName">
```

`[()]`这种语法只能设置一个数据绑定属性，如果需要做更多或不同的事情，就需要它的展开形式来实现，比如强制让输入值变为大写形式：

```HTML
<input
  [ngModel]="currentHero.firstName"
  (ngModelChange)="setUpperCaseFirstName($event)">
```

### 3.2.5 输入和输出属性

在一个绑定声明中，出现在绑定声明右侧的，称之为数据绑定的 __源__ 。出现在绑定声明左侧的，称之为绑定到的 __目标__ ，这些指令的属性必须被声明称 __输入__ 或 __输出__ 。切记，所有的组件皆为指令。

绑定目标和绑定源的区别

绑定目标 | 绑定源
------- | ------
在`=`左侧 | 在`=`右侧
{% raw %}
是绑定符`[]`、`()`、`[()]`中的属性或事件名 | 是引号`""`中的部分或插值符号`{{}}`中的部分
{% endraw %}
访问目标指令中的成员会受到限制，只能绑定到那些显示标记为输入或输出的属性 | 源指令中的每个成员都会自动在绑定中可用，你不需要特别做什么，就能在目标表达式或语句中访问指令的成员,如

```HTML
// UserDetail.component.ts(节选)
<user-detail [user]="currentUser" (deleteRequest)="deleteUser($event)">
</user-detail>
```

`UserDetail.user`和`UserDetail.deleteRequest`都位于绑定声明的左侧，所以它们是绑定的目标。其中，`UserDetail.user`是属性绑定的目标，`UserDetail.deleteRequest`是事件绑定的目标。数据通过模板声明流向`UserDetail.user`目标属性，所以`UserDetail.user`相对`UserDetail`而言是一个输入属性。同样，在事件声明中，数据流出`UserDetail.deleteRequest`目标属性，传递给接收者，所以相对`UserDetail`而言，`UserDetail.deleteRequest`是一个输出属性。输入属性通常接收数据值，输出属性暴露事件生产者，比如`EventEmitter`对象，输入和输出都是从目标指令的视角来说的，比如`UserDetail`。而绑定的组件成员`currentUser`和`deleteUser`位于绑定声明的右侧，所以它们是绑定的源，它们既不是`UserDetail`的输入属性，也不是`UserDetail`的输出属性，仅仅是绑定中的数据源。

#### 声明输入和输出属性

目标属性必须被显示的标记为输入或输出。有两种方式用来声明，但切记不要同时使用。
方式一：通过`@Input`或者`@Output`装饰器

```TS
@Input()  user: User;
@Output() deleteRequest = new EventEmitter<User>();
```

方式二：在指令元数据的`inputs`或`outputs`数组中标记出这些成员。

```TS
@Component({
  inputs: ['user'],
  outputs: ['deleteRequest'],
})
```

#### 输入/输出属性别名

有时需要让输入/输出属性的公开名字不同于内部名字，比如使用属性(Attribute)型指令时。因为在指令类中，直接用指令名字作为属性名通常不是很好，指令名很少能描述这个属性是做什么的。比如：

```HTML
<div (myClick)="clickMessage=$event">click with myClick</div>
```

`myClick`这个指令名对于用来发出`click`消息的属性就算不上一个好名字，而是希望`myClick`绑定了一个名叫`myClick`的事件属性。幸运的是，Angular2可以做到这一点，在外部使用一个公开的名字，同时在内部使用另一个不同的名字，也有两种方法实现。
方式一：通过`@Input`/`@Output`装饰器为属性指定别名

```TS
@Output('myClick') clicks = new EventEmitter<string>(); //  @Output(alias) propertyName = ...
```

方式二：在指令元数据的`inputs`或`outputs`数组中为属性指定别名

```TS
@Directive({
  outputs: ['clicks:myClick']  // propertyName:alias
})
```

## 3.3 局部模板变量
### 3.3.1 作用域

局部模板变量能在DOM元素中使用，能用于Angular2组件。使用中可以在同一元素、兄弟元素或任何子元素中使用模板模板变量。想把谁定义为局部模板变量，只需在其前面加上`#`符号，或者`ref-`前缀。如：

```HTML
<input #phone placeholder="phone number">
<button (click)="callPhone(phone.value)">Call</button>

<input ref-fax placeholder="fax number">
<button (click)="callFax(fax.value)">Fax</button>
```

Angular2会自动把这种变量的值设置为它当前所在的那个元素。如例子中在这个`input`元素上定义了这些变量，把那些`input`元素对象传递给了`button`元素，即它们被当做参数传给了事件绑定中的`call`方法。定义后的局部模板变量可以在当前元素或者子元素中应用该变量。

### 3.3.2 NgForm和局部模板变量

```HTML
<form (ngSubmit)="onSubmit(theForm)" #theForm="ngForm">
  <div class="form-group">
    <label for="name">Name</label>
    <input class="form-control" required ngControl="firstName"
      [(ngModel)]="currentHero.firstName">
  </div>
  <button type="submit" [disabled]="!theForm.form.valid">Submit</button>
</form>
```

在这个例子中，局部模板变量`theForm`出现了三次，中间还隔了一个段的HTML。如果Angular没有接管这个变量，那它可能是个HTML表单元素。但实际上它是个`ngForm`，一个对Angular内建指令`NgForm`的引用。既包装了原生的HTML表单元素又赋予了它额外的“超能力”，如跟踪用户输入的有效性，比如通过检查`theForm.form.valid`就可以禁用提交按钮，以及如何把一个信息量略大的对象传给父组件的`onSubmit`方法。

## 3.4内置指令
老版本的Angular中包含了70多个内置指令，社区贡献了更多。在Angular2中不需要那么多指令。使用更强大、更富表现力的Angular2绑定系统，可以达到同样的效果。如果能用一个简单的绑定来达到目的，为什么还要创建一个指令来处理点击事件？

```HTML
<button (click)="onSave()">Save</button>
```

由于可以从简化复杂任务的指令中获益，Angular2仍然带有内置指令，只是没那么多了。你也可以写自己的指令，但也不会那么多了。

### 3.4.1 NgClass

实际应用中会通过动态添加或删除CSS类的方式来控制元素如何显示。在Angular2中，通过绑定`NgClass`，可以同时添加或移除多个类。
CSS类绑定是添加和移除单个类的最佳途径，如：

```HTML
<!-- 通过isSpecial属性来切换special的开关 -->
<div [class.special]="isSpecial">The class binding is special</div>
```

但当同时添加或移除多个CSS类时，`NgClass`指令会更好一些。应用`NgClass`最好的方式是绑定到一个key:value形式的控制对象，对象中的每个key都是一个CSS类名，如果它的value为true，这个类就被添加，反之被移除。比如有这个一个组件方法`setClasses`，用于管理三个CSS类的状态：

```ts
setClasses() {
  let classes =  {
    saveable: this.canSave,      // true
    modified: !this.isUnchanged, // false
    special: this.isSpecial,     // true
  };
  return classes;
}
```

然后通过添加一个`NgClass`属性绑定，就可以通过调用`setClasses`类设置元素的类了，如：

```HTML
<div [ngClass]="setClasses()">This div is saveable and special</div>
```

### 3.4.2 NgStyle
实际中可以基于组件的状态来动态设置内联样式。绑定到`NgStyle`可以同时设置很多内联样式。
样式绑定是设置单一样式的简单方式，如：

```HTML
<div [style.font-size]="isSpecial ? 'x-large' : 'smaller'" >
  This div is x-large.
</div>
```

如果要同时设置多种内联样式，`NgStyle`指令是更好的选择。与`NgClass`类似，通过把它绑定到一个key:value控制对象的形式使用`NgStyle`。对象的每个key是样式名，它的value就是能用于这个样式的任何值。假设有一个类似于`setStyles`的组件方法，它返回一个定义三种样式的对象：

```TS
setStyles() {
  let styles = {
    // CSS property names
    'font-style':  this.canSave      ? 'italic' : 'normal',  // italic
    'font-weight': !this.isUnchanged ? 'bold'   : 'normal',  // normal
    'font-size':   this.isSpecial    ? '24px'   : '8px',     // 24px
  };
  return styles;
}
```

通过添加一个`NgStyle`属性绑定，让它调用`setStyles`，并据此来设置元素的样式：

```HTML
<div [ngStyle]="setStyles()">
  This div is italic, normal weight, and extra large (24px).
</div>
```
### 3.4.3 NgIf

通过把`NgIf`指令绑定到一个真值表达式，可以把一个元素及其子元素添加到DOM树上。

```HTML
<div *ngIf="currentUser">Hello,{{currentUser.firstName}}</div>
```

相反，绑定到一个假值表达式将从DOM树中移除元素及其子元素。如：

```HTML
<!-- 因为isActive的值为false，所以User Detail不在DOM树种-->
<user-detail *ngIf="isActive"></user-detail>
```

#### 与类绑定/样式绑定的区别

通过类绑定或样式绑定可以实现显示和隐藏一个元素及其子元素。当我们隐藏一个子树时，它仍然会保留在DOM中。子树中的组件及其状态仍然保留着。即使对于不可见属性，Angular也会继续检查变更。子树可能占用相当可观的内存和运算资源。而当`NgIf`为`false`时，Angular从DOM中实际移除了这个元素的子树。它销毁了子树中的组件及其状态，也潜在释放了可观的资源，最终让用户体验到更好的性能。
显示/隐藏技术用在小型元素上可能还不错，但在隐藏大树时就要小心；`NgIf`可能是更好更安全的选择。

### 3.4.4 NgSwitch

当需要从一组可能的元素树种根据条件显示其中一个时，就需要`NgSwitch`了。Angular2将只把选中的元素添加进DOM中。如：

```HTML
<span [ngSwitch]="userName">
  <span *ngSwitchCase="'张三'">张三</span>
  <span *ngSwitchCase="'李四'">李四</span>
  <span *ngSwitchCase="'王五'">王五</span>
  <span *ngSwitchCase="'赵六'">赵六</span>
  <span *ngSwitchDefault>龙大</span>
</span>
```

把作为父指令的`NgSwitch`绑定到一个能返回开关值的表达式，例子中这个值是字符串，但它可以是任何类型的值。父指令`NgSwitch`控制一组`<span>`子元素。每个`<span>`或者挂在一个匹配值的表达式上，或者被标记为默认情况。任何时候，这些span中最多只有一个会出现在DOM中。如果这个span的匹配值和开关值相等，Angular2就把这个`<span>`添加DOM中。如果没有任何span匹配上，Angular2就会把默认的span添加到DOM中。Angular2会移除并销毁所有其他的span。

三个相互合作的指令：
* ngSwitch：绑定到一个返回开关值的表达式
* ngSwitchWhen：绑定到一个返回匹配值的表达式
* ngSwitchDefault：一个用于标记处默认元素的属性
注意：不要再ngSwitch前使用`*`，而应该是属性绑定，而ngSwitchWhen和ngSwitchDefault前面要放`*`。

### 3.4.5 NgFor

`NgFor`是一个迭代器指令。当需要展示一个由多个条目组成的列表时就需要这个指令了。如下面这个例子，就是在一个HTML块上应用`NgFor`。

```HTML
<div *ngFor="let user of users">{{user.fullName}}</div>
```

`NgFor`也可以应用在一个组件元素上，如：

```HTML
<user-detail *ngFor="let user of users" [user]="user"></user-detail>
```

注意`NgFor`前面的`*`。赋值给`NgFor`的字符串并不是一个模板表达式，而是由Angular自己解释的小型语言——一个微语法。在例子中，Angular会取出users数组中的没有user，把它储存在一个局部变量user中，使其在每个迭代中对模板HTML可用。
user前面的let关键字创建了一个名叫user的模板输入变量。在模板中使用这个模板变量来访问user的属性，就像在插值表达式所做的那样。也可以把这个变量传给组件元素上的一个绑定，就像第二个例子中对user-detail所做的那样。

__NgFor中的索引__

`ngFor`指令支持一个可选的`index`索引，在迭代过程中会从0增长到“当前数组中的长度”。可以通过模板输入变量来捕获这个index，并应用在模板中。下面的例子就把index捕获到了一个名为`i`的变量中。

```HTML
<div *ngFor="let user of users; let i=index">{{i + 1}} - {{user.fullName}}</div>
```

##3.5 表单
通过上章节对模板数据绑定的属性绑定和事件绑定的学习，基本能用模版实现大部分的数据展示功能了，但是既然有展示数据，那必需要有数据采集的入口。接下来进一步学习数据采集的入口`表单`。

表单作为数据采集的重要入口，几乎是所有web应用必不可少的一部分，使用场景很广泛，常见的场景有新用户注册，用户登陆、各类数据的添加修改、问卷调查、文件上传等等。html提供了许多表单标签如文本、密码、单选框、复选框等，且内置简单校验，但是内置校验提示效果在各个浏览器表现都不同，校验错误提示文字各异，无法统一，且与应用本身的UI风格相差甚远，其次，自定义校验规则、表单数据获取、处理、提交等流程异常复杂。

针对上述问题，angular团队在angular2中对表单进行了封装扩展，为校验、提示、自定义UI、数据处理等问题提供了很好的解决方案。angular2模版表单能随意控制表单的布局、使用双向绑定数据、设置校验规则、显示自定义校验错误提示、自定义校验错误提示样式效果、根据输入结果开启禁用表单等等。通过angular2表单，可以使用简洁的代码、灵活接口，构建丰富交互体验、强用户引导的表单。
###3.5.1 模版中的表单
angular2有模版驱动(Template-Driven Forms)及模型驱动(Model-Driven Forms)两种方式构建表单，模版驱动模式使用内置表单指令、内置校验，能快速构建简单表单；模型驱动模式使用`FormBuilder`可以自定义表单、自定义校验，能构建灵活、复杂的表单。

首先，来学习模版驱动方式构建表单，以添加、修改联系人的表单为例，构建如图3.5.1及3.5.2的表单。


![MacDown logo](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapters3-5/add-contact-form.png)

图 3.5.1 添加新联系人表单

![MacDown logo](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapters3-5/edit-contact-form.png)

图 3.5.1 修改联系人表单

在添加新联系人表单中，手机联系人的姓名、电话、住址、邮箱、生日等信息，未输入或输入表单值校验不通过，表单右边显示红色竖条，校验通过显示绿色竖条，表单失去焦点后，若表单值校验不通过，显示错误提示信息；所有表单有一个表单值校验不通过，提交按钮禁用，所有表单值校验通过，提交按钮恢复可用，提交保存添加。

在修改联系信息表单中，根据已有的联系人姓名、电话、住址、邮箱、生日等数据，显示在修改表单中，修改信息校验效果与添加联系人一致，校验通过提交保存修改。

###3.5.2 表单指令
在html中使用表单直接使用`<form>`及`<input>`标签，但是如果想创造性的摆放各种控件、把它们绑定到数据、指定校验规则、显示校验错误、有条件的禁用／启用特定的控件、触发内置的视觉反馈等等效果，需要费很大的劲。Angular2提供的表单指令帮我们处理了大多数上诉重复、单调的任务。
####NgForm表单
Angular2表单是Angular2提供的指令`NgForm`，负责处理表单内的页面逻辑，为普通的 form 元素扩充了额外的特性。先来看看在模版中如何使用表单。

通过

```js
import { provideForms } from '@angular/forms';
```
引入`provideForms`组件，在根组件上注入表单的依赖，调用 provideForms()，返回表单的相关服务，将返回的服务结果传给 providers 数组参数，以注册这些新的表单模块。

```js
bootstrap(AppComponent, [provideForms()]);
```
注册完成后就可以在所有的模版中使用Angular2表单`ngModel`、`ngModelGroup `等相关指令及表单校验等表单特性。

```html
<h3 class="nav-bar">添加联系人</h3>
<div class="container">FormComponent
  <form>
  ...
  </form>
</div>
```
通过`providers`数组参数注册了表单模块后，Angular2模版在编译解析时，遇到`form`标签会自动创建一个`ngForm`指令并且关联到对应的`form`标签上。`NgForm`为`form`建立一个控件组对象，作为表单控件的容器；可以通过＃符号定义局部变量contactForm，将contactForm变量初始化为`ngFrom`，来引用该控件组对象,如下：
   
```html
<h3 class="nav-bar">添加联系人</h3>
<div class="container">
  <form #contactForm="ngForm">
  ...
  </form>
</div>
```
此时，可以通过contactForm来控制整个表单及表单组件的有效性，追踪表单组件的状态，contactForm的详细应用，可查看下文表单校验及自定义class小节的讲解。

####NgModel 双向数据绑定

数据绑定有单向数据绑定及双向数据绑定，数据绑定是Angular最具特色的功能。在数据绑定章节，学习了属性绑定、事件绑定及双向数据绑定，现在一起来看下数据绑定在表单中的运用。

构建修改联系人组件，创建一个联系人的数据初始化到联系人修改表单：

```js
@Component({
  selector: 'my-form',
  template: `
  <h3 class="nav-bar">修改联系人</h3>
  <div class="container">
  <form #contactForm="ngForm">
    <ul>
		<li class="form-group" >
		  <label for="name">姓名：</label>
		  <input type="text" class="form-control" name="name"  [ngModel]="curContact.name" >
		</li>
		<li class="form-group" >
          <label for="telNum">电话：</label>
          <input type="text" class="form-control" name="telNum"  [ngModel]="curContact.telNum">
       </li>
		...
		<li class="form-group">
		  <button type="submit" class="btn btn-default">添加</button>
		  <button type="button" class="btn btn-default">取消</button>
		</li>
	</ul>
  </form>
  </div>
  `,
})
export class FormComponent { 
  curContact: any = {
    name: '李四', 
    telNum: '15876352804',
    address: '深圳市中洲控股',
    email: '123455@qq.com',
    birthday: '04-01-01'
  };
}
```
`ngModel`是表单运用中最重要的一个指令，表单几乎所有的特性都依赖`ngModel`指令完成。在表单中使用`ngModel`，必需通过给表单添加name属性，如`name="name"`否则会报错。
上述例子中，[ngModel]="curContact.name"将curContact对象中的name绑定到input表单上，页面表单上显示的数据正是curContact中对应的数据。

当表单页面改变输入值时，curContact.name值是否改变？在表单中添加p标签，实时显示curContact.name的值：

```html
...
<li class="form-group" >
  <label for="name">姓名：</label>
  <input type="text" class="form-control" name="name"  [ngModel]="curContact.name">
  <p>{{curContact.name}}</p>
</li>
...
```
当表单页面改变输入值时，p标签中curContact.name值并不会改变；那相反，直接在组件中修改模型的curContact.name值呢？
在表单中添加一个切换按钮，用于切换组件模型中的curContact.name值

```js
@Component({
  selector: 'my-form',
  template: `
  ...
  <li class="form-group">
	  <button type="submit" class="btn btn-default">添加</button>
	  <button type="button" class="btn btn-default">取消</button>
	  <button type="button" class="btn btn-default" (click)="changeName()">切换</button>
  </li>
  ...
  `,
})
export class FormComponent { 
  curContact: any = {
  	name: '李四', 
  	telNum: '15876352804',
  	address: '深圳市中洲控股',
  	email: '123455@qq.com',
  	birthday: '04-01-01'
  };
  changeName(){
    this.curContact.name = "张三";
  }
}
```

当点击切换按钮时，在数据模型中改变curContact.name值为"张三"后，表单页面显示的值也跟着变成"张三"，因`[]`实现的是单向绑定，即从组件数据模型中修改的数据能触发视图中的数据改变，但是在视图中修改的数据，不能反应到组件模型中。在纯粹展示数据但不需要修改数据的表单中，可以使用`［］`将模型中的数据绑定到表单视图。

在常用开发场景下，一般都希望当绑定到表单的组件模型数据能显示在表单上，同时当表单上的数据变更时，也需要同步到组件模型数据里。这时候需要数据能双向流通，Angular里引入一种新`NgModel`语法来支持数据绑定，`[()]`能帮助更便捷的进行双向绑定。
   
``` html
<input type="text" name="name" [(ngModel)]="curContact.name">
```
`[]`是实现数据流从组件数据源到模板，而`()`是实现从模板到数据源，把这两者合起来`[()]`就是双向绑定的语法，即属性绑定和数据绑定的结合。此时在页面中输入姓名为"张四"，组件数据模型中curContact.name值也变为"张四"，点击“切换”按钮，修改组件数据模型curContact.name值为"张三"，页面中姓名实时变更显示为"张三"，同时，contactForm.value中的name也被同步修改为"张三"，因此提交时只需提交contactForm.value，避免很多逻辑处理。

`ngModelChange`是`NgModel`指令的事件属性。当Angular在表单中看到一个`[(x)]`的绑定目标时，`x`指令会有一个名为`x`的输入属性，和一个名为`xChange`的输出属性。同理，Angular当遇到`[(ngModel)]`时会翻译成一个`ngModel`的输入属性和一个`ngModelChange`的输出属性，自动地完成了属性绑定和事件绑定。因此，也可以用下面两种方法实现双向绑定，三者效果是一样。

``` html
<input type="text" class="form-control" name="name" bindon-ngModel="curContact.name">
<input type="text" class="form-control" name="name" [ngModel]="curContact.name" (ngModelChange)="curContact.name = $event">
```
模板表达式中值得注意的是`model.name = $event`,我们以前看到的`$event`变量是来自 DOM 事件的， 但 ngModelChange 是一个 Angular EventEmitter 类型的属性，不会生成 DOM 事件，当它触发时，返回的是输入框的值，因此`[ngModel]="curContact.name" (ngModelChange)="curContact.name = $event"`,恰好能实现双向数据绑定。

不可否认，Angular2`[()]`双向数据绑定的处理确实很方便，让开发者在开发过程中，避免考虑很多的问题。然而有时候并不希望这种自动化的处理，在复杂的数据绑定场景，更希望定制化的输入输出控制，例如需要把用户输入的内容首字母变成大写字母，此时可以将属性绑定跟数据绑定进行拆分：

```html   
  <input [ngModel]="curContact.name"  (ngModelChange)="setUpperCaseFirstName($event)">
```

```js
export class FormComponent { 
  setUpperCaseFirstName(value){
  	//此处实现将首字母变大写
  }
}
```
在比较通用的业务场景里，[(ngModel)]可以使代码变得更简洁，若是复杂的数据处理，可以通过展开成属性绑定和事件绑定对数据进行特殊处理。

上面介绍了表单text的双向数据绑定，接下来学习其他常用表单类型的双向数据绑定如何实现。

#####number 数值表单
number的用法与text用法一致

```html
<li class="form-group" >
  <label for="telNum">电话：</label>
  <input type="number" class="form-control" name="telNum"  [(ngModel)]="curContact.telNum">
</li>
```
电话号码格式为数组，表单类型设为`number`，在移动端方便调起数字键盘，且输入仅允许数字，输入其他字符无效。

#####radio 单选框
radio实现单选框选择功能，同样实现了双向数据绑定

```html
<li class="form-group" >
  <label for="sex">性别：</label>
  <input type="radio" class="form-control" name="sex" [(ngModel)]="curContact.sex" value="female">女
  <input type="radio" class="form-control" name="sex" [(ngModel)]="curContact.sex" value="male">男
</li>
```
上述例子中是一个选择性别的单选框，男和女单选框的`ngModel`绑定的是同一个值`curContact.sex`，当点击“女”单选框，`curContact.sex`会被赋值为“女”单选框对应value属性值“female”，同理，当点击“男”单选框，`curContact.sex`会被赋值为“男”单选框对应value属性值“male”。若性别单选框需要设置默认值，如设置默认选中“男”单选框，可以在组件中给curContact.sex设置初始值为"男"单选框对应得value属性值，即`curContact.sex = 'male'`。

#####select 下拉框
select实现下拉单项选择功能，以构建兴趣爱好下拉选择框为例，学习Angular下拉选择框的用法。构建兴趣爱好列表数据如下：

```js
export class FormComponent { 
  ...
  let interests:any[] = [
   { value: 'reading', display: '阅读' },
   { value: 'traveling', display: '旅游' },
   { value: 'sport', display: '运动' }
  ];
}
```
Angular的单选下拉框由`NgSelectOption`指令实现，有两种用法，一种是选中返回的是基本类型数据，另一种选中返回的是对应选中的数据对象。

单选选中返回的数据是基本类型：

```html
<select name="interest" [(ngModel)]="curContact.interest">
  <option *ngFor="let interest of interests" [value]="interest.value">  
   {{interest.display}}
  </option>
</select>
```
例子中使用`[value]`绑定单选项option的value属性值，输入的是单项兴趣对象的value属性对应得值。假若在下拉框中选中旅游项，则`curContact.interest` 值为“traveling”。

单选选中返回的数据是对象：

```html
<select name="interestObj" [(ngModel)]="curContact.interestObj">
  <option *ngFor="let interest of interests" [ngValue]="interest">  
    {{interest.display}}
  </option>
</select>
```
例子中使用`[ngValue]`绑定单选项option的value属性值，输入的是单项兴趣的整个对象。假若在下拉框中选中旅游项，则`curContact.interestObj` 值为`{ value: 'traveling', display: '旅游' }`。
Angular的单选下拉框的两种用法唯一不同的是单选项option的value属性值的绑定，当绑定使用`[value]`时，表示接收的是基本类型的输入绑定，此时需使用基本类型变量作为输入值，当绑定使用`[ngValue]`时，表示接收的是复杂类型的输入绑定，此时可使用对象变量作为输入值，选择下拉框的其中一项，返回的`[(ngModel)]`的值为选中的option对应得value输入值，输入的是基本类型，则得到的是基本类型，输入的是对象，则得到的也会是对象。

#####Multiple select 多选下拉框
Multiple select实现下拉多项选择功能，多选下拉框的用法与单选下拉框类似，不同的是多选下拉框返回的数据都是数组。

多选下拉框选中返回的数据是数组基本类型：

```html
<select multiple name="interestMul" [(ngModel)]="curContact.interestMul">
  <option *ngFor="let interest of interests" [value]="interest.value">  
    {{interest.display}}
  </option>
</select>
```
多选下拉框与单选下拉框相同，使用`[value]`绑定单选项option的value属性值，输入的是单项兴趣对象的value属性对应得值，相对单选下拉框多了`multiple`指令属性。假若在多选下拉框中选中旅游和运动两项，则`curContact.interestMul`返回值为`["traveling","sport"]`。

多选下拉框选中返回的数据是数组对象：

```html
<select name="interestMulObj" [(ngModel)]="curContact.interestMulObj">
  <option *ngFor="let interest of interests" [ngValue]="interest">  
    {{interest.display}}
  </option>
</select>

```
例子中与单选下拉框相同，使用`[ngValue]`绑定单选项option的value属性值，输入的是单项兴趣对象的值，相对单选下拉框多了`multiple`指令属性。假若在多选下拉框中选中旅游和运动两项，则`curContact.interestMulObj`返回值为`[{ value: 'traveling', display: '旅游' },{ value: 'sport', display: '运动' }]`。

>值得注意的是，rc3版本，多选下拉框支持还不全面，经测试，多选下拉框在pc chrome中，选择需按住鼠标才能选择多个，在android中多选选择无效，在使用时需谨慎测试。

#####Checkbox复选框
Angular复选框选中与否，得到的值是布尔值，表示该复选框表单是否选中。

```html
<li>
  <input type="checkbox" name="lock" [(ngModel)]="curContact.lock">禁用
</li>
```
上述例子中，复选框选中`contactForm.value.lock`及`curContact.lock`都为true，未选中则为false。对于通过勾选复选框实现其他表单禁用、启用等，返回布尔值十分有优势。

但是如果需要通过复选框来收集有意义的数据，就需要获取选中的复选框对应得value值，此时可以通过巧妙的方式实现。构建一个隐藏的表单`interestCheckbox`，用于存放复选框选中的值，添加复选框表单change事件，通过`$event.target.checked`获取该复选框是否被选中，设置选中时的值及未选中的值，如下：

```html
<li>
   <label>兴趣爱好(复选框)</label>
   <input type="hidden" name="interestCheckbox" [(ngModel)]="curContact.interestCheckbox">
   <input type="checkbox"  (change)="setInterestCheckboxValue($event.target.checked,'reading')">阅读
   <input type="checkbox"  (change)="setInterestCheckboxValue($event.target.checked,'traveling')">旅游
   <input type="checkbox"  (change)="setInterestCheckboxValue($event.target.checked,'sport')">运动
</li>
<li>选中复选框的值：{{curContact.interestCheckbox|json}}</li>
```

```js
export class FormComponent { 
  public curContact = {
  	interestCheckbox:[] 
  };
  setInterestCheckboxValue(checked,value){
    let index:number = this.curContact.interestCheckbox.indexOf(value);
    if(checked){
      if(index < 0){
        this.curContact.interestCheckbox.push(value);
      }
    }else{
      if(index > -1){
        this.curContact.interestCheckbox.splice(index,1);
      }
    }
  }
}
```
例子中，当点击复选框时，触发setInterestCheckboxValue方法并将`$event.target.checked`及复选框对应的value值作为参数传入。当该复选中被选中，且`curContact.interestCheckbox`中还没有value对应得值时，将value值push进curContact.interestCheckbox数组中。当该复选框被取消选中时，且`curContact.interestCheckbox`中存在value对应得值时，将value值从curContact.interestCheckbox数组中移除。curContact.interestCheckbox双向绑定到hidden表单中，因此，提交hidden表单中的值就相当于提交复选框的值。

**表单中的局部变量**
在`NgForm`章节中，定义了局部变量contactForm，表单加入`ngModel`及`name`属性后，#contactForm局部变量value属性值的最大作用也得以体现，此时可获取contactForm.value的值为：

```js
{
	name: undefined,
	telNum: undefined,
	address: undefined,
	email: undefined,
	birthday: undefined
}
```
contactForm.value属性是一个简单的JSON对象，键对应`input`元素的`name`属性值，值对应于`input`元素的值。 此时值都为`undefined`,因为表单还未输入任何值，当往表单输入姓名`李四`，输入电话`12345678901`，再获取contactForm.value的值为：

```js
{
	name: '李四',
	telNum: '12345678901',
	address: undefined,
	email: undefined,
	birthday: undefined
}
```
对应name字段值由`undefined`变为输入的'李四',对应telNum字段值由`undefined`变为输入的`12345678901`。对于AJAX请求提交表单采集的数据，这无疑是令人兴奋的功能，直接将contactForm.value提交即可，不需要自己构建JSON对象，非常简洁方便。

在`NgForm`中，定义了局部变量#contactForm，同理，在input上也可以定义局部变量，添加#name="ngModel"

```html
<input type="text" class="form-control"  name="name" [(ngModel)]="curContact.name"  #name="ngModel">
```
Angular2会将局部变量#name初始为`NgModel `，值得注意的是`form`表单中也定义了局部变量#contactForm="ngForm"。 ＃contactForm为`NgForm`指令，是`NgForm`实例对象的引用，#name为`ngModel`指令，是`ngModel`实例对象的引用。因为Angular2是通过指令的`exportAs`值，与对应的指令对象关联起来的，`NgForm`指令的`exportAs`值为`ngForm`，`NgModel`指令的`exportAs`值为`ngModel `，因此，在表单中赋值有区别。

回顾模板局部变量章节中介绍的局部变量，定义#nameDom局部变量

```
<input type="text" class="form-control" name="name" [(ngModel)]="curContact.name"  #name="ngModel"  #nameDom >
```
与#name相比，#nameDom局部变量直接定义变量但不赋值，两者引用是否一样呢？ #nameDom与#name都是定义在同一个`input`上的局部变量，但两者是完全不同的引用对象。#name为`NgModel`实例对象的引用，记录表单状态及校验结果；#nameDom为Dom节点变量引用，引用`input`本身，为`input`的标准Dom对象，可以在表单中使用#nameDom获取Dom自身的属性，如查看表单对应的样式类名#nameDom.className或者表单的高度等#nameDom.height。

**ngModelGroup**

`ngModelGroup`指令是Angular提供的另一特色指令，可以对表单输入内容进行分组，方便我们在语义上区分不同性质的输入。例如联系人的信息包括姓名及住址，现在需对姓名和住址进行精细化信息收集，姓名可精细化成姓和名字，地址可精细化成城市、区、街等，此时就可以将姓名及住址进行分组收集，如下：

```html
<form #concatForm = "ngForm">
  <fieldset ngModelGroup="nameGroup"  #nameGroup="ngModelGroup">
    <label>姓:</label>
    <input type="text" name="firstname" [(ngModel)]="curContact.firstname" required>
    <label>名字:</label>
    <input type="text" name="lastname" [(ngModel)]="curContact.lastname" required>
  </fieldset>
  <fieldset ngModelGroup="addressGroup"  #addressGroup ="ngModelGroup">
    <label>街:</label>
    <input type="text" name="street" [(ngModel)]="curContact.street" required>
    <label>区:</label>
    <input type="text" name="zip" [(ngModel)]="curContact.zip" required>
    <label>城市:</label>
    <input type="text" name="city" [(ngModel)]="curContact.city" required>
  </fieldset>
</form>
```
上述例子分别对联系人的姓名和住址进行分组，`ngModelGroup`将姓和名字的表单内容进行包裹组成姓名分组，将住城市、区和街道的表单内容进行包裹组成住址分组。此时concatForm.value值为（concatForm.value表单中的局部变量）：

```js
{
  nameGroup: {
    firstname: '',
    lastname: '',
  },
  addressGroup: {
    street: '',
    zip: '',
    city: ''
  }
}

```
由此可见concatForm.value值也被相应分组展示，这样既收集到精细化的姓名及住址数据，也可以很方便地通过精细化的姓名及住址数据组合成完成的姓名及住址数据。
同时`ngModelGroup`实例对象的valid可单独校验`ngModelGroup`下的所有`ngModel`表单是否合法。如当firstname输入合法，lastname输入不合法，姓名分组局部变量#nameGroup.valid为false，当firstname、lastname输入都合法，姓名分组局部变量#nameGroup.valid为true。
>`ngModelGroup`指令必需作为`NgForm`的孩子使用。


**追踪表单状态及数据校验**

Angular表单提供表单状态追踪及数据校验功能，当在表单中使用`ngModel`，表单控件通过`FormControl`注册建立一个控件对象，并加入到`NgForm`指令建立的控件组中，受`NgForm`监控，该指令会追踪表单的状态，如用户碰过此控件吗？它的值变化了吗？数据变得无效了吗？

如何追踪表单的状态呢？表单`NgForm`指令及`FormControl`指令都有有5个表示状态的属性，属性值为布尔类型，`NgForm`指令状态追踪的是整个Form表单的状态，`FormControl`指令追踪的是input表单的状态。先看表单状态属性值对应的状态：

表 3-5-1   表单状态
 
| 状态          | true          |  false     |
|------------  |:-------------:| -----------:|
| valid        | 表单值有效      | 表单值无效   |
| pristine     | 表单值未改变    | 表单值已改变  |
| dirty        | 表单值已改变    | 表单值未改变  |
| touched      | 表单已被访问过  | 表单未被访问过 |
| untouched    | 表单未被访问过  | 表单已被访问过 |

接下来，以姓名表单为例，给name表单添加required属性`<input type="text" name="name" [(ngModel)]="curContact.name" required>`，对姓名表单进行获取焦点、输入、删除输入等操作，观察表单每一步操作的状态变化。

还未对表单进行操作前，表单的初始状态如图3-5-2。表单还未进行任何输入，值未改变过，表单`pristine`为true，`dirty`为false；表单添加了required属性，表单校验不通过，`valid`值为false；表单未被访问过，`touched`为false，`untouched`为true。

表 3-5-2   表单初始状态

| 状态          | true  |  false  |
|------------  |:-----:| -------:|
| valid        |      |   √       |
| pristine     | √     |        |
| dirty        |      | √ |
| touched      |      | √  |
| untouched    | √     |  |

在表单中输入任意字符，状态如图3-5-3。表单值被改变，表单`pristine`为false，`dirty`为true；表单有值，满足required要求，校验通过，`valid`值为true；因表单还未失去焦点，还处于未访问过状态`touched`为false，`untouched`为true。

表 3-5-3   表单输入后的状态

| 状态          | true  |  false  |
|------------  |:-----:| -------:|
| valid        | √     |        |
| pristine     |     | √       |
| dirty        | √     |   |
| touched      |      | √  |
| untouched    | √     |  |

使表单失去焦点，处于已访问过状态`touched`为true，`untouched`为false，状态如图3-5-4。

表 3-5-4   表单失去焦点后的状态

| 状态          | true  |  false  |
|------------  |:-----:| -------:|
| valid        | √     |        |
| pristine     |      | √       |
| dirty        | √     |   |
| touched      | √      |   |
| untouched    |     | √  |

由此可见，根据表单的状态属性，可以精确的追踪表单所处的状态，根据不同的状态，可以对不同状态场景下的表单进行特定的样式或者逻辑处理。


**NgSumit 提交表单数据**

当表单的提交按钮type为`submit`时，提交按钮被点击，会触发`form`标签中添加的`NgSubmit`事件，并执行绑定到组件的`onSubmit`方法，同时将contactForm.value的值作为参数，传入`onSubmit`方法中，在`onSubmit`方法中实现数据处理及上传。

```html
<form #contactForm="ngForm" (ngSubmit)="onSubmit(contactForm.value)">
 ...
 <li class="form-group">
    <button type="submit" class="btn btn-default" >添加</button>
 </li>
</form>
```
在许多应用场景中，往往会接触到表单未输入完且未完全输入正确的场景下，提交按钮是灰置并且不能点击的，避免无效的点击和请求，减轻服务器的负载。这样的场景，在Angular2是怎么实现的呢？

```html
<button type="submit" class="btn btn-default" [disabled]="!contactForm.form.valid">添加</button>
```
上述例子中只添加了`[disabled]="!contactForm.form.valid"`，绑定提交按钮的`disabled`属性,当输入表单值全部检验通过时contactForm.form.valid为true，相反，如果有其中一个或多个表单值校验不通过，contactForm.form.valid为false，这样就可以达到在未完全输入正确的数据时，提交按钮不能点击的效果，只需添加短短的一条代码就实现了上述的复杂逻辑。

###3.5.3 用户自定义class
在`NgModel`中介绍了`NgModel`指令在对数据收集方面的应用及追踪表单状态的内容。下面来学习`NgModel`指令表单状态的改变在自定义表单样式方面的应用。

`NgModel`不仅仅能追踪表单控件状态，还会根据表单控件的状态，使用对应得css状态类来更新控件类名，反映表单当前的状态。状态样式类详细如表3-5－5

 表 3-5-5   表单状态类名

| 状态          | 为true时的css类| 为false时的css类|
|------------  |:-------------:| --------------:|
| 控件已经被访问过| ng-touched    | ng-untouched|
| 控件值已经变化  | ng-dirty      | ng-pristine |
| 控件值是有效的  | ng-valid      | ng-invalid  |

同样以姓名表单为例，给name表单添加required属性，对姓名表单进行获取焦点、输入、删除输入等操作，观察表单每一步操作的状态样式类变化。

未进行任何操作前，表单初始状态下样式类为：

```html
<input class="form-control ng-invalid ng-dirty ng-touched" [(ngModel)]="curContact.name" name="name" type="text" required>
```
在表单中输入任意字符，类`ng-pristine`被修改为`ng-dirty`,类`ng-invalid`被修改为`ng-valid`:

```html
<input class="form-control ng-untouched ng-dirty ng-valid" [(ngModel)]="curContact.name" name="name" type="text" required>
```
表单失去焦点，类`ng-untouched`被修改为`ng-touched`

```html
<input class="form-control ng-touched ng-dirty ng-valid" [(ngModel)]="curContact.name" name="name" type="text" required>
```
删除表单中的内容，类`ng-valid`被修改为`ng-invalid`:

```html
<input class="form-control ng-touched ng-dirty ng-invalid" [(ngModel)]="curContact.name" name="name" type="text" required>
```

表单状态类名变化与表单的状态属性变化一致，详情可看`NgModel`中的表单追逐部分内容。有了这些代表表单状态的表单类名，我们可以自定义类名中的样式，实现自定义效果，如：
    
```style
.ng-valid[required] { 
  border-left: 5px solid #0f0; 
}
.ng-invalid {
  border-left: 5px solid #f00; 
}
```
该样式自定义了用户输入表单数值且输入表单值有效时的表单样式边框为绿色，表单输入无效时的表单边框为红色，同理，我们可以根据这些表单状态类自定义出更加丰富的表单交互效果。
通过表单类名自定义样式可以在视觉上给予用户反馈，当表单输入不合法时，用户可以在视觉上感知输入错误，但是用户可能无法得知输入为什么不合法，如何纠正，在这种场景下可以添加有用的错误提示来对用户进行强引导。此时，可以配合表单的状态属性valid、pristine、dirty、touched、untouched等值，设置错误提示的显示与隐藏。

```html
<div class="form-group">
    <label for="name">姓名</label>
    <input type="text" class="form-control" minlength=3 maxlength=10 [(ngModel)]="curContact.name" name="name" #name="ngModel" required >
    <p [hidden]="name.valid || name.pristine" class="alert alert-danger">
      用户名长度为3-10个字符
    </p>
</div>
```
根据表单状态属性值,当表单在初始状态时，不显示错误提示；当表单输入值是有效时，不显示错误提示；当表单输入无效时，显示错误提示。


###3.5.4 表单验证（Validation）
表单提交的数据被送往服务器后，服务器需要对表单数据进行数据校验，校验数据格式是否满足设定要求、过滤xss字符串等等。若在服务器数据校验不合法需向前端进行不合法的数据反馈，在网络差的环境下，用户等待很长的时间，结果返回的是数据不合法的结果，还需要继续修改表单，再进入第二次等待。

表单校验是前端对表单的输入值进行检查，检查表单输入值是否满足设定的规则，不满足设定的规则，立即响应给用户。html5表单内置基础校验，但基础校验使用不灵活，且各个平台校验提示效果不统一，往往需要借助其他的插件。Angular2表单对校验进行的封装，提供了灵活的接口，在上述问题上有很大的优势。本节将详细介绍angular2支持的内置表单校验及自定义校验。

####内置表单校验

angular2支持的内置验证包括：

* **required**: 限制表单控件值不能为空
* **minlength**: 限制表单控件值的最小长度
* **maxlength**: 限制表单控件值的最大长度
* **pattern**:  限制表单控件值必需匹配正则

原生Html5支持简单的校验拦截，但是提示样式及文本是固定的，不可控，屏蔽原生html5的校验，可以在`form`中添加`novalidate`属性

```html
<form #contactForm="ngForm" (ngSubmit)="onSubmit(contactForm)" novalidate>
```
此时点击提交按钮，Html5的校验拦截不生效，直接触发onSubmit方法，可以在该方法中进行自定义校验。


####自定义校验

angular2提供的内置表单校验基本能满足大部分校验场景，倘若需要实现复杂的表单校验，可以使用Angular2提供的自定义校验。

在学习自定义校验前，先学习如果使用模型驱动模式构建表单，先引入`FormBuilder`

```js
import {FormBuilder}    from '@angular/common';
import {REACTIVE_FORM_DIRECTIVES, FormControl, FormGroup} from '@angular/forms';
```
注入`FormBuilder`后，在组件constructor中传入`FormBuilder`参数fb,同时使用fb.group方法构建`FormGroup`实例变量customForm，customForm也可以简单定义为form,此处命名为customForm是为了区分上面内置指令，能更容易理解如何构建自定义表单。

```js
export class FormComponent { 
  customForm: FormGroup;
  constructor(fb: FormBuilder) {  
    this.customForm = fb.group({
      'customName': ['李四']
    });  
  }
}
```
在这个例子中，通过fb.group中传人的对象创建了`control`指令对象customName,并添加到`FormGroup`中，customName值为['李四'],即control的默认值为'李四'，为什么这里定义的值是数组，而不是字符串呢？因为还有其它属性可以配置，下面详细讲解。
在模版中使用自定义表单`customForm`:

```js
@Component({
  selector: 'my-form',
  directives: [REACTIVE_FORM_DIRECTIVES]
  template: `
  <h3 class="nav-bar">修改联系人</h3>
  <div class="container">
  <form [formGroup]="customForm" (ngSubmit)="onSubmit(customForm.value)" novalidate></form>
  </div>
  `,
})
```
在使用自定义表单前，需在装饰器`@Component`添加`directives: [REACTIVE_FORM_DIRECTIVES]`，在内置NgForm小结中讲到，angular2遇到`form`标签会自动创建一个`ngForm`指令并且关联到对应的`form`标签上。这里是一个特例，当`form`标签上使用`formGroup `属性时，相当于告诉angular2不需自动创建一个`ngForm`指令，直接使用已经存在的`formGroup`指令对象customForm。同时在提交时使用的contactForm.value也使用customForm.value替换.

在FormComponent中创建了`control`指令对象customName,在`input`表单中使用已经存在的`control`，表单的`name`、`ngModel`属性为组件中定义的`Control`指令对象名customName，告诉angular2将customName控制器指令绑定到`input`表单中：

```html
<form [ngFormModel]="customForm" (ngSubmit)="onSubmit(customForm.value)" novalidate>
 <li class="form-group" >
  <label for="name">姓名</label>
  <input type="text" class="form-control"  name="customName"  [(ngModel)]="customName">
 </li>
 ...
</form>
```

如何添加自定义校验呢？回顾上面构造`control`指令时值为什么是数组的问题，是因为要保留添加自定义校验的配置：

```js
import { Validators} from '@angular/forms'
this.customForm = fb.group({
    'customName': ['李四',Validators.required]
}); 
```
内置校验是`Validators`组件实现的，使用时需import `Validators`组件. 添加Validators.required与直接在`input`表单元素中添加required属性是一样的效果。

现定义用户名的校验规则，如用户名必需是邮件格式或者是手机号码格式，若表单值不满足该校验规则，则返回userName的错误信息，满足返回null.

```js
function validateUserName(c: Control) {
  let EMAIL_REGEXP = new RegExp("[a-z0-9]+@[a-z0-9]+.com");
  let Tel_REGEXP = new RegExp("1[0-9]{10}");
  return (EMAIL_REGEXP.test(c.value) || Tel_REGEXP.test(c.value)) ? null : {
    userName: {
      valid: false,
      errorMsg: '用户名必需是正确的手机号或者邮箱账号'
    }
  };
}
```
为用户名添加自定义校验

```js
this.customForm = fb.group({
  'customName': ['李四', validateUserName]
}); 
```
在返回的userName中添加错误提示信息,可以准确的显示错误提示，userName在Control实例对象的errors属性中；

```html
<li class="form-group">
  <label for="name">姓名</label>
  <input type="text" class="form-control" name="customName"  [(ngModel)]="customName"  #localName="ngModel">
  <p *ngIf="localName.valid || !localName.pristine" class="alert alert-danger">
    {{localName.errors.userName.errorMsg}}
  </p>
</li>
```
>注：在`NgModel`小节中，表单的局部变量名与name属性名可以重复，但在自定义表单这里的局部变量#localName与定义的`Control`指令名称不能重复，否则会报错。

如果想在一个表单中添加多个校验，可以使用Validators.compose:

```js
this.customForm = fb.group({
    'customName': ['李四', Validators.compose([Validators.required, validateUserName])]
}); 
```
此时如果表单未输入任何值，或者输入值不是邮件格式或者是手机号码格式的，不同时满足两个校验规则，customName.errors为：

```js
{
	required:true,
	userName: {
      valid: false,
      errorMsg: '用户名必需是正确的手机号或者邮箱账号'
    }
}
```
可以根据errors内容进行强引导的错误提示文字，当未输入过时，不显示错误提示，当输入错误的用户名时，显示自定义错误信息，当再清空输入值时，显示“请填写用户名”

```html
<li class="form-group">
  <label for="name">姓名</label>
  <input type="text" class="form-control" name="customName"  [(ngModel)]="customName"  #localName="ngModel">
  <p *ngIf="localName.errors && localName.errors.userName && !localName.errors.required" class="alert alert-danger">
    {{localName.errors.userName.errorMsg}}
  </p>
  <p *ngIf="localName.errors && localName.errors.required && !localName.pristine" class="alert alert-danger">
    请填写用户名
  </p>
</li>
```

>补充说明，在上面的例子中定义局部变量#localName引用`ngModel`指令，同时在模型驱动构建的表单中，创建customForm控件后,在组件上添加`control`实例对象：

>```js
  this.customNameControl = this.customForm.controls['customName']; 
```

>需要注意的是this.customNameControl为`control`实例对象，而局部变量#localName为`NgngModel`指令实例，但与#localName一样，可以在模版上使用valid进行校验错误提示。#localName获取对应的`control`实例对象可通过#localName.control。

另外，我们还可以通过表单状态给表单添加需要的class类名，处理更丰富的样式、提示等

```html
<div class="form-group" [class.pass]= "customForm.controls['customName'].valid">
  <label for="name">姓名</label>
  <input type="text" class="form-control" name="customName"  [(ngModel)]="customName"  #localName="ngModel">
</div>
```
当表单验证通过时添加pass的class类，通过pass类可以同时改变label、input标签的样式。

下面再补充介绍如何使用模型驱动模式构建常用表单number、radio等

```js
this.customForm = fb.group({
    'sex': ['',Validators.required],
    'telNum': ['',Validators.required],
}); 
```
在group中创建性别`Control`控件和电话号码`Control`控件，且都为必填。
在模版中使用控件如下所示：
```html
<li class="form-group" >
	<label for="sex">性别：</label>
	<input type="radio" class="form-control" name="sex" [(ngModel)]="sex" value="female">女
	<input type="radio" class="form-control" name="sex" [(ngModel)]="sex" value="male">男
</li>
<li>
  <label for="telNum">电话号码：</label>
  <input type="number" class="form-control" name="telNum"  [(ngModel)]="telNum">
</li> 
```
同理，使用模型驱动模式构建复选框、单选下拉框及多选下拉框时，先构建对应的`Control`控件，`Control`控件可自定义一种或者多种校验方式，再将`Control`控件应用到模版对应的复选框、单选下拉框活着多选下拉框表单中，就能实现自定义校验的表单。


###表单小结
Angular2表单使用下列表单特性实现表单数据修改、验证和更多操作：

* Angular HTML 表单模板。
* 带有 Component 装饰器的组件类。
* 处理表单提交的 ngSubmit 指令。
* 模板引用变量，如 #concatForm 、 #name 、 #nameDom的区别及用法 。
* 双向数据绑定、数据验证和表单状态变化追踪的 [(ngModel)] 语法
* 指向 input 控件的引用变量上的 valid 属性，可用于检查控件是否有效、是否显示/隐藏错误信息。
* 通过绑定到 NgForm 的有效性状态，控制提交按钮的禁用状态。
* 对无效控件，定制CSS类来给用户提供视觉反馈
* 使用`FormBuilder`模型方式构建表单及自定义校验


##3.6 管道（pipes）
管道是用于将模版内的数据转换成用户能快速识别的数据来显示。如日期数据，对于用户来说，只需要看日期信息，而日期的原始数据为Mon Jun 06 2016 14:17:00 GMT+0800 (CST)，这样的展示不直观，用户需要自己对原始数据进行转换后才能得到想要的日期信息，用户更喜欢直接看到转换后的日期信息2016-06-06。再如，知道活动的开始时间，在页面中需要展示活动还有多长时间开始的倒计时，这时需要通过活动的开始时间及现在时间的计算得到倒计时，再显示到页面。angular2管道可以很优雅的在模版中使用逻辑，在模版中执行一个函数获取其返回值。管道使得代码更清晰，更有层次。

###3.6.1 管道的用法
在进行前端视图数据展示时，往往会发现接口返回的数据只是单单一个数值，并不是我们页面展示需要的格式，而该接口可能会提供多个平台使用以及方便后台复杂的逻辑计算，接口也不会对数组进行对应得格式化再返回，因此这就需要前端自力更生了。angular提供了管道，将接口返回的数值进行特定格式化后再显示到模版html中，接下来看下管道的用法。

####管道参数
管道使用管道操作符`|`，将获取到的原始数据作为输入数据，将转换后的期望数据作为输入，显示在模版中。下面将生日数据转换成用户友好的展示方式：

```js
@Component({
  selector: 'my-app',
  template: `
    <p>The hero's birthday is {{ birthday | date }}</p>
  `,
})
export class AppComponent { 
   birthday = new Date(1990,3,15);
}
```
在例子中，展示友好的生日日期是通过管道操作符`|` 右边的`Date`管道来实现的。输出结果为`The heros birthday is Apr 15, 1990`

可以将日期以固定格式输出，使用`:`给管道添加参数：

```html
<p>The hero's birthday is {{ birthday | date:"MM／dd/yyy" }}</p>
```
输出值为`The heros birthday is 04/15/1990`

管道参数的值可以是任意合法的模板表达式，如字符串或者属性组件等，也就是说，可以通过绑定控制参数格式来控制生日的值。

```js
@Component({
  selector: 'my-app',
  template: `
  <p>The hero's birthday is {{ birthday | date:format }}</p>
  <button (click)="toggleFormat()">切换日期格式</button>
  `,
})
export class AppComponent { 
  birthday = new Date(1990,3,15);
  toggle = true; // start with true == shortDate
  get format()   { return this.toggle ? 'shortDate' : 'fullDate'}
  toggleFormat() { this.toggle = !this.toggle; }
}
```
模版中添加一个切换日期格式的按钮，点击按钮时，日期格式在'shortDate'及'fullDate'中切换，对应显示的日期格式在‘4/15/1990’及‘Sunday, April 15, 1990’中切换。

####链式管道

我们可以使用链式管道将多个管道应用在同一个数据上，展示更丰富的数据格式。

```js
{{ expression | pipeName1 | pipeName2}}
```
expression值通过管道pipeName1处理后返回处理后的结果expression2，expression2再通过pipeName2管道处理，输出链式管道处理的最终结果.

```html
<p> The chained hero's birthday is {{ birthday | date | uppercase}} </p>
```
birthday链到`DatePipe`和`UpperCasePipe`上,将日期显示为大写`APR 15, 1990`

如果通过参数来过滤，那么可以通过括号来控制编译的顺序，下面的例子将显示SUNDAY, APRIL 15, 1990

```html
<p> The chained hero's birthday is {{ birthday | date:'fullDate' | uppercase}} </p>
```
也可以通过括号来区分优先级或者让表达式更新清楚

```html
<p> The chained hero's birthday is {{ ( birthday | date:'fullDate' ) | uppercase}} </p>
```

####管道内置指令

angular2内置许多管道指令，例如`DatePipe`, `UpperCasePipe`, `LowerCasePipe`, `CurrencyPipe`及`PercentPipe`, 不需要import，可以直接在任何模版中使用。

**DatePipe**

`DatePipe`基于所请求的格式串，格式化一个日期值，显示在模版中。使用格式：

```
expression | date:format
```
输入值expression可以为Date日期对象或者是日期字符串如`2016/04/05`;
format为日期格式，可以随意自定义，angular提供了年月日等标志符，可以根据标志符自定义日期格式。

表 3-6-1 `DatePipe`指令日期标志符（取2016-06-08 20:05:08时间为例）

| 日期        | 标志符   | 缩写         |   全称                     |  单标志符  |      双标志符  |    
|------------ |:------:| ------------:|--------------------------:|------------:|------------:|
| 地区        | G       | G (AD)       | GGGG (Anno Domini)        | -           | -           |
| 年          | y      | -             | -                        | y (2016)     | yy (16)    
| 月          | M      |MMM (Jun)      | MMMM (June)              | M (6)        | MM (06)
| 日          | d      | -             | -                        | d (8)        | dd (08) 
| 星期        | E      | EEE (Fri)     | EEEE (Friday)            | -            |  － ｜
| 时间(AM,PM) | j      | -             |-                         | j (8 PM)     | jj (08 PM) 
| 12小时制时间 | h      | -             |-                         | h (8)        | hh (08) 
| 24小时制时间 | H      |-              |-                         | H (20)       | HH (20)
| 分          | m      | -             |-                         | m (5)        | mm (05)  
| 秒          | s      | -             |-                         | s (8)        | ss (08)  
| 时区         | Z     | -             | Z (china Standard Time)  | -            |-|
| 时区         | z     | z (GMT-8:00)  |-                         | -            |-|

以月份为例，根据表格3-6-1自定义日期格式，若月份需要英文缩写的话，使用`MMM`；月份展示英文全称，使用`MMMM`；需要显示数字可以使用单标志符`M`;若月份是1-9月，也希望显示成两位01-09，则使用双标志符`MM`。
>截止rc3版本，双标志符jj、hh 、mm、ss经过测试，并未实现添加前置0的效果。后续使用时，可先测试正确性，检查是否有更新。

通过日期管道，日期可以根据表格随意自定义，如：

```js
@Component({
  selector: 'my-app',
  template: `
   <div>
     <p>'{{date | date:"y-MM-dd HH:mm:ss EEEE"}}'</p>
  </div>
  `,
})
export class AppComponent { 
  date: date = new Date('2016-06-08 20:05:08');
}

```
结果为`2016-06-08 20:5:8 Wednesday`

我们在使用原生html5 date控件时，设置最大最小日期范围，输入格式必需为`YYYY-MM-dd`，月份及日期必需为两位，不足两位，前补0，在这种场景下，都必需通过js对日期格式进行处理，使用日期管道，很方便就能得到对应得格式，如下：

```
<p>'{{date | date:"y-MM-dd"}}'</p>
```

Angular也提供了常用的`DatePipe`可选预定义格式，如下表

表 3-6-2 `DatePipe`可选预定义格式

| 预定义格式名   | 缩写           | 格式效果                 |
|------------  |:-------------:| -----------------------:|
| 'medium'     | 'yMMMdjms'    | Jun 6, 2016, 5:22:01 PM |
| 'short'      | 'yMdjm'       | 6/6/2016, 5:21 PM       |
| 'fullDate'   | 'yMMMMEEEEd'  | Monday, June 6, 2016    |
| 'longDate'   | 'yMMMMd'      | June 6, 2016            |
| 'mediumDate' | 'yMMMd'       | Jun 6, 2016             |
| 'shortDate'  | 'yMd'         | 6/6/2016                |
| 'mediumTime' | 'jms'         | 5:19:10 PM              |
| 'shortTime'  | 'jm'          | 5:19 PM                 |

日期管道也可以这样使用：

```html
{{ dateObj | date:'medium' }}      // 输出是 'Jun 6, 2016, 5:22:01 PM'
{{ dateObj | date:'shortTime' }}   // 输出是 '5:19 PM'
```

**JsonPipe**

`JsonPipe`将输入数据对象经过`JSON.stringify`转换后输出对象字符串，在开发调试时非常方便。

```js
@Component({
  selector: 'my-app',
  template: `
  <div>
  <p>没经过JSON管道处理: {{jsonObject}}</p>
  <p>经过JSON管道处理:</p>
  <pre>{{jsonObject | json}}</pre>
  </div>
  `,
})
export class AppComponent { 
   jsonObject: Object = {foo: 'bar', baz: 'qux', nested: {xyz: 3, numbers: [1, 2, 3, 4, 5]}};
}
```
输出结果为：

```html
没经过JSON管道处理: [object Object]
经过JSON管道处理:{
  "foo": "bar",
  "baz": "qux",
  "nested": {
    "xyz": 3,
    "numbers": [
      1,
      2,
      3,
      4,
      5
    ]
  }
}
```
没经过JSON管道转换的，在视图中显示为对象toString后的值‘[object Object]’，无法得知对象内部的变量和值；讲过JSON管道转换的，在视图中显示的是对象`JSON.stringify`后的值，在调试时可以一目了然查看对象内部变量和值，有助于快速定位问题。

**UpperCasePipe**

`UpperCasePipe` 将文本所有小写字母转成大写字母，用法如下：

```html
<pre>'{{value | uppercase}}'</pre>
```

**LowerCasePipe**

`LowerCasePipe ` 将文本所有大写字母转成小写字母，用法如下：

```html
<pre>'{{value | LowerCasePipe}}'</pre>
```
例子如下:

```js
@Component({
  selector: 'my-app',
  template: `
   <div>
    <p>文本转大写: {{text | uppercase}}</p>
    <p>文本转小写: {{text | LowerCasePipe}}</p>
  </div>
  `,
})
export class AppComponent { 
  text:string = abcABC;
}
```
结果为：

```html
文本转大写:ABCABC
文本转小写:abcabc
```
`uppercase`管道将text文本中所有小写字母改成了大写字母；`LowerCasePipe`管道将text文本中所有大写字母改成了小写字母。

**DecimalPipe**

`DecimalPipe` 将数值转成本地化文本，用法如下：

```
expression | number[:digitInfo]
```
digitInfo格式为：

```
{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}
```

 * minIntegerDigits：整数部分保留最小的位数，默认值为1
 * minFractionDigits：分数部分保留最小的位数，默认值为0
 * maxFractionDigits：分数部分保留最大的位数，默认值为3
 
```
{% raw %} 
@Component({
  selector: 'my-app',
  template: `
   <div>
    <p>e (3.4-5): {{e | number:'3.4-5'}}</p>
    <p>pi (3.1-5): {{pi | number:'3.1-5'}}</p>
  </div>
  `,
})
export class AppComponent { 
  e: number = 2.718281828459045;
  pi: number = 33456;
}
{% endraw %}
```

结果为：

```
e (3.4-5): 002.71828    
pi (3.1-5): 33,456.0
```
上述例子中，对于变量e进行数值本地格式化的参数为“3.4-5”，参数`.`之前的3表示整数位最少保留3位，原数值整数位为2位，不足3位，以前置0填充，填充后整数位为“002”；参数`.`后面的`4-5`表示最大保留分数位为4位，最小保留分数位为5位，因原始数据分数位大于5位，最大保留5位限制发挥作用，经四舍五入后分数位为“71828”。

对于变量pi进行数值本地格式化的参数为“3.1-5”，参数`.`之前的3表示整数位最少保留3位，原数值整数位为5，大于3位，不需添加前缀0，直接本地化格式后整数位为“33,456”；参数`.`后面的`1-5`表示最大保留分数位为5位，最小保留分数位为1位，因原始数据分数位数为0，因此最小保留1位限制发挥作用，分位补一个0，最终格式化的值为“33,456.0”。

**CurrencyPipe**

`CurrencyPipe` 将数值转成本地货币格式，用法如下：

```
expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]
```
currencyCode为`ISO 4217`货币码,如`CNY`为人民币、`USD`为美元、`EUR`为欧元； symbolDisplay为布尔值，true表示显示货币符号，如`¥`、`$`等 , false表示显示`ISO 4217`货币码；digitInfo详情可查看`DecimalPipe`的digitInfo格式说明。

```
@Component({
  selector: 'my-app',
  template: `<div>
    <p>A: {{a | currency:'USD':false}}</p>
    <p>B: {{b | currency:'USD':true:'4.2-2'}}</p>
  </div>`
})
export class AppComponent {
  a: number = 0.259;
  b: number = 1.3495;
}   
```
结果为：

```
A: USD0.259
B: $0,001.35
```
例子中，变量a第一个参数为USD,表示转换成美元货币格式，第二个参数为false,货币前缀展示的是美元`ISO 4217`货币码；变量b第一个参数为USD,表示转换成美元货币格式，第二个参数为true,货币前缀展示的是美元货币符号，第三个前缀表示对货币数值进行数值本地化，整数位保留4位，不足4位添加前置0，整数位为"0,001",分数位保留2到2位，原分数位位3位，保留2位进行四舍五入后分数位为“35”，因此解析后转换成百分比格式为“$0,001.35”

**PercentPipe**

`PercentPipe`将数值转换为本地格式百分比，用法如下：

```
expression | percent[:digitInfo]
```
digitInfo详情可查看`DecimalPipe`的digitInfo格式说明。

```js
@Component({
  selector: 'my-app',
  template: `
   <div>
    <p>A: {{a | percent}}</p>
    <p>B: {{b | percent:'4.3-5'}}</p>
  </div>
  `,
})

export class AppComponent { 
  a: number = 0.259;
  b: number = 1.3495;
}
```
结果为：

```
A: 25.9%
B: 0,134.950%
```
上诉例子中，变量a直接转换成百分比格式；变量b经过百分比将小数点往右移动两位后变成134.95,在进行数值本地化，整数位保留4位，不足4位添加前置0，整数位为"0,134",分数位保留3到5位，因分数不足3位，添加后置0，分数位为“950”，因此解析后转换成百分比格式为“0,134.950%”


**SlicePipe**

`SlicePipe` 将数组或者字符串裁剪成新子集，用法如下：

```
expression | slice:start[:end]
```
`SlicePipe`以JavaScript API`Array.prototype.slice()`及`String.prototype.slice()`的功能效果为基础，实现了类似的功能。参数start和end为数组的索引，具体定义可参考JavaScript API`Array.prototype.slice()`及`String.prototype.slice()`的介绍。

```js
@Component({
  selector: 'my-app',
  template: `
   <div>
   	  <h5>数组裁剪：</h5>
     <li *ngFor="let  i of collection | slice:1:3">list:{{i}}</li>
     <h5>字符串裁剪：</h5>
     <p>str[0:4]: '{{str | slice:0:4}}'</p>
  </div>
  `,
})
export class AppComponent { 
  collection: string[] = ['a', 'b', 'c', 'd'];
  str: string = 'abcdefghij';
}
```
结果为：

```
数组裁剪：
  list:b
  list:c
字符串裁剪：
  str[0:4]: 'abcd'
```
上述例子中，实现了使用管道将数组及字符串进行裁剪。数组collection相当于执行了`collection.slice(1,3)`，从数组索引为1开始裁剪到数组索引为3之前止，所以裁剪出数组索引为1的值b和索引为2的值c，字符串裁剪同理。

**ReplacePipe**

`ReplacePipe ` 将符合一定规则的文本替换成其指定的文本，用法如下：

```
expression | replace:pattern:replacement
```
输入值expression可以为`String`字符串类型和`Number`数值类型，`Number`数值类型最后会强制转换为`String`字符串类型; 

参数pattern为匹配需被替换的文本，可为`String`字符串类型或者`RegExp`正则表达式，pattern最后会转换成`RegExp`正则表达式对象，因此在书写上注意特殊符号的转义；参数replacement为被替换成的文本，可为`String`字符串类型或者`Function`函数表达式。

```js
@Component({
  selector: 'my-app',
  template: `
   <div>
     <p>'{{str | replace:"abc":"aaa-"}}'</p>
     <p>'{{str2 | replace:pattent:"-"}}'</p>
     <p>'{{str3 | replace:"/":"+"}}'</p>
  </div>
  `,
})
export class AppComponent { 
  str: string = 'abcabcabcabc';
  str2: string = '2016/06/24';
  str3: string = '(3*5)/(2-1)';
  pattent: RegExp = /\//g;
}
```
结果为：

```html
<p>'aaa-abcabcabc'</p>
<p>'2016-06-24'</p>
<p>'(3*5)+(2-1)'</p>
```
例子中字符串str相当于执行了`str.repalce('abc','aaa-')`将第一个"abc"替换成"aaa-"；字符串str2传人了一个正则对象，相当于执行了`str2.repalce(/\//g,'-')`将字符串str2中所有的"/"替换成“－”；str3相当于执行了`str3.repalce('/','+')`将第一个"/"替换成"+"；

`ReplacePipe `以JavaScript API`String.prototype.replace()`的功能效果为基础，实现了类似的功能，参数start和end的具体定义可参考JavaScript API`Array.prototype.slice()`及`String.prototype.slice()`的介绍。


### 3.6.2 自定义管道
虽然angular2提供了许多内置的管道指令，但是数据转换的格式各式各样，内置管道不能一一满足需求。angular2提供自定义管道功能，可根据业务场景自定义各式各样的数据转换需求。下面定义一个日期格式化的自定义管道。

#### 定义元数据

```
@Pipe({name: 'dateReform'})
```
通过`@Pipe`装饰器来告诉Angular这是一个管道类，`@Pipe`装饰器有一个name属性，用来指定管道名称。名称必须是有效的JavaScript标识符，这里叫 dateReform。
在使用`@Pipe`时必须引入`Pipe`组件，如下：

```
import { Pipe } from '@angular/core';
```

#### 实现transform方法
自定义的管道必须继承类`PipeTransform`, 在使用类`PipeTransform`时，必须通过`import { Pipe, PipeTransform } from '@angular/core'`引入类`PipeTransform`组件。且自定义管道必需重载实现`PipeTransform`接口`transform`方法，方法接收一个输入参数，和若干可选参数，最后返回转换后的值，如下：

```
export class DateReform implements PipeTransform {
  transform(val:string, format:string):string {

    let date = new Date(val);
    let year = date.getFullYear() + '';
    let month = date.getMonth() + 1 + '';
    let day = date.getDate() + '';

    let yyyy = year;
    let MM = (month.length < 2 ? '0' : '') + month;
    let dd = (day.length < 2 ? '0' : '') + day;

    let result = '';
    switch(format) {
      case 'yyyy-MM-dd':
        result = [yyyy, MM, dd].join('-');
      break;
      case 'yyyyMMdd':
        result = [yyyy, MM, dd].join('');
      break;
      default:
        result = [yyyy, MM, dd].join('');
    }

    return result;
  }
}
```
例子中定义了一个名为`DateReform`的管道类，`DateReform`管道类继承类`PipeTransform`,`DateReform`管道`transform`方法接收一个需要转换的日期输入参数val，及一个可选代表日期格式的参数format，根据日期格式，将输入的日期进行格式话，最后返回转换后的日期字符串值，显示在视图中；若日期格式参数没有传人，则使用默认的日期格式对日期进行格式化，并返回显示在视图中。

####在模版中使用自定义管道：

```
import { Component }         from '@angular/core';
import {DateReform} from './dateReform.pipe';

@Component({
  selector: 'my-app',
  pipes: [DateReform],
  template: `
   <div>
    <p>
      日期: {{value | dateReform: "yyyy-MM-dd"}}
    </p>
  </div>
  `,
})
export class AppComponent { 
  value: number = new Date();
}
```

在组件模版中使用自定义管道，需先引入自定义管道`DateReform`：

```
import {DateReform} from './dateReform.pipe';
```
在组件`@Component`装饰器声明`pipes: [DateReform]`,告诉模版可以使用自定义管道`DateReform`，此时可以在模版中随意使用自定义管道`DateReform`。例子中实现了将日期格式化为“年-月-日”的格式。

自定义管道和内置管道使用方式完全相同,不同的是使用前需将管道import进来，且必须在`@Component`装饰器的pipes数组里列出需使用的自定义管道。

####全局自定义管道
上面定义的`DateReform `日期格式后管道，不仅会在当前页面使用，也会其他页面使用，对于这类通用的自定义管道，每次使用前都需要在当前页面import管道、然后在`@Component`装饰器的pipes数组里列出使用的管道，异常繁琐。为了避免这种使用场景，angular2提供了全局自定义管道，供全局使用。

在启动应用入口页面引入自定义管道`DateReform`,同时引入`bootstrap`、`provide`、`PLATFORM_PIPES`组件

```js
import { Component }         from '@angular/core';
import { bootstrap }    from '@angular/platform-browser-dynamic';
import { provide, PLATFORM_PIPES } from '@angular/core';
import { DateReform } from './dateReform.pipe';

bootstrap(AppComponent, [{provide: PLATFORM_PIPES, useValue: [DateReform], multi:true}]);
```

在启动应用入口页面依赖注入管道`DateReform`

```js
bootstrap(AppComponent, [{provide: PLATFORM_PIPES, useValue: [DateReform], multi:true}]);
```
使用`{provide: PLATFORM_PIPES, useValue: [DateReform], multi:true}`注册日期格式提供商，在根组件上依赖注入了一个`DateReform`提供商服务，它会在整个应用程序中被共享，详细关于提供商的内容，会在依赖注入章节讲解。
此时管道`DateReform`为全局自定义管道，像内置管道一样可以在任何组件中随意使用，且无需在定义组件前import `DateReform`管道，也无需在`@Component`装饰器的pipes数组里列出使用`DateReform`管道等，节省许多重复操作，大大提高开放效率，且代码简洁多了。

```js
import { Component }  from '@angular/core';

@Component({
  selector: 'my-app',
  template: `
   <div>
    <p>
      日期: {{value | dateReform: "yyyy-MM-dd"}}
    </p>
  </div>
  `,
})
export class TestComponent { 
  value: number = new Date();
}
```

### 3.6.4 管道状态
若Angular2在每次点击、移动鼠标、定时器触发、服务器响应等事件后会执行数据绑定值变化检测，这会带来性能问题，因此如果我们使用管道，Angular2会选择使用更简单、更快速的变化检测算法来提高性能。下面通过显示联系人的列表看看有无管道时Angular2是如何优化性能的。

无管道时，添加新联系人，实时更新联系人列表

```
@Component({
  selector: 'my-app',
  template: `
  <input type="text" #box  (keyup.enter)="addContact(box.value); box.value=''"placeholder="输入联系人后回车添加">
  <div *ngFor="let contact of (contacts)">
    {{contact.name}}
  </div>
  `,
})
export class AppComponent { 
  contacts=[{name:'张三'},{name:'李四'}];
  addContact(name:string) {
    this.contacts.push({name});
  }
}
```
上述例子中，在表单输入联系人后，回车触发addContact，通过push将新contact推入数组中，同时contacts数组数据被刷新显示到页面上，实现了在表单中输入一个联系人名称，在列表中实时显示更新后的联系人的列表的功能。

下面添加一个过滤`李`姓联系人的自定义管道，添加新联系人，实时更新`李`姓联系人列表。

添加一个SelectContactPipe管道用于过滤出姓`李`的联系人。SelectContactPipe自定义管道如下：

```
@Pipe({ name: 'selectContact' })
export class SelectContactPipe implements PipeTransform {
  transform(allContacts) {
    return allContacts.filter(contact => contact.name.match("^李"));
  }
}
```
在组件模版中使用管道：

```
<div *ngFor="let contact of (contacts | selectContactPipe)">
{{contact.name}}
</div>
```
运行结果发现很奇怪，添加的`李`姓联系人并不会实时显示在页面，但是也没有报 error 错误。为什么结果不是想象中的结果呢？因为Angular2使用了一个忽略变更列表的变化检测算法。

例子中使用`this.contacts.push(contact);`新增一个联系人。将新联系人对象 contact 推入到数组里面，数组的对象引用并没有发生改变，还是同一个数组，所以从Angular2角度来说，相同数组、没有变化，不进入`SelectContactPipe`筛选管道，数据没有更新，页面无法实时显示更新的联系人。

若将push换成concat:

```
this.contacts = this.contacts.concat(contact);
```
数组concat方法将老数据和新数据连接成一个新的副本数组，并重新赋值给联系人列表contacts，数组的对象引用地址发生改变，Angular2也能检测到新的变化，进入`SelectContactPipe`筛选管道，筛选的`李`姓联系人列表数据更新，页面实时显示更新后的`李`姓联系人列表，解决了添加联系人后，无法在页面实时显示新增联系人的问题。

但是每添加一个联系人，都需重新产生一个新副本数组，这想必会让人崩溃。因此，Angular提供另一种Impure管道，用来解决检测变化时对对象引用依然有效的办法。

管道有两种类型：pure 和 impure，其中pure是默认类型，现在来看看 pure 和 impure 两者的区别。

####Pure 管道

在 pure 管道，Angular2只有在检测到输入值发生 pure 变更时才会进入pure管道执行`transform`方法触发数据变化，从而达到页面数据更新。pure 变更指的是基本数据类型String、Number、Boolean、Symbol等输入值的变化或对象Date、Array、Function、Object等引用的变化。

如DatePipe日期管道，管道输入值日期对象`Date`,更改输入日期`Date`中的月份、往一个输入数组`Array`中添加新值或者更新了一个输入对象`Object`的属性， Angular 都不会调用纯管道。

```
@Component({
  selector: 'my-app',
  template: `
   <div>
     <p>'{{date | date:"y-MM-dd HH:mm:ss EEEE"}}'</p>
      <p>'{{date2 | date:"y-MM-dd HH:mm:ss EEEE"}}'</p>
  </div>
  `,
})
export class AppComponent { 
  date: date = new Date('2016-06-08 20:05:08');
  date2: string = '2016-06-08 20:05:08';
  constructor() { 
    let self = this;
    setTimeout(function(){
      self.date.setMonth(12);
      self.date2 = '2016-12-08 20:05:08';
    },2000);
  }
}
```
上述例子中，日期管道的输入值分别为一个日期对象和一个日期字符串，初始日期都为’2016-06-08 20:05:08‘，添加一个2秒的计时器，将日期月份变为12。最初显示为：

```
'2016-06-08 20:5:8 Wednesday'
'2016-06-08 20:5:8 Wednesday'
```

2秒后显示为：

```
'2016-06-08 20:5:8 Wednesday'
'2016-12-08 20:5:8 Thursday'
```
由显示的结果可以看出，在pure管道`date`中,输入为字符串基本类型日期时，当2秒计时完成后，日期字符串月份修改为12月，因基本类型的值发生了改变，会执行日期管道`transform`方法，此时，通过管道显示出来的日期也变为12月。而输入日期对象时，2秒计时完成后，直接修改日期对象的月份为12，但是日期对象的引用并没有发生改变，不会执行日期管道`transform`方法，因此通过管道显示出来的日期没有发生改变。


内置管道中DatePipe、UpperCasePipe、LowerCasePipe、DecimalPipe、CurrencyPipe、PercentPipe、ReplacePipe等都为pure管道。

一个对象引用检查要比一个对象内部所有值的检查快得多，Angular为了能快速判断是否可以跳过管道执行和视图更新，会忽略对象内部的变化，这就是pure管道变化检测策略。因对象引用检测的受限，所以需要另一种管道的变化检测策略 impure 管道。

####Impure 管道

Angular2每次组件变化检测周期时都会执行 impure 管道，每个按钮或鼠标移动时都会进入管道`transform`方法，执行管道处理。所以Impure管道执行不够快，有可能会让用户体验变得很差，在使用impure管道时需特别注意。

以上述添加新联系人例子为例，在管道元数据里设置 pure 属性值为 false 可以定义 impure 类型管道。

```
@Pipe({ 
  name: 'selectContactPipe' ,
  pure: false
})
```
此例子添加pure: false 定义Impure管道，数据添加继续使用`this.contacts.push(contact);`新增将联系人推入数组中，此时在页面输入`李`姓联系人，回车后，也能实时显示新添加的`李`姓联系人。以为此时的管道是异步管道，在变化周期内都会去检测执行`SelectContactPipe`管道的“transform”方法，因此数据会同步到模版视图中。

####Impure异步管道

在Angular2内置管道指令中，还有一个有趣的管道`AsyncPipe`。`AsyncPipe`是Impure异步管道，接收的是 Promise 或 Observable 对象作为输入值，并自己订阅它，最终返回产生的值。

```
import { Component } from '@angular/core';
import { Observable } from 'rxjs/Rx';
@Component({
  selector: 'my-app',
  template: `
    <p>时间: {{ time | async }}</p>
  `,
})
export class AppComponent {
  contacts: Observable<string>;
  constructor() { this.getObservableTime(); }
  getObservableTime() {
    this.time = new Observable<number>((observer: Subscriber<number>) => {
      setInterval(() => observer.next(new Date().toLocaleString()), 1000);
    });
  }; 
}
```
这个例子，使用`AsyncPipe`管道把一个时间字符串 time 的 Observable 绑定到视图中，通过异步管道实现了每隔一秒，时间切换的时钟效果。

除了`AsyncPipe`是异步管道之外，`SlicePipe`与`JsonPipe`也是异步管道，具体可看表3-6-3。

表 3-6-3 内置管道类型总结

| 管道           | 类型   | 功能   |
|------------   |:------:|:------:| 
| DatePipe      | pure   | 日期管道，格式化日期 
| UpperCasePipe | pure   | 将文本所有小写字母转成大写字母
| LowerCasePipe | pure   | 将文本所有大写字母转成小写字母
| DecimalPipe   | pure   | 将数值按特定的格式显示的文本
| CurrencyPipe  | pure   | 将数值转成本地货币格式
| PercentPipe   | pure   | 将数值转百分比格式
| ReplacePipe   | pure   | 将符合一定规则的文本替换成其指定的文本
| SlicePipe     | impure | 将数组或者字符串裁剪成新子集
| AsyncPipe     | impure | 异步管道，输入值为 Promise 或 Observable 对象，并订阅该对象，返回产生的值
| JsonPipe      | impure | 将输入数据对象经过`JSON.stringify`转换后输出对象字符串


####Pure 管道 and pure 函数
 在本章前面见过的管道都是用纯函数实现的。pure函数是指在处理输入并返回结果时，不会产生任何副作用的函数。 Pure管道使用Pure函数，给定相同的输入，它们总是返回相同的输出。一个 纯管道 必须总是用 纯函数 实现。忽略这个警告将导致失败并带来一大堆这样的控制台错误：表达式在被检查后被更改。
 

## 3.7 模板表达式操作符

### 3.7.1 管道操作符（|）

在用到绑定中之前，模板表达式的结果可能需要一些转换。比如，你可能希望把一个数值显示成金额、强制文本变成大写，或者过滤一个列表及排序。Angular管道对像这种小型转换来说是个很不错的选择。管道是一个简单的函数，它接受一个输入值，并返回转换结果。它们很容易用于模板表达式中，只有使用管道操作符（|）即可。如：

```HTML
<div>Title through uppercase pipe: {{title | uppercase}}</div>
```

管道操作符会把它左侧的表达式结果传给它右侧的管道函数。你也可以通过多个管道串联出表达式，如：

```HTML
<!-- 先转换成大写，再转换成小写 -->
<div>
  Title through a pipe chain:
  {{title | uppercase | lowercase}}
</div>
```

还可以对它们使用参数，如：

```HTML
<!-- 结果形如"February 25, 1970" -->
<div>Birthdate: {{currentUser?.birthdate | date:'longDate'}}</div>
```

`json`管道可以用来帮助我们调试绑定：

```HTML
<div>{{currentUser | json}}</div>
```

输出结果类似于这样：

```JSON
{ "firstName": "Hercules", "lastName": "Son of Zeus",
  "birthdate": "1970-02-25T08:00:00.000Z",
  "url": "http://www.imdb.com/title/tt0065832/",
  "rate": 325, "id": 1 }
```

### 3.7.2 安全导航操作符（?.）和空属性路径

Angular的安全导航操作符（?.）是一个流畅而便利的方式，用来保护出现在属性路径中null和undefined的值。
如下所示，加入`title`属性为空，视图仍会被渲染，但是显示的值为空；只能看到“标题是”，后面没有任何东西。这是合理的，至少程序没有崩溃。

```HTML
标题是{{title}}
```

假设模板表达式需要一个属性路径，比如要显示子标题的第一个字符：

```HTML
标题的第一个字符是{{subtitle.firstString}}
```

如果`subtitle`为null，Javascript会抛出衣蛾空引用的错误，Angular也是如此：

```JAVASCRIPT
TypeError: Cannot read property 'firstString' of null in [null].
```

这时你会发现，整个视图不见了。如果确信firstString属性永远不可能为空，我们就可以声称这是一个合理的行为。如果它必须不能为空，但它仍然会是空值，你就制造了一个编程错误，以便它被捕获和修复。这种情况，抛出一个异常正式需要做的。另一方面，属性路径中空值可能随时发生，特别是当我们知道这些数据最终总会到来的时候。
当等待数据的时候，视图渲染器应该把空属性路径显示为空白，就像上面`title`属性所做的那样，但不幸的是，当`subtitle`为空的时候，程序已经崩溃了。


### 本章小节
本章着重介绍了模板相关语法，以及与模板相关的表单、管道等，下面将从模板语法、表单、管道三个维度总结如下：

#### 模板语法
本章模板语法主要介绍了插值、数据绑定、局部模板变量内置指令、模板表达式操作符等，涵盖的主要内容有：

1、模板中最常见的数据绑定形式是插值，插值可以是组件属性的变量名、合法的表达式，甚至可以是宿主组件的函数方法；</br>
2、数据绑定的形式，通过输入属性的绑定数据由上而下流入一个组件，数据通过输出属性流出组件等；</br>
3、通过事件&属性绑定来补充Angular2的双向绑定，提供了`NgModel`语法糖来实现数据的双向绑定等；</br>
4、介绍了两种模板表达式操作符，即管道操作、安全导航操作符（?.）和空属性路径。

#### 表单
本章表单部分主要涵盖的内置指令、表单状态追踪、表单检验及表单双向数据绑定，关键点有：

1、表单提供`ngForm` 、`ngModel` 、`ngModelGroup` 、`ngSubmit`等内置表单指令，实现表单数据修改、双向数据绑定、校验、提交等功能。</br>
2、表单加入ngModel及name属性后，可以根据valid、pristine、dirty、touched、untouched等值进行表单状态跟踪及校验。</br>
3、表单加入ngModel及name属性后，用户对表单的操作状态，同时会通过表单状态类体现出来。可以通过ng-touched、ng-untouched、ng-dirty、ng-pristine、ng-valid、ng-invalid等表单状态类，自定义表单在不同状态下的样式。</br>
4、表单内置验证包括required、minlength、maxlength、pattern，表单提交时，可以通过valid检测校验合法性。</br>
5、表单通过`FormBuilder`构建表单的方式添加自定义校验。如果想添加多个校验，可以使用Validators.compose。</br>

#### 管道
本章管道主要涵盖angular2的内置管道指令用法、自定义管道、全局自定义管道及管道状态，关键点有：

1、管道通过管道符号`|`声明使用，`|`符号后接管道名pipeName即可使用管道，同时可通过`:`冒号给管道传人参数。</br>
2、Angular2支持链式管道，多个管道之前同样以`|`符号分割，形成链式管道，模版最后输出的是多个管道作用后的结果。</br>
3、Angular2提供许多内置管道，如日期格式化管道、文本转换大写管道、文本转换小写管道、数值格式化管道、货币格式化管道、百分比格式化管道、文本替换管道、数组或字符串裁剪管道、异步管道、Json格式化管道。</br>
4、angular提供自定义管道,管道可以在该组件模版中局部范围内使用。同时angular提供自定义全局管道，自定义全局管道可以在所有的组件模版中使用。</br>
5、angular管道分为pure及impure管道，pure管道只有在基本数据类型String、Number、Boolean、Symbol等输入值的变化或者对象Date、Array、Function、Object等引用发生改变时才执行管道处理。impure管道是在组件变化检测周期时都会执行管道处理。</br>
