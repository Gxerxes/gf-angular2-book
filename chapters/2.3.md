#3 模板

## 引言

HTML是模板的主要形式，Angular模板的默认语言就是HTML。几乎所有的HTML语法在模板中都是适用的。但`<script`元素是被禁止的，主要是为了防止Javascript脚本注入攻击的风险。同时一些HTML元素在模板中并不起什么作用，比如`<html>`，`<body>`，`<base>`。除此之外，Angular中可以通过组件和指令对模板的HTML词汇进行扩展，这些扩展作为新的元素或属性出现。
这一章，会学习有关模板方面的知识，比如模板表达式和模板声明，数据绑定，表单以及管道的相关知识。

## 3.1 模板表达式和模板声明

先来学习两个有关模板的基本概念，模板表达式和模板声明。

### 3.1.1 模板表达式

模板表达式可以产生一个值。Angular会执行这个表达式并将值分配给一个绑定目标的属性上。这个目标可能是一个HTML元素，一个组件或者一个指令。目标表达式书写在插值语法中，在属性绑定那里将再次看到模板表达式的出现，它出现在`=`右侧的引号中，`[属性]="模板表达式"`。
模板表达式写起来就像是Javascript语言，很多Javascript表达式都是合法的模板表达式，但并不是全部。
具有或可能引发副作用的Javascript表达式是被禁止的，包括：
* 赋值表达式（`=`，`+=`，`-=`...）
* new操作符
* 带有`;`或者`'`的连接表达式
* 自增和自减操作（`++`和`--`）
其他与Javascript语法不同的值得注意的包括：
* 不支持位运算符（`|`和`&`）
* 模板表达式的操作符，如`|`和`?.`等，被赋予了新的含义

#### 模板表达式上下文

模板表达式不能引用任何全局命名空间中的成员，如window和document，也不能调用`console.log`或者`Math.max`等方法，仅限于引用表达式上下文的成员。典型的表达式的上下文就是这个组件的实例，它是各种绑定值的来源。当看到被双大括号包裹的*title*—{{title}}，就会知道`title`是数据绑定组件中的一个属性。当看到`[disabled]="ischange"`中的*ischange*，就会知道引用了组件的`ischange`属性。组件本身通常是表达式的上下文，这就是模板表达式通常引用那个组件的原因。	

#### 模板表达式的书写原则

模板表达式书写时要注意以下几个原则：
* 无副作用——一个模板表达式除了改变目标属性的值以外不应该改变任何应用状态，这是基于Angular的“单向数据流”准则。永远不必担心在读组件值的时候改变其他的一些展示值。
* 高效执行——Angular执行表达式的频率远超我们的想象。每一次的键盘或者鼠标事件这些表达式都会被执行。如果表达式执行缓慢，将会大大降低用户的体验。当计算复杂时，可以考虑缓存那些从其他计算得出的值。
* 足够简单——尽管可以写一些相当复杂的模板表达式，但是通常不要这么做。
* 幂等性优先——幂等性表达式没有副作用，而且能提升Angular变更检测的性能。一个幂等的表达式总是返回完全相同的东西，直到它所依赖的值中有一个变了。

### 3.1.2 模板声明

模板声明用来响应由绑定目标（比如HTML元素、组件或者指令）来触发的事件对象。在事件绑定部分也将会有模板声明的介绍，模板声明出现在`=`的右侧，如`(事件)="模板声明"`。模板声明有一个副作用，即如何从用户的输入来更新应用状态，不然，响应一个事件就没有什么意义了。
和模板表达式一样，模板声明和Javascript语句类似。模板表达式和模板声明的解析器有所同，模板声明支持`=`赋值操作，也支持多条语句（用;或者,分隔）。但是，一些Javascript语句还是不被支持的：
* new操作符
* 自增和自减操作（`++`和`--`）
* 赋值操作，如`+=`和`-=`
* 不支持位运算符（`|`和`&`）
* 模板表达式运算符

#### 模板声明上下文

模板表达式操作和模板表达式一样，模板声明只能引用其上下文环境的成员变量，模板声明的上下文环境就是绑定事件的组件实例。模板声明不能引用任何全局命名空间中的成员，不能引用`window`或者`document`，也不能引用`console.log`或者`Math.max`。`(click)="onSave()"`里面的*onSave*肯定是数据绑定组件实例中的一个方法。模板声明的上下文除了组件外可以包括对象。模板引用对象就是这些备选上下文对象中的一个。在事件绑定声明中将会频繁的看到`$event`保留字的使用，这是DOM事件本身的一个扩展引用，它代表来自所触发事件的“消息”或“有效载荷”。

#### 模板声明的书写原则

和模板表达式一样，避免写得太复杂，推荐的写法是单一函数调用或者单一属性访问。

## 3.2 数据绑定

学习了模板的一些基本知识后，接下来学习Angular中一个重要的知识——数据绑定。

### 3.2.1 概述

数据绑定为应用程序提供了一种简单而一致的方法来显示数据以及数据交互，它是管理应用程序里面数值的一种机制。通过这种机制，可以从HTML里面取值和赋值，使得数据的读写，数据的持久化操作变得更加简单快捷。Angular提供了多种数据绑定方式，可以根据数据流的方向分为三种，每一种都有各自的语法。

![MacDown logo](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapters2-3/date-binding.png)

绑定类型除了插值外在`=`的左侧都会有一个目标名称，即绑定目标，或者被标点符号包裹（`[]`，`()`），或者有一个前缀（`bind-`，`on-`，`bindon-`）。而`=`右侧或者插值符号`{{}}`中的部分则为绑定源。

学习数据绑定前先来了解一对非常重要的概念对比。

#### DOM对象属性(property)与HTML标签特性(attribute) 

在英语中property和attribute都可以译为”属性“，名字相同，意义却大有不同。理解这两个属性的不同是理解Angular如何进行数据绑定的关键。

     | DOM对象属性(property) | HTML标签特性(attribute) | 关系
------------- | ------------- | ----------- | ----
定义方式 | 是这个DOM元素作为对象，其附加的内容，是在文档对象模型里定义的，如childNodes、firstChild等 | 是DOM节点自带的属性，是在HTML里定义的，即只要是HTML标签中出现的属性（HTML代码）都是attribute，例如HTML中常用的id、class、align等 | 有些常用特性（id、title、class等）会”脚踏两只船“被转化为property
DOM树建立后，属性值是否会改变 | 会 | 不会<br>attribute的作用就是用来初始化DOM对象属性 | 如当浏览器渲染`<input type="text" value="Bob">`时，浏览器会用value创建一个对应的DOM节点并初始化值为”Bob”。当用户在该输入框里输入”Sally”，DOM对象属性值就变成”Sally”，但HTML元素属性值依然是”Bob”（input.getAttribute('value')  //return ”Bob“）。所以HTML元素属性值是指定初始化的值，DOM对象属性值是当前值。

注意，理解这两个概念的区别很重要。绑定是作用在DOM对象属性和事件上，而不是HTML标签特性上。在Angular中，HTML标签特性的唯一作用就是用来初始化元素和指令的状态，而数据绑定时，仅仅解决元素、指令属性和事件，HTML标签特性消失在这里。请牢记这一思维模式。

### 3.2.2 插值

数据绑定最常见的形式就是插值，在Angular中，默认使用的是双大括号作为插值语法。使用插值可以在HTML元素标签和属性值内将变量输出，如

```
<h3>
{{title}}
<img src="{{ImageUrl}}">
</h3>
```

大括号中间的值通常是一个组件属性的变量名，Angular使用了相应组件属性的值来替换这个变量。在这个例子中，Angular就是对`title`和`ImageUrl`求值并替换后，最终在页面中展示出来。
更普遍的做法是，大括号里面还可以是一个合法的模板表达式，Angular会首先进行求值，然后转换成一个字符串，如

```
<!-- "1+1=2" -->
<p>1+1={{1+1}}</p>
```

表达式甚至可以调用宿主组件的函数，如

```
<!-- "1+1的和不是4" -->
<p>1+1的和不是{{1 + 1 + getVal()}}</p
```

Angular对于双大括号里面的表达式都会求值，转化成字符串的结果，然后和附近的字符串组合在一起。最终，将这个结果分配给元素或者指令的属性。
表面上看，插值的作用是将`{{`和`}}`里面的内容计算转化成字符串后，“替换”`{{...}}`这里的内容，这样的理解在使用上并没有问题，但是实际在Angular中，插值的本质是转化成`属性绑定`的一种特殊语法。

### 3.2.3 单向数据绑定—从数据源到视图目标

这种形式的数据绑定也可以称为属性绑定。当要把一个视图元素的属性设置为模板表达式时，就需要模板的属性绑定。这种数据绑定是值只能从组件中的数据流向目标元素的属性。属性绑定不能用来从目标元素拉取值，也不能绑定到目标元素的属性来读取它，只能设置它。

#### DOM元素属性绑定

最常用的属性绑定是把元素的属性设置为组件中属性的值。来看下面几个例子，image元素的src属性会被绑定到组件的`userImageUrl`属性上：

```HTML
<img [src]="userImageUrl">
```

此时DOM对象属性的名称就是绑定目标。如`src`。也可以是`bind-`前缀的形式，又叫 __规范形式__ ，如`<img bind-src="userImageUrl">`。

当组件`isUnchanged`（未改变）时禁用一个按钮：

```HTML
<button [disabled]="isUnchanged">按钮是禁用的</button>
```

设置指令的属性：

```HTML
<div [ngClass]="classes">[ngClass]绑定到classes 属性</div>
```

设置一个自定义组件的属性（这是父子组件间通讯的重要途径）：

```HTML
<user-detail [user]="currentUser"></user-detail>
```

#### HTML标签特性绑定

Angular推荐使用DOM元素属性绑定。但当元素没有属性可绑的时候，就需要使用HTML标签特性（Attribute）绑定（这是“绑定到目标属性”这一规则中唯一的例外，是唯一一个能够创建和设置Attribute的绑定形式）。比如，ARIA,SVG和table中的colspan/rowspan等HTML标签特性，是纯粹的Attribute，并没有相对的DOM属性可供绑定，如果写出类似下面的东西，就会很奇怪：

```HTML
<tr><td colspan="{{1 + 1}}">Three-Four</td></tr>
```

还会得到这个错误

```
Template parse errors:
Can't bind to 'colspan' since it isn't a known native property
```

模板解析错误：不能绑定到'colspan'，因为它不是已知的原生属性。
正如错误提示所说，`<td>`元素没有`colspan`DOM元素属性，而有`colspan`标签特性（Attribute）。插值和属性绑定只能设置DOM元素属性，而不是HTML标签特性，所以需HTML标签特性绑定来创建和绑定类似的Attribute。HTML标签特性绑定在语法上类似于属性绑定，但中括号中的部分不是一个元素的属性名，而是由一个`attr.`的前缀和HTML标签特性的名称组成，然后通过一个能求值为字符串的表达式来设置HTML标签特性的值。如：

```HTML
<table border=1>
  <tr><td [attr.colspan]="1 + 1">One-Two</td></tr>
  <tr><td>Five</td><td>Six</td></tr>
</table>
```

HTML标签特性绑定的主要用途之一就是用来设置ARIA Attribute（ARIA指用于给残障人士访问互联网提供便利）。如：

```HTML
<!-- 为无障碍浏览创建并设置aria标签特性 -->
<button [attr.aria-label]="actionName">{{actionName}} with Aria</button>
```

#### css类绑定

借助css类绑定可以很方便的从`class`元素特性上添加和移除css类名。css类绑定在语法上类似于属性绑定，但中括号中的部分不是一个元素的属性名，css类绑定由一个`class`前缀紧跟一个点`.`，再跟着css类的名字组成，其中后两部分可选，类似于：`[class.class-name]`。下面的例子展示了如何通过css类绑定类添加和移除“special”类：

```HTML
<!-- 标准HTML样式类设置 -->
<div class="bad curly special">Bad curly special</div>
<!-- 通过绑定重设或覆盖样式类  -->
<div class="bad curly special" [class]="badCurly">Bad curly</div>
<!-- 通过一个属性值来添加或移除special样式类 -->
<div [class.special]="isSpecial">这个样式比较特殊</div>
```

#### style样式绑定

通过样式绑定，可以设置内联样式。样式绑定语法上类似于属性绑定，但中括号里面的部分不是一个元素的属性名，样式绑定包括一个`style`前缀，紧跟一个点`.`，再跟着css样式的属性名，形如`[style.style-property]`。如：

```HTML
<button [style.color] = "isSpecial ? 'red': 'green'">红色</button>
<button [style.background-color]="canSave ? 'cyan': 'grey'" >保存</button>

<!-- 带有单位的样式绑定 -->
<button [style.font-size.em]="isSpecial ? 3 : 1" >大</button>
<button [style.font-size.%]="!isSpecial ? 150 : 50" >小</button>
```

样式属性可以是中线命名法（font-size），也可以是驼峰是命名法（fontSize）。

#### 属性绑定与插值的区别和联系

开发人员通常会在插值和属性绑定之间做选择。如下面的例子，插值和属性绑定两者起到了相同的效果。

```HTML
<p><img src="{{userImageUrl}}">是<i>插值的</i>图片。</p>
<p><img [src]="userImageUrl">是<i>属性绑定的</i>图片。</p>

<p><span>"{{title}}"是<i>插值的</i>标题。</span></p>
<p>"<span [innerHTML]="title"></span>"是<i>属性绑定的</i>标题。</p>
```

在多数情况下，插值表达式是一个更方便的选择。实际上，在渲染视图之前， Angular就会把这些插值表达式翻译成为对应的属性绑定形式。从技术上看无法决定哪种形式更好。但从可读性角度出发，建议使用插值表达式的方式。建议建立组织级的代码风格规定，然后选择一种形式，既能遵循规则，又能让手头的任务做起来更自然。
不论哪种方式，Angular都会对危险的HTML有所防备。在显示它们之前，Angular会先对内容进行“消毒”，不会允许带有`script`标签的HTML泄露到浏览器中。如：
```HTML
evilTitle = 'Template <script>alert("evil never sleeps")</script>Syntax';
```

### 3.2.4 单向数据绑定—从视图目标到数据源

事件绑定就是这种数据绑定方式。在事件绑定中，Angular通过监听用户动作，比如键盘事件、鼠标事件、触屏事件等来响应相对应的数据流向-从视图目标到数据源。事件绑定的语法是由等号左侧小括号内的 __目标事件__ 和右侧引号中的 __模板声明__ 组成。比如下面这个例子，是事件绑定监听按钮的点击事件。无论什么时候点击，都会调用组件的 `onSave()`方法。

```HTML
<button (click)="onSave()">保存</button>
```

#### 目标事件

小括号`()`中的名字标记出了目标事件，如下例所示，目标事件是按钮的click事件：

```HTML
<button (click)="onSave()">保存</button>
```

除了小括号，也可以使用规范形式来标记目标事件，即`on-`前缀，如：

```HTML
<button on-click="onSave()">保存</button>
```

元素事件是最常见的目标事件，但Angular会先看这个名字是否能够匹配已知指令的事件，如果事件名称既不是元素事件，也不是某个已知指令的事件，Angular就会抛出一个“未知指令”的错误。

#### $event对象和事件处理器

在事件绑定中，Angular会为目标事件设置事件处理器。当事件发生时，这个处理器便会执行模板语句。典型的模板语句通常涉及到那些针对事件想做出相应处理的接收器，如从一个HTML控件中取得一个值，并存入一个模型中。这种绑定会通过一个名叫`$event`的事件对象来传递有关这个事件的信息（包括数据值）。
事件对象的形态取决于目标事件本身。如果目标事件是一个原生的DOM元素事件，$event就是一个DOM事件对象，有如`target`和`target.value`这样的属性。如：

```HTML
<input [value]="currentUser.firstName" (input)="currentUser.firstName=$event.target.value" >
```

这个例子会把输入框的value绑定到firstName属性，并通过绑定到输入框的input事件来监听更改。当用户更改输入框的文本时，input事件就会被触发，对应的模板声明就会被执行，且该模板声明的上下文里包含了一个DOM事件对象变量（`$event`），要更改firstName属性，就必须通过$event.target.value来获取更改后的值。
如果这个事件属于指令（切记，组件是指令的一种），那么$event便具有指令所生成的形态。

#### 自定义事件

指令通过Angular提供的EventEmitter来触发自定义事件。指令创建一个EventEmitter实例，并将其作为一个属性暴露出来。指令调用EventEmitter.emit(payload)来触发一个事件，其中payload可以传入任何值，父指令通过绑定这个属性来监听这个事件，并通过$event对象来获取payload。
假设有一个通讯录，里面记载了联系人信息，并响应用户的动作。虽然`UseraDetailComponent`有一个删除按钮，但它自己并不知道该如何删除这个联系人。最好的做法就是触发一个事件来报告“删除联系人”的请求。

```TS
import { Component, EventEmitter, Input, Output } from '@angular/core';

@Component({
  selector: 'user-detail',
  inputs: ['user'],
  outputs: ['deleteRequest']
  template: `
  <div>
    <img src="{{userImageUrl}}">
    <button (click)="delete()">删除</button>
  </div>`
})
export class HeroDetailComponent {
  hero: User = new User('', '张三'); userImageUrl = 'images/user.png';
  @Input() prefix = '';

  deleteRequest = new EventEmitter<User>();

  delete() {
    this.deleteRequest.emit(this.user);
  }
}
```

组件定义了一个`deleteRequest`属性，这是一个`EventEmitter`实例。当点击删除按钮时，组件就会调用`delete()`方法，这个方法告诉`EventEmitter`，传递一个`User`对象。假设作为宿主的父组件绑定到了`UserDetailComponent`的`deleteRequest`事件：

```HTML
<user-detail (deleteRequest)="deleteUser($event)" [user]="currentUser"></user-detail>
```

当`deleteRequest`事件触发时，Angular就会调用父组件的`deleteUser`方法，在`$event`中传入要删除的联系人（来自`UserDetail`）即可。deleteUser方法删除联系人会更新模型，也可能触发其他修改，包括向远端服务器的查询和保存。这些变更会通过系统进行扩散，并最终显示到当前以及其他视图中。

### 3.2.5 双向数据绑定

当开发数据输入表单时，期望的结果是既能将组件的数据显示到表单上，也能在用户修改时更新组件的数据。之前了解到的属性绑定和事件绑定已经可以实现了这种双向绑定效果：

```HTML
<input [value]="currentUser.firstName"
       (input)="currentUser.firstName=$event.target.value" >
```

这种实现看起来很繁琐，谁能记住哪个元素属性用于设置，哪个用于汇报用户更改？又该如何从输入框中提取出当前显示的文本，以便更新数据属性？谁想每次都去查一遍？使用Angular里的NgModel指令可以更便捷的进行双向绑定。

```HTML
<input
  [ngModel]="currentUser.firstName"
  (ngModelChange)="currentUser.firstName=$event">
```

ngModel指令通过它自己的`ngModel`输入属性和`ngModelChange`输出属性隐藏了这些繁琐的细节。这样看起来虽然好一点，但还是不够，没必要对同一个数据源进行两次数据绑定，于是Angular指定了一种新语法来支持双向数据绑定`[()]`。

```HTML
<input [(ngModel)]="currentUser.firstName">
```

就是这么简单。`[]`实现了数据流从组件到模板，`()`实现了数据流从模板到组件，两者一结合`[()]`就实现了双向绑定，形象的形容这种语法就叫做“盒子里的香蕉”。也可以用前缀形式的语法：

```HTML
<input bindon-ngModel="currentUser.firstName">
```

`[()]`这种语法只能设置一个数据绑定属性，如果需要做更多或不同的事情，就需要它的展开形式来实现，比如强制让输入值变为大写形式：

```HTML
<input
  [ngModel]="currentUser.firstName"
  (ngModelChange)="setUpperCaseFirstName($event)">
```

### 3.2.6 输入和输出属性

在一个绑定声明中，出现在绑定声明右侧的，称之为数据绑定的 __源__ 。出现在绑定声明左侧的，称之为绑定到的 __目标__ ，这些指令的属性必须被声明成 __输入__ 或 __输出__ 。切记，所有的组件皆为指令。

绑定目标和绑定源的区别

{% raw %}

绑定目标 | 绑定源
------- | ------
在`=`左侧 | 在`=`右侧
是绑定符`[]`、`()`、`[()]`中的属性或事件名 | 是引号`""`中的部分或插值符号`{{}}`中的部分
访问目标指令中的成员会受到限制，只能绑定到那些显示标记为输入或输出的属性 | 源指令中的每个成员都会自动在绑定中可用，不需要特别做什么，就能在目标表达式或语句中访问指令的成员。

{% endraw %}

看下面这个示例：

```HTML
<user-detail [user]="currentUser" (deleteRequest)="deleteUser($event)">
</user-detail>
```

`UserDetail.user`和`UserDetail.deleteRequest`都位于绑定声明的左侧，所以它们是绑定的目标。其中，`UserDetail.user`是属性绑定的目标，`UserDetail.deleteRequest`是事件绑定的目标。数据通过模板声明流向`UserDetail.user`目标属性，所以`UserDetail.user`相对`UserDetail`而言是一个输入属性。同样，在事件声明中，数据流出`UserDetail.deleteRequest`目标属性，传递给接收者，所以相对`UserDetail`而言，`UserDetail.deleteRequest`是一个输出属性。输入属性通常接收数据值，输出属性暴露事件生产者，比如`EventEmitter`对象，输入和输出都是从目标指令的视角来说的，比如`UserDetail`。而绑定的组件成员`currentUser`和`deleteUser`位于绑定声明的右侧，所以它们是绑定的源，它们既不是`UserDetail`的输入属性，也不是`UserDetail`的输出属性，仅仅是绑定中的数据源。

#### 声明输入和输出属性

目标属性必须被显示的标记为输入或输出。有两种方式用来声明，但切记不要同时使用。
方式一：通过`@Input`或者`@Output`装饰器

```TS
@Input()  user: User;
@Output() deleteRequest = new EventEmitter<User>();
```

方式二：在指令元数据的`inputs`或`outputs`数组中标记出这些成员。

```TS
@Component({
  inputs: ['user'],
  outputs: ['deleteRequest'],
})
```

#### 输入/输出属性别名

有时需要让输入/输出属性的公开名字不同于内部名字，比如使用HTML标签特性(Attribute)型指令时。因为在指令类中，直接用指令名字作为属性名通常不是很好，指令名很少能描述这个属性是做什么的。比如：

```HTML
<div (myClick)="clickMessage=$event">点击</div>
```

`myClick`这个指令名对于用来发出`click`消息的属性就算不上一个好名字。幸运的是，Angular2可以做到这一点，在外部使用一个公开的名字，同时在内部使用另一个不同的名字，也有两种方法实现。
方式一：通过`@Input`/`@Output`装饰器为属性指定别名

```TS
@Output('myClick') clicks = new EventEmitter<string>(); //  @Output(alias) propertyName = ...
```

方式二：在指令元数据的`inputs`或`outputs`数组中为属性指定别名。用":"来分隔，左侧是指令中的属性名，右侧是公开的别名

```TS
@Directive({
  outputs: ['clicks:myClick']  // propertyName:alias
})
```

### 3.2.7 数据绑定中的中括号

中括号会告诉Angular要计算模板表达式。如果忘记了中括号，Angular就会把这个表达式当做一个字符串常量看待，并且用该字符串来 __初始化目标属性__ ，而不会计算这个字符串。所以不要出现这样的错误：

```HTML
<!-- ERROR: UserDetailComponent.user expects a
     User object, not the string "currentUser" -->
  <user-detail user="currentUser"></user-detail>
```

但是当满足下面三个条件时，又要 __省略中括号__ 。

* 目标属性接受字符串值
* 这个字符串是一个固定的值
* 初始值永不改变

在标准的HTML中经常用用这种方式初始化HTML标签特性（Attribute），这种方式也可以用在初始化指令和组件的属性。 下面这个例子把`UserDetailComponent`的`prefix`属性初始化成了一个固定的字符串，而不是模板表达式。注意与`user`的对比，`user`是可以改变的。

```HTML
<user-detail prefix="你是我" [user]="currentUser"></user-detail>
```

## 3.3 模板引用变量

### 3.3.1 定义及作用域

模板引用变量是模板中对DOM元素或指令的引用。模板引用变量能在DOM元素中使用，也能用于Angular组件。使用中可以在同一元素、兄弟元素或任何子元素中使用模板引用变量。想把谁定义为模板引用变量，只需在其前面加上`#`符号，或者`ref-`前缀。如：

```HTML
<input #phone placeholder="phone number">
<button (click)="callPhone(phone.value)">电话</button>

<input ref-fax placeholder="fax number">
<button (click)="callFax(fax.value)">传真</button>
```

Angular会自动把这种变量的值设置为它当前所在的那个元素。如例子中在这个`input`元素上定义了这些变量，把那些`input`元素对象传递给了`button`元素，即它们被当做参数传给了事件绑定中的`call`方法。

### 3.3.2 NgForm和模板引用变量

```HTML
<form (ngSubmit)="onSubmit(theForm)" #theForm="ngForm">
  <div class="form-group">
    <label for="name">姓名</label>
    <input class="form-control" required ngControl="firstName"
      [(ngModel)]="currentHero.firstName">
  </div>
  <button type="submit" [disabled]="!theForm.form.valid">提交</button>
</form>
```

在这个例子中，模板引用变量`theForm`出现了三次，中间还隔了一个段的HTML。如果Angular没有接管这个变量，那它可能是个HTML表单元素。但实际上它是个`ngForm`，一个对Angular内建指令`NgForm`的引用。既包装了原生的HTML表单元素又赋予了它额外的“超能力”，如跟踪用户输入的有效性，比如通过检查`theForm.form.valid`就可以禁用提交按钮，以及如何把一个信息量略大的对象传给父组件的`onSubmit`方法。

## 3.4内置指令

由于可以从简化复杂任务的指令中获益，Angular带有内置指令。

### 3.4.1 NgClass

实际应用中会通过动态添加或删除CSS类的方式来控制元素如何显示。在Angular中，通过绑定`NgClass`，可以同时添加或删除多个类。
CSS类绑定是添加和移除单个类的最佳途径，如：

```HTML
<!-- 通过isSpecial属性来切换special的开关 -->
<div [class.special]="isSpecial">这个类绑定是特殊的</div>
```

但当同时添加或移除多个CSS类时，`NgClass`指令会更好一些。应用`NgClass`最好的方式是绑定到一个key:value形式的控制对象，对象中的每个key都是一个CSS类名，如果它的value为true，这个类就被添加，反之被移除。比如有这么一个组件方法`setClasses`，用于管理三个CSS类的状态：

```ts
setClasses() {
  let classes =  {
    saveable: this.canSave,      // true
    modified: !this.isUnchanged, // false
    special: this.isSpecial,     // true
  };
  return classes;
}
```

然后通过添加一个`NgClass`属性绑定，就可以通过调用`setClasses`类设置元素的类了，如：

```HTML
<div [ngClass]="setClasses()">这个div是可保存和特殊的</div>
```

### 3.4.2 NgStyle

实际中可以基于组件的状态来动态设置内联样式。绑定到`NgStyle`可以同时设置很多内联样式。
样式绑定是设置单一样式的简单方式，如：

```HTML
<div [style.font-size]="isSpecial ? 'x-large' : 'smaller'" >
  这个div是大号的。
</div>
```

如果要同时设置多种内联样式，`NgStyle`指令是更好的选择。与`NgClass`类似，通过把它绑定到一个key:value控制对象的形式使用`NgStyle`。对象的每个key是样式名，它的value就是能用于这个样式的任何值。假设有一个类似于`setStyles`的组件方法，它返回一个定义三种样式的对象：

```TS
setStyles() {
  let styles = {
    // CSS属性名
    'font-style':  this.canSave      ? 'italic' : 'normal',  // italic
    'font-weight': !this.isUnchanged ? 'bold'   : 'normal',  // normal
    'font-size':   this.isSpecial    ? '24px'   : '8px',     // 24px
  };
  return styles;
}
```

通过添加一个`NgStyle`属性绑定，让它调用`setStyles`，并据此来设置元素的样式：

```HTML
<div [ngStyle]="setStyles()">
	这个div的样式是italic, normal weight, 和extra large (24px)。
</div>
```

### 3.4.3 NgIf

通过把`NgIf`指令绑定到一个真值表达式，可以把一个元素及其子元素添加到DOM树上。

```HTML
<div *ngIf="currentUser">Hello,{{currentUser.firstName}}</div>
```

相反，绑定到一个假值表达式将从DOM树中移除该元素及其子元素。如：

```HTML
<!-- 因为isActive的值为false，所以User Detail不在DOM树种-->
<user-detail *ngIf="isActive"></user-detail>
```

#### 与类绑定/样式绑定的区别

通过类绑定或样式绑定可以实现显示和隐藏一个元素及其子元素。当我们隐藏一个子DOM树时，它仍然会保留在DOM中。子树中的组件及其状态仍然保留着。即使对于不可见属性，Angular也会继续检查变更。子树可能占用相当可观的内存和运算资源。而当`NgIf`为`false`时，Angular从DOM中实际移除了这个元素的子树。它销毁了子树中的组件及其状态，也潜在释放了可观的资源，最终让用户体验到更好的性能。
显示/隐藏技术用在小型元素上可能还不错，但在隐藏大树时就要小心，此时`NgIf`可能是更好更安全的选择。

### 3.4.4 NgSwitch

当需要从一组可能的元素树种根据条件显示其中一个时，就需要`NgSwitch`了。Angular2将只把选中的元素添加进DOM中。如：

```HTML
<span [ngSwitch]="userName">
  <span *ngSwitchCase="'张三'">张三</span>
  <span *ngSwitchCase="'李四'">李四</span>
  <span *ngSwitchCase="'王五'">王五</span>
  <span *ngSwitchCase="'赵六'">赵六</span>
  <span *ngSwitchDefault>龙大</span>
</span>
```

把作为父指令的`NgSwitch`绑定到一个能返回开关值的表达式，例子中这个值是字符串，但它可以是任何类型的值。父指令`NgSwitch`控制一组`<span>`子元素。每个`<span>`或者挂在一个匹配值的表达式上，或者被标记为默认情况。任何时候，这些span中最多只有一个会出现在DOM中。如果这个span的匹配值和开关值相等，Angular2就把这个`<span>`添加DOM中。如果没有任何span匹配上，Angular2就会把默认的span添加到DOM中。Angular2会移除并销毁所有其他的span。

三个相互合作的指令：
* ngSwitch：绑定到一个返回开关值的表达式
* ngSwitchCase：绑定到一个返回匹配值的表达式
* ngSwitchDefault：一个用于标记默认元素的属性
注意：不要再ngSwitch前使用`*`，而应该用属性绑定，但ngSwitchCase和ngSwitchDefault前面要放`*`。

### 3.4.5 NgFor

`NgFor`是一个迭代器指令。当需要展示一个由多个条目组成的列表时就需要这个指令了。如下面这个例子，就是在一个HTML块上应用`NgFor`。

```HTML
<div *ngFor="let user of users">{{user.fullName}}</div>
```

`NgFor`也可以应用在一个组件元素上，如：

```HTML
<user-detail *ngFor="let user of users" [user]="user"></user-detail>
```

注意不要忘了`NgFor`前面的`*`。赋值给`NgFor`的字符串并不是一个模板表达式，而是由Angular自己解释的小型语言——一种微语法。在例子中，Angular会取出users数组中的每个user，把它储存在一个局部变量user中，使其在每个迭代中对模板HTML可用。
user前面的let关键字创建了一个名叫user的模板输入变量（注意，与模板引用变量不是一回事）。在模板中使用这个模板变量来访问user的属性，就像在插值表达式所做的那样。也可以把这个变量传给组件元素上的一个绑定，就像第二个例子中对user-detail所做的那样。

#### NgFor中的索引

`ngFor`指令支持一个可选的`index`索引，在迭代过程中会从0增长到“当前数组中的长度”。可以通过模板输入变量来捕获这个index，并应用在模板中。下面的例子就把index捕获到了一个名为`i`的变量中。

```HTML
<div *ngFor="let user of users; let i=index">{{i + 1}} - {{user.fullName}}</div>
```

#### NgForTrackBy

ngFor指令有时性能会比较差，特别是在大型列表中。对一个条目的小改动都会导致级联的DOM操作。比如，当通过重新从服务器来刷新通讯录，刷新后的列表可能包含很多（如果不是全部的话）以前显示过的联系人。但在Angular看来，它不知道哪些是以前就存在过的，只能清理旧列表、舍弃那些DOM元素，并用新的DOM元素来重建一个新列表。
解决这个问题，可以通过追踪函数来避免这种折腾。追踪函数会告诉Angular：我们知道两个具有相同user.id的对象是同一个联系人。如：

```TS
trackByUsers(index: number, user: User){return user.id}
```	

然后，把NgForTrackBy指令设置为那个追踪函数：

```HTML
<div *ngFor="let user of users; trackBy:trackByUsers">({{user.id}}) {{user.fullName}}</div>
```

追踪函数不会排除所有DOM更改。如果用来判断是否为同一个联系人的属性变化了，就会更新DOM元素，反之就会留下这个DOM元素。列表界面就会变得比较更加平滑，拥有更好的响应效果。

##3.5 表单
通过上章节对模板数据绑定的属性绑定和事件绑定的学习，基本能用模板实现大部分的数据展示功能了，但是既然有展示数据，那必需要有数据采集的入口。接下来进一步学习数据采集的入口`表单`。

表单作为数据采集的重要入口，几乎是所有web应用必不可少的一部分，使用场景很广泛，常见的场景有新用户注册，用户登陆、各类数据的添加修改、问卷调查、文件上传等等。html提供了许多表单标签如文本、密码、单选框、复选框等，且内置简单校验，但是内置校验提示效果在各个浏览器表现都不同，校验错误提示文字各异，无法统一，且与应用本身的UI风格相差甚远，其次，自定义校验规则、表单数据获取、处理、提交等流程异常复杂。

针对上述问题，Angular团队在Angular中对表单进行了封装扩展，为校验、提示、自定义UI、数据处理等问题提供了很好的解决方案。Angular模板表单能随意控制表单的布局、使用双向绑定数据、设置校验规则、显示自定义校验错误提示、自定义校验错误提示样式效果、根据输入结果开启禁用表单等等。通过Angular表单，可以使用简洁的代码、灵活接口，构建丰富交互体验、强用户引导的表单。

Angular有模板驱动(Template-Driven Forms)及模型驱动(Model-Driven Forms)两种方式构建表单，模板驱动模式使用内置表单指令、内置校验，能快速构建简单表单；模型驱动模式使用`FormBuilder`可以自定义表单、自定义校验，能构建灵活、复杂的表单。接下来的内容，将重点学习模板驱动方式构建表单，同时在自定义表单校验小节将通过学模型驱动方式构建表单来学习自定义表单校验。
###3.5.1 模板中的表单
在组件中使用模板可以构建任何视图，也包括表单。

下面，先通过添加新联系人表单来了解模板中的表单，表单效果如图2.3-1。

![MacDown logo](https://raw.githubusercontent.com/gf-rd/gf-angular2-book/master/_images/chapters3-5/add-contact-form.png)

图 2.3-1 添加新联系人表单

在添加新联系人表单中，需收集联系人的姓名、电话、住址、邮箱、生日等信息，在模板中加入表单及控件元素，如下所示：

```js
@Component({
  selector: 'my-form'，
  template: `
  <h3>修改联系人</h3>
  <form>
    <ul>
		<li class="form-group" >
		  <label for="name">姓名：</label>
		  <input type="text"  name="name"/>
		</li>
		<li class="form-group" >
          <label for="telNum">电话：</label>
          <input type="text"  name="telNum"/>
       </li>
       <li class="form-group" >
          <label for="address">住址：</label>
          <input type="text"  name="address"/>
       </li>
       <li class="form-group" >
          <label for="email">邮箱：</label>
          <input type="text"  name="email"/>
       </li>
       <li class="form-group" >
          <label for="birthday">生日：</label>
          <input type="text"  name="birthday"/>
       </li>
		<li class="form-group">
		  <button type="submit" class="btn btnAngular-default">添加</button>
		  <button type="button" class="btn btn-default">取消</button>
		</li>
	</ul>
  </form>
  `，
})
```
如上例子所示，在Angular模版中构建表单其实就是将普通HTML中构建表单的代码直接搬到了组件的模板中。这里构建的模板表单只是实现了一个简单的表单视图，并未添加任何交互处理。在Angular中，表单的交互是由表单的特有的指令实现的，下面将通过表单指令深入讲解Angular的表单。

###3.5.2 表单指令
表单指令是Angular对常用的表单交互功能进行封装扩展，负责处理大多数绑定数据、指定校验规则、显示校验错误等重复单调的任务，使我们能在模板中快速构交互友好的表单。接下来会一一讲解各个表单指令的功能及指令引申出的相关知识点，涉及的内容包括：

* 表单的控制中心`NgForm`指令
* 表单双向数据绑定`NgModel`指令
* 表单及表单控件的局部变量
* 表单状态追踪及数据校验
* 表单分组`ngModelGroup`指令
* 表单数据提交`NgSumit`指令

####NgForm表单
`NgForm`指令是表单的控制中心，负责处理表单内的页面逻辑，为普通的Form元素扩充了许多额外的特性，所有的表单指令都需要在`NgForm`指令内部才能正常运行。先来看看在模板中如何使用`NgForm`指令。

通过

```js
import { provideForms } from '@Angular/forms';
```
引入`provideForms`组件，在根组件上注入表单的依赖：

```js
bootstrap(AppComponent， [provideForms()]);
```
代码调用`provideForms`方法，方法返回表单的相关服务，将返回的服务结果传给 providers 数组参数，通过bootstrap方法在根组件上注入表单的依赖、注册新表单模块。

注册完成后就可以在所有的模板中使用`NgForm`指令，如下：

```html
<h3 class="nav-bar">添加联系人</h3>
<div class="container">
  <form>
  ...
  </form>
</div>
```
代码中并未出现`NgForm`相关的指令，为什么说已经使用了`NgForm `指令？因为通过`providers`数组参数注册了表单模块后，Angular模板在编译解析时，遇到`form`标签会自动创建一个`NgForm`指令并且关联到对应的`form`标签上。`NgForm`指令会为表单建立一个控件组对象，作为表单控件的容器。使用控件组对象，可以通过＃符号定义表单局部变量contactForm，并将contactForm变量初始化为`ngFrom`，来引用该控件组对象，如下：
   
```html
<form #contactForm="ngForm">
...
</form>
```
通过表单局部变量contactForm可以控制整个表单及表单组件的有效性，追踪表单组件的状态。表单局部变量contactForm的应用，下面表单校验及自定义css类小节会详细讲解。

前面介绍了属性绑定、事件绑定及双向数据绑定，接下来讲解数据绑定在表单中的运用。

####NgModel 数据绑定
`NgModel`指令实现表单控件的数据绑定，提供控件状态跟踪及校验功能。`NgModel`指令是表单数据绑定的核心所在，是表单运用中最重要的一个指令，表单几乎所有的特性都依赖`ngModel`指令实现。Angular默认是单向数据绑定，也可以实现双向数据绑定。接下来首先分别通过表单单向数据绑定和表单双向数据绑定来认识表单数据绑定，接着学习常用的表单控件实现双向数据绑定的异同。

##### 表单单向数据绑定
下面通过一个例子学习表单单向数据绑定：

```js
@Component({
  selector: 'my-form'，
  template: `
  <h3 class="nav-bar">修改联系人</h3>
  <div class="container">
  <form #contactForm="ngForm">
    <ul>
		<li class="form-group" >
		  <label for="name">姓名：</label>
		  <input type="text" class="form-control" name="name"  [ngModel]="curContact.name" >
		</li>
		<li class="form-group" >
          <label for="telNum">电话：</label>
          <input type="text" class="form-control" name="telNum"  [ngModel]="curContact.telNum">
       </li>
		...
		<li class="form-group">
		  <button type="submit" class="btn btn-default">添加</button>
		  <button type="button" class="btn btn-default">取消</button>
		</li>
	</ul>
  </form>
  </div>
  `，
})
export class FormComponent { 
  curContact: any = {
    name: '李四'， 
    telNum: '15876352804'，
    address: '深圳市XXX'，
    email: '123455@qq.com'，
    birthday: '2016-01-01'
  };
}
```
例子中，构建了一个修改联系人表单组件，并创建一个联系人的数据，通过`[ngModel]`将创建的联系人数据绑定到表单控件。`[]`实现的是单向绑定，即从组件数据模型中修改的数据能触发视图中控件的值修改，但是在视图中修改的控件的值，不能反应到组件数据模型中。在纯粹展示数据的表单中，可以使用`［］`将模型中的数据绑定到表单视图。
>在表单中使用`ngModel`，必需给控件添加name属性(如name="name")，否则会报错。

##### 表单双向数据绑定
Angular默认是单向绑定，但也支持双向数据绑定，既绑定到控件的模型数据能显示在视图上，同时当控件输入的数据变更时，能同步到组件模型数据里。回顾数据绑定小节中引入的双向数据绑定语法`[()]`，正是为表单控件双向绑定量身定制的。使用`[()]`将姓名控件代码修改如下：
   
``` html
<input type="text" name="name" [(ngModel)]="curContact.name">
```
也可以用前缀形式的语法

``` html
<input type="text" class="form-control" name="name" bindon-ngModel="curContact.name">
```
此时，在页面姓名控件中输入"张四"，组件数据模型中curContact.name值变为"张四"，修改组件数据模型curContact.name值为"张三"，页面姓名控件的值实时变更显示为"张三"。

`[()]`是如何实现双向数据绑定的呢？当Angular在表单中看到一个`[(x)]`的绑定目标时，`x`指令会有一个名为`x`的输入属性，和一个名为`xChange`的输出属性。同理，当Angular遇到`[(ngModel)]`时会翻译成一个`ngModel`的输入属性和一个`ngModelChange`的输出属性，自动地完成了属性绑定和事件绑定。因此，在表单中也可以使用下面的方法实现双向绑定，效果是一样的。

``` html
<input type="text" name="name" [ngModel]="curContact.name" (ngModelChange)="curContact.name = $event">
```
这里值得注意的是`curContact.name = $event`，以前看到的`$event`变量是来自 DOM 事件的， 但 ngModelChange 是一个 Angular EventEmitter 类型的属性，不会生成 DOM 事件。当它触发时，返回的是输入控件的值，因此`[ngModel]="curContact.name" (ngModelChange)="curContact.name = $event"`也能实现双向数据绑定。

不可否认，Angular`[()]`双向数据绑定的处理确实很方便，让开发者在开发过程中，避免考虑很多的问题。然而有时候并不希望出现这种自动化的处理。在复杂的数据绑定场景，更希望定制化的输入输出控制，例如需要把用户输入的内容首字母变成大写字母，此时，可以将属性绑定跟事件绑定进行拆分，如下：

```html   
  <input [ngModel]="curContact.name"  (ngModelChange)="setUpperCaseFirstName($event)">
```

```js
export class FormComponent { 
  setUpperCaseFirstName(value){
  	//此处实现将首字母变大写
  }
}
```
在比较通用的业务场景里，`[(ngModel)]`可以使代码变得更简洁，若是复杂的数据处理，可以通过展开成属性绑定和事件绑定对数据进行特殊处理。

##### 常用表单控件的双向数据绑定
上面介绍表单数据绑定知识点主要以文本域控件为例子，下面将介绍其他常用控件类型的双向数据绑定如何实现。

######数值域（number）
数值域控件的双向数据绑定实现与文本域控件的一致，如下：

```html
<li class="form-group" >
  <label for="telNum">电话：</label>
  <input type="number" class="form-control" name="telNum"  [(ngModel)]="curContact.telNum">
</li>
```

######单选框（radio）
单选框的双向数据绑定与文本域控件类似，同一组的所有单选框控件都绑定同一个模型数据，同一个name属性，如下所示：

```html
<li class="form-group" >
  <label for="sex">性别：</label>
  <input type="radio" class="form-control" name="sex" [(ngModel)]="curContact.sex" value="female">女
  <input type="radio" class="form-control" name="sex" [(ngModel)]="curContact.sex" value="male">男
</li>
```
例子中是一个选择性别的单选框，男和女单选框的`ngModel`绑定的是同一个值`curContact.sex`，当点击“女”单选框，`curContact.sex`会被赋值为“女”单选框控件所对应值“female”，同理，当点击“男”单选框，`curContact.sex`会被赋值为“男”单选框控件所对应的值“male”。

######单选下拉框（select）
Angular的单选下拉框由`NgSelectOption`指令实现，有两种用法，一种选中返回的是基本类型数据，另一种选中返回的是对应选中的数据对象。

在构建下拉框前，先定义下拉框列表需要的数据：

```js
export class FormComponent { 
  ...
  let interests:any[] = [
   { value: 'reading'， display: '阅读' }，
   { value: 'traveling'， display: '旅游' }，
   { value: 'sport'， display: '运动' }
  ];
}
```

单选下拉框，选中返回的数据是基本类型的用法：

```html
<select name="interest" [(ngModel)]="curContact.interest">
  <option *ngFor="let interest of interests" [value]="interest.value">  
   {{interest.display}}
  </option>
</select>
```
使用`[value]`绑定单选下拉框单选项option的value属性值，输入的是单个兴趣对象的value属性对应得值。此时，如果在下拉框中选中旅游项，那么`curContact.interest`值为“traveling”。

单选下拉框，选中返回的数据是对象的用法：

```html
<select name="interestObj" [(ngModel)]="curContact.interestObj">
  <option *ngFor="let interest of interests" [ngValue]="interest">  
    {{interest.display}}
  </option>
</select>
```
使用`[ngValue]`绑定单选下拉框单选项option的value属性值，输入的是单个兴趣的整个对象。如果在下拉框中选中旅游项，则`curContact.interestObj` 值为`{ value: 'traveling'， display: '旅游' }`对象。

Angular的单选下拉框的两种用法唯一不同的是单选项option的value属性值的绑定，当绑定使用`[value]`时，表示接收的是基本类型的输入绑定，此时需使用基本类型变量作为输入值，当绑定使用`[ngValue]`时，表示接收的是复杂类型的输入绑定，此时可使用对象变量作为输入值，选择下拉框的其中一项，返回的`[(ngModel)]`的值为选中的option对应得value输入值，输入的是基本类型，则得到的是基本类型，输入的是对象，则得到的也会是对象。

###### 多选下拉框（Multiple select）
多选下拉框实现下拉选择多项的功能，多选下拉框的用法与单选下拉框类似，不同的是多选下拉框返回的数据是数组。

多选下拉框选中返回的数据是数组基本类型的用法：

```html
<select multiple name="interestMul" [(ngModel)]="curContact.interestMul">
  <option *ngFor="let interest of interests" [value]="interest.value">  
    {{interest.display}}
  </option>
</select>
```
多选下拉框与单选下拉框相同，使用`[value]`绑定单选项option的value属性值，输入的是单个兴趣对象的value属性对应得值，相对单选下拉框多了`multiple`指令属性。此时，在多选下拉框中选中旅游和运动两项，则`curContact.interestMul`返回值为`["traveling"，"sport"]`数组。

多选下拉框选中返回的数据是数组对象的用法：

```html
<select name="interestMulObj" [(ngModel)]="curContact.interestMulObj">
  <option *ngFor="let interest of interests" [ngValue]="interest">  
    {{interest.display}}
  </option>
</select>

```
多选下拉框与单选下拉框相同，使用`[ngValue]`绑定单选项option的value属性值，输入的是单个兴趣对象的值，相对单选下拉框多了`multiple`指令属性。如果在多选下拉框中选中旅游和运动两项，那么`curContact.interestMulObj`返回值为`[{ value: 'traveling'， display: '旅游' }，{ value: 'sport'， display: '运动' }]`数组对象。

>值得注意的是，rc3版本，多选下拉框支持还不全面，经测试，多选下拉框在pc chrome中，选择需按住鼠标才能选择多个，在android中多选选择无效，在使用时需谨慎测试。

######复选框（Checkbox）
Angular复选框选中与否，复选框控件的绑定输出的是布尔值，表示该复选框表单是否选中。

```html
  <input type="checkbox" name="lock" [(ngModel)]="curContact.lock">禁用
```
上述例子中，若复选框选中`curContact.lock`为true，未选中则为false。对于通过勾选复选框实现其他表单禁用、启用等，返回布尔值十分有优势。

但是如果需要通过复选框来收集有意义的数据，就需要获取选中的复选框对应得value值，此时可以通过巧妙的方式实现。构建一个隐藏的表单`interestCheckbox`，用于存放复选框选中的值，添加复选框表单change事件，通过`$event.target.checked`获取该复选框是否被选中，设置选中时的值及未选中时的值，如下：

```html
<li>
   <label>兴趣爱好(复选框)</label>
   <input type="hidden" name="interestCheckbox" [(ngModel)]="curContact.interestCheckbox">
   <input type="checkbox"  (change)="setInterestCheckboxValue($event.target.checked，'reading')">阅读
   <input type="checkbox"  (change)="setInterestCheckboxValue($event.target.checked，'traveling')">旅游
   <input type="checkbox"  (change)="setInterestCheckboxValue($event.target.checked，'sport')">运动
</li>
<li>选中复选框的值：{{curContact.interestCheckbox|json}}</li>
```

```js
export class FormComponent { 
  public curContact = {
  	interestCheckbox:[] 
  };
  setInterestCheckboxValue(checked: Boolean, value: String){
    let index:number = this.curContact.interestCheckbox.indexOf(value);
    if(checked){
      if(index < 0){
        this.curContact.interestCheckbox.push(value);
      }
    }else{
      if(index > -1){
        this.curContact.interestCheckbox.splice(index，1);
      }
    }
  }
}
```
例子中，当点击复选框时，触发setInterestCheckboxValue方法并将`$event.target.checked`及复选框对应的value值作为参数传入。当该复选中被选中，且`curContact.interestCheckbox`中还没有value对应得值时，将value值push进curContact.interestCheckbox数组中。当该复选框被取消选中时，且`curContact.interestCheckbox`中存在value对应得值时，将value值从curContact.interestCheckbox数组中移除。curContact.interestCheckbox双向绑定到隐藏控件中，因此，提交隐藏控件中的值就相当于提交复选框的值。

####表单中的局部变量
模板中可以定义局部变量，表单中也可以定义局部变量，模板表单中的局部变量与模板中普通的局部变量有些区别。模板中普通的局部变量通过#定义，默认赋值为当前元素Dom对象的引用，能直接在模板中获取元素的属性值，如className、value等。模板表单中的局部变量在定义时会被赋值为表单指令对象的引用，能追踪表单的状态及有效性。

之前学习`NgForm`指令时定义的局部变量contactForm，当表单控件加入`ngModel`及`name`属性后，局部变量contactForm的value属性值的最大作用也得以体现。如下代码：

```
<form #contactForm="ngForm">
	<ul>
		<li class="form-group" >
		  <label for="name">姓名：</label>
		  <input type="text" class="form-control" name="name"  [(ngModel)]="curContact.name" >
		</li>
		<li class="form-group" >
	      <label for="telNum">电话：</label>
	      <input type="text" class="form-control" name="telNum"  [(ngModel)]="curContact.telNum">
	   </li>
		...
	</ul>
</form>
```
可获取contactForm.value的值为：

```js
{
	name: undefined，
	telNum: undefined
}
```
contactForm.value属性是一个简单的JSON对象，键对应控件元素的`name`属性值，值对应于控件元素的值。 控件在初始状态，值都为`undefined`。当往姓名控件输入`李四`，电话控件输入`12345678901`，再获取contactForm.value的值为：

```js
{
	name: '李四'，
	telNum: '12345678901'，
}
```
对于简单的AJAX请求提交表单采集的数据，这无疑是令人兴奋的功能，直接将表单局部变量contactForm的value提交即可，不需要自己构建JSON对象，非常简洁方便。

表单可以定义局部变量，表单控件也可以定义局部变量。以姓名控件为例，添加自定义局部变量：

```html
<input type="text" class="form-control"  name="name" [(ngModel)]="curContact.name"  #name="ngModel">
```
此处控件局部变量name初始化为`NgModel`，在定义表单局部变量contactForm时初始化为`ngForm`。 两者的区别是表单局部变量contactForm为`NgForm`指令，是`NgForm`实例对象的引用，控件局部变量name为`ngModel`指令，是`ngModel`实例对象的引用。
>Angular是通过指令的`exportAs`值，与对应的指令对象关联起来的，`NgForm`指令的`exportAs`值为`ngForm`，`NgModel`指令的`exportAs`值为`ngModel`。

Angular为什么要提供引用`NgForm`的表单局部变量和引用`ngModel`控件局部变量的用法呢？因为这些局部变量为在模板中追踪表单状态及表单的数据校验提供了便利。

####表单状态追踪及数据校验
当在表单中使用`ngModel`，表单控件通过`FormControl`注册建立一个控件对象，并加入到`NgForm`指令建立的控件组中，受`NgForm`监控。`ngModel`指令会追踪表单的状态，如用户是否碰过此控件、值是否变化了，数据是否变得无效。

如何追踪表单控件的状态呢？表单`NgForm`指令及`ngModel`指令都有5个表示状态的属性，属性值为布尔类型，可通过表单局部变量获取。`NgForm`指令状态追踪的是整个表单的状态，`ngModel`指令追踪的是表单控件的状态。先看表单状态属性语义表2.3-1：

表 2.3-1   表单状态属性语义表
 
| 状态          | true          |  false     |
|------------  |:-------------:| -----------:|
| valid        | 表单值有效      | 表单值无效   |
| pristine     | 表单值未改变    | 表单值已改变  |
| dirty        | 表单值已改变    | 表单值未改变  |
| touched      | 表单已被访问过  | 表单未被访问过 |
| untouched    | 表单未被访问过  | 表单已被访问过 |

下面，以姓名控件为例，给控件添加required属性，对姓名控件进行获取焦点、输入、删除输入等操作，观察控件每一步操作的状态变化。

还未对控件进行操作前，控件的初始状态如图2.3-2。表单未进行任何输入，值未改变过，`pristine`为true，`dirty`为false。控件添加required属性，控件校验不通过，`valid`值为false。控件未被访问过，`touched`为false，`untouched`为true。

表 2.3-2   控件初始状态

| 状态          | true  |  false  |
|------------  |:-----:| -------:|
| valid        |      |   √       |
| pristine     | √     |        |
| dirty        |      | √ |
| touched      |      | √  |
| untouched    | √     |  |

在表单中输入任意字符，状态如图2.3-3。表单值被改变，`pristine`为false，`dirty`为true；表单有值，满足required要求，校验通过，`valid`值为true；因表单还未失去焦点，处于未访问过状态`touched`为false，`untouched`为true。

表 2.3-3   控件输入后的状态

| 状态          | true  |  false  |
|------------  |:-----:| -------:|
| valid        | √     |        |
| pristine     |     | √       |
| dirty        | √     |   |
| touched      |      | √  |
| untouched    | √     |  |

使表单失去焦点，处于已访问过状态`touched`为true，`untouched`为false，状态如图2.3-4。

表 2.3-4   控件失去焦点后的状态

| 状态          | true  |  false  |
|------------  |:-----:| -------:|
| valid        | √     |        |
| pristine     |      | √       |
| dirty        | √     |   |
| touched      | √      |   |
| untouched    |     | √  |

由此可见，根据表单的状态属性，可以精确的追踪表单所处的状态，根据不同的状态，可以对不同状态场景下的表单进行特定的样式或者逻辑处理。

####ngModelGroup
`ngModelGroup`指令是Angular提供的另一特色指令，可以对表单输入内容进行分组，方便我们在语义上区分不同性质的输入。例如联系人的信息包括姓名及住址，现在需对姓名和住址进行精细化信息收集，姓名可精细化成姓和名字，地址可精细化成城市、区、街等。此时就可以将姓名及住址进行分组收集，如下：

```html
<form #concatForm = "ngForm">
  <fieldset ngModelGroup="nameGroup"  #nameGroup="ngModelGroup">
    <label>姓:</label>
    <input type="text" name="firstname" [(ngModel)]="curContact.firstname" required>
    <label>名字:</label>
    <input type="text" name="lastname" [(ngModel)]="curContact.lastname" required>
  </fieldset>
  <fieldset ngModelGroup="addressGroup"  #addressGroup ="ngModelGroup">
    <label>街:</label>
    <input type="text" name="street" [(ngModel)]="curContact.street" required>
    <label>区:</label>
    <input type="text" name="zip" [(ngModel)]="curContact.zip" required>
    <label>城市:</label>
    <input type="text" name="city" [(ngModel)]="curContact.city" required>
  </fieldset>
</form>
```
上述例子分别对联系人的姓名和住址进行分组，`ngModelGroup`将姓和名字的表单内容进行包裹组成姓名分组，将城市、区和街道的表单内容进行包裹组成住址分组。此时concatForm.value值为：

```js
{
  nameGroup: {
    firstname: ''，
    lastname: ''，
  }，
  addressGroup: {
    street: ''，
    zip: ''，
    city: ''
  }
}

```
由此可见concatForm.value值也被相应分组展示，这样既收集到精细化的姓名及住址数据，也可以很方便地通过精细化的姓名及住址数据组合成完成的姓名及住址数据。

除此之外，`ngModelGroup`实例对象的valid可单独校验`ngModelGroup`下的所有添加了`ngModel`的控件输入是否有效。如当firstname输入有效，lastname输入不有效，姓名分组局部变量nameGroup.valid为false。当firstname、lastname输入都有效，姓名分组局部变量#nameGroup.valid为true。

####NgSumit 提交表单数据
`NgSumit`指令响应表单`submit`提交按钮，负责控制管理表单提交的流程。当提交按钮被点击，会触发表单添加的`ngSubmit`事件。

```html
<form #contactForm="ngForm" (ngSubmit)="onSubmit(contactForm.value)">
 ...
 <li class="form-group">
    <button type="submit" class="btn btn-default" >添加</button>
 </li>
</form>
```
```js
export class FormComponent { 
  onSubmit(form: any){
    //处理form数据并提交
  }
}
```
例子中，绑定了`ngSubmit`事件，当提交按钮被点击，执行绑定`onSubmit`组件方法，并contactForm.value的值作为参数传入，在`onSubmit`方法中进行数据处理及上传。

在许多应用场景中，往往会接触到表单验证未通过的场景下，提交按钮是灰置并且不能点击的需求。这样的场景，在Angular实现如下：

```html
<button type="submit" class="btn btn-default" [disabled]="!contactForm.valid">添加</button>
```
代码中只添加了`[disabled]="!contactForm.valid"`，绑定提交按钮的`disabled`属性，当输入表单值全部检验通过时contactForm.valid为true。相反，如果有其中一个或多个表单值校验不通过，contactForm.valid为false。只添加短短的一条代码就实现在未完全输入正确的数据时，提交按钮不能点击的效果，避免了许多无效的点击和请求，减轻了服务器的负载。

###3.5.3 用户自定义表单样式
`NgModel`不仅仅能追踪表单控件状态，还会根据表单控件的状态，使用对应得css状态类来更新控件类名，反映表单当前的状态。在表单指令小节介绍了`NgModel`指令在追踪表单控件状态的内容，接下来继续学习控件状态的改变在自定义控件样式方面的应用。控件状态样式类是根据控件状态变化而变化的，具体状态类详细如表2.3－5

 表 2.3-5   控件状态类名

| 状态          | 为true时的css类| 为false时的css类|
|------------  |:-------------:| --------------:|
| 控件已经被访问过| ng-touched    | ng-untouched|
| 控件值已经变化  | ng-dirty      | ng-pristine |
| 控件值是有效的  | ng-valid      | ng-invalid  |

同样以姓名控件为例，对姓名控件进行获取焦点、输入、删除输入等操作，观察控件每一步操作的状态样式类变化。

未进行任何操作前，控件初始状态下css类为：

```html
<input class="ng-invalid ng-dirty ng-touched" type="text" required>
```
在控件中输入任意字符，css类`ng-pristine`被修改为`ng-dirty`，css类`ng-invalid`被修改为`ng-valid`:

```html
<input class=" ng-untouched ng-dirty ng-valid" type="text" required>
```
控件失去焦点，css类`ng-untouched`被修改为`ng-touched`

```html
<input class="ng-touched ng-dirty ng-valid"  type="text" required>
```
删除控件中的内容，css类`ng-valid`被修改为`ng-invalid`:

```html
<input class="ng-touched ng-dirty ng-invalid"  type="text" required>
```

回顾追踪控件状态部分内容，控件css类名变化与控件状态变化一致，控件css类名根据控件状态变化而变化。使用代表控件状态的css类名，我们可以自定义css类名中的样式，实现自定义跟踪状态的效果，如：
    
```style
.ng-valid[required] { 
  border-left: 5px solid #0f0; 
}
.ng-invalid {
  border-left: 5px solid #f00; 
}
```
代码定义了当输入有效时控件样式边框为绿色，输入无效时的控件边框为红色，同理，我们可以根据这些表单状态类自定义出更加丰富的表单交互效果。

通过控件css类名自定义样式可以在视觉上给予用户反馈，当表单输入不合法时，用户可以在视觉上感知输入错误。但用户无法得知输入为什么不合法，如何纠正。在这种场景下可以添加有用的错误提示来对用户进行强引导。可配合控件的状态属性valid、pristine、dirty、touched、untouched等值，设置错误提示的显示与隐藏。

```html
<div class="form-group">
    <label for="name">姓名</label>
    <input type="text" class="form-control" minlength=3 maxlength=10 [(ngModel)]="curContact.name" name="name" #name="ngModel" required >
    <p [hidden]="name.valid || name.pristine" class="alert alert-danger">
      用户名长度为3-10个字符
    </p>
</div>
```
上述例子根据表单状态属性值，当表单在初始状态时，不显示错误提示；当表单输入值是有效时，不显示错误提示；当表单输入无效时，显示错误提示。

###3.5.4 表单验证（Validation）
表单校验是前端对表单的输入值进行检查，检查表单输入值是否满足设定的规则，不满足设定的规则，立即响应给用户。HTML5表单内置基础校验，但基础校验使用不灵活，且各个平台校验提示效果不统一，往往需要借助其他的插件。Angular表单对校验进行的封装，提供了灵活的接口，在上述问题上有很大的优势。本节将详细介绍Angular支持的内置表单校验及自定义校验。

####内置表单校验
Angular支持的内置验证包括：

* **required**: 限制表单控件值不能为空
* **minlength**: 限制表单控件值的最小长度
* **maxlength**: 限制表单控件值的最大长度
* **pattern**:  限制表单控件值必需匹配正则

使用Angular内置校验与使用普通HTML5校验一致，直接在表单控件中添加对应得校验属性即可，如下：

```
 <input type="text" minlength=3 maxlength=10 [(ngModel)]="curContact.name" name="name" required >
```

原生HTML5支持简单的校验拦截，但是提示样式及文本是固定的，不可控，屏蔽原生HTML5的校验，可以在表单中添加`novalidate`属性，如下：

```html
<form #contactForm="ngForm" (ngSubmit)="onSubmit(contactForm)" novalidate>
```
此时点击提交按钮，Html5的校验拦截不生效，直接触发onSubmit方法，可以在该方法中进行自定义校验。

表单局部变量contactForm提供了许多校验字段，可供进行自定义校验处理，如下：

```js
export class FormComponent { 
  onSubmit(form: any){
    if(!form.valid){
    	form.controls.forEach(control){
    		if(!control.valid){
    		   if(control.errors.required){
    		     // 不满足必需输入的规则
    		   }else if(control.errors.minlength){
    		     // 不满足最小输入长度限制的规则
    		   }else if(control.errors.maxlength){
    		     // 不满足最大输入长度限制的规则
    		   }
    		}
    	}
    }
  }
}
```
代码中先判断整个表单是否校验通过，若校验不通过，则遍历所有的表单控件数组controls，检查具体哪个控件校验未通过。对于校验不通过的控件，可以通过控件的errors属性定位到控件设定的哪个规则不合法，针对不同的不合法规则，进行不同的错误提示。

####自定义校验
Angular提供的内置表单校验基本能满足大部分校验场景，倘若需要实现复杂的表单校验，可以使用Angular提供的自定义校验。下文将从模型驱动模式构建表单、添加内置校验、添加自定义校验、常用控件类型添加自定义校验等方面一步一步讲解表单自定义校验。

##### 模型驱动模式构建表单
自定义校验是依赖模型驱动模式表单进行自定义的，在学习自定义校验前，先学习如何使用模型驱动模式构建表单。模型驱动模式构建表单包括下面几部分内容：

* 引入构建表单的组件
* 通过`FormBuilder`构建表单控件
* 在模板中使用构建的表单和控件

**引入构建表单的组件**

模型驱动模式构建表单必需引入`FormBuilder`、`REACTIVE_FORM_DIRECTIVES`、`FormControl`、`FormGroup`等组件：

```js
import {FormBuilder}   from '@Angular/common';
import {REACTIVE_FORM_DIRECTIVES，FormControl，FormGroup} from '@Angular/forms';
```


**构建表单控件**

注入`FormBuilder`后，在组件constructor中传入`FormBuilder`参数fb，同时使用fb.group方法构建`FormGroup`实例变量customForm。通过fb.group中传人的对象参数创建了`control`指令对象customName，并添加到`FormGroup`中。此时，customName值为['李四']，数组中第一个值为控件的默认值，其他属性配置，后面内容会详细讲解。

```js
export class FormComponent { 
  customForm: FormGroup;
  constructor(fb: FormBuilder) {  
    this.customForm = fb.group({
      'customName': ['李四']
    });  
  }
}
```

**模板中使用构建的表单和控件**

在模板中使用自定义表单`customForm`:

```js
@Component({
  selector: 'my-form'，
  directives: [REACTIVE_FORM_DIRECTIVES]
  template: `
  <h3 class="nav-bar">修改联系人</h3>
  <div class="container">
  <form [formGroup]="customForm" (ngSubmit)="onSubmit(customForm.value)"></form>
  </div>
  `，
})
```
在使用自定义控件前，需在装饰器`@Component`添加`directives: [REACTIVE_FORM_DIRECTIVES]`，声明依赖的指令。通过`formGroup`属性将自定义表单`customForm`对象绑定到表单上。在提交时可以直接使用的customForm.value，因为此时的customForm已经是`NgForm`指令对象，不需自定义表单局部变量来引用`NgForm`指令对象。
>在`NgForm`小节中讲到，Angular遇到`form`标签会自动创建一个`NgForm`指令并且关联到对应的`form`标签上。这里是一个特例，当`form`标签上使用`formGroup`属性时，相当于告诉Angular不需自动创建一个`NgForm`指令，直接使用已经存在的表单指令对象customForm。

在表单控件中使用已经存在的`control`指令对象customName，表单的`name`、`ngModel`属性都赋值为组件中定义的`Control`指令对象名customName，告诉Angular将customName控制器指令绑定到控件中：

```html
<form [ngFormModel]="customForm" (ngSubmit)="onSubmit(customForm.value)" novalidate>
 <li class="form-group" >
  <label for="name">姓名</label>
  <input type="text" class="form-control"  name="customName"  [(ngModel)]="customName">
 </li>
 ...
</form>
```

##### 添加内置校验
上文谈到构造`control`指令的值为数组，数组的第一位为控件的默认值。下文将介绍数组的第二位值，控件的校验配置。内置校验是`Validators`组件实现的，设置校验配置前需从`@Angular/forms`中引入`Validators`组件。

下面给控件添加Validators.required内置校验，添加Validators.required与直接在表单元控件素中添加required属性功能效果一致。

```js
this.customForm = fb.group({
    'customName': ['李四'，Validators.required]
}); 
```

##### 添加自定义校验

自定义校验是根据业务需求，对控件添加特定的校验。那么如何添加自定义校验呢？还是以用户名为例，先自定义用户名的校验规则：用户名必需是邮件格式或者是手机号码格式。自定义校验代码如下，若表单值不满足该用户名的校验规则，则返回userName的错误信息，满足返回null。

```js
function validateUserName(c: Control) {
  let EMAIL_REGEXP = new RegExp("[a-z0-9]+@[a-z0-9]+.com");
  let Tel_REGEXP = new RegExp("1[0-9]{10}");
  return (EMAIL_REGEXP.test(c.value) || Tel_REGEXP.test(c.value)) ? null : {
    userName: {
      valid: false，
      errorMsg: '用户名必需是正确的手机号或者邮箱账号'
    }
  };
}
```
为用户名添加自定义校验

```js
this.customForm = fb.group({
  'customName': ['李四'， validateUserName]
}); 
```
通过上文的学习，我们知道如果控件校验不通过时，控件对应的`Control`实例对象的属性errors会返回校验不合法的对象信息。当控件添加`validateUserName`自定义校验，`validateUserName`校验不通过，同样可以在控件对应的`Control`实例对象errors属性中得到自定义校验返回的userName的错误信息，如下所示：

```html
<li class="form-group">
  <label for="name">姓名</label>
  <input type="text" class="form-control" name="customName"  [(ngModel)]="customName"  #localName="ngModel">
  <p *ngIf="localName.valid || !localName.pristine">
    {{localName.errors.userName.errorMsg}}
  </p>
</li>
```
当`validateUserName`校验不通过时，会显示'用户名必需是正确的手机号或者邮箱账号'的错误提示。
>注：在`NgModel`小节中，表单的局部变量名与name属性名可以重复，但在自定义表单这里的局部变量localName与定义的`Control`指令名称不能重复，否则会报错。
>另外，需要注意的是自定义的customName为`control`实例对象，而控件局部变量localName为`NgModel`指令实例，localName获取对应的`control`实例对象可通过localName.control获取。

倘若需要在一个表单中添加多个校验，可以使用Validators.compose，用法如下：

```js
this.customForm = fb.group({
  'customName': ['李四'， Validators.compose([Validators.required， validateUserName])]
}); 
```
若表单未未同时满足配置的两个校验规则时，customName.errors为：

```js
{
	required:true，
	userName: {
      valid: false，
      errorMsg: '用户名必需是正确的手机号或者邮箱账号'
    }
}
```
可以根据属性errors内容进行强引导的错误提示文字，当表单控件未输入过时，不显示错误提示，当输入错误的用户名时，显示自定义错误信息，当再清空输入值时，显示“请填写用户名”

```html
<li class="form-group">
  <label for="name">姓名</label>
  <input type="text" class="form-control" name="customName"  [(ngModel)]="customName" #localName="ngModel">
  <p *ngIf="localName.errors && localName.errors.userName && !localName.errors.required" >
    {{localName.errors.userName.errorMsg}}
  </p>
  <p *ngIf="localName.errors && localName.errors.required && !localName.pristine">
    请填写用户名
  </p>
</li>
```

除了可以添文字强引导外，还可以通过表单状态给表单添加需要的class类名，处理更丰富的样式、提示等

```html
<div class="form-group" [class.pass]= "customForm.controls['customName'].valid">
  <label for="name">姓名</label>
  <input type="text" class="form-control" name="customName"  [(ngModel)]="customName"  #localName="ngModel">
</div>
```
当表单验证通过时添加pass的class类，通过pass类可以同时改变label、input标签的样式。

##### 模型驱动模式构建常用控件类型
上文介绍了模型驱动模式构建表单文本域控件，下面将讲解如何使用模型驱动模式构建其他常用控件类型及添加自定义校验。模型驱动模式下与模板模式下，常用控件类型在模板中的使用一样，唯一的区别是模型驱动模式构建，在模板控件的name属性和ngModel属性是自定义`Control`对象的引用。

来看一个简单的例子，在自定义表单中创建性别`Control`控件和电话号码`Control`控件，且都为必填。

```js
this.customForm = fb.group({
    'customSex': [''，Validators.required]，
    'customTelNum': [''，Validators.required]，
}); 
```
在模板中使用控件如下所示：

```html
<li class="form-group" >
	<label for="customSex">性别：</label>
	<input type="radio" class="form-control" name="customSex" [(ngModel)]="customSex" value="female">女
	<input type="radio" class="form-control" name="customSex" [(ngModel)]="customSex" value="male">男
</li>
<li>
  <label for="customTelNum">电话号码：</label>
  <input type="number" class="form-control" name="customTelNum"  [(ngModel)]="customTelNum">
</li> 
```
单选下拉框、多选下拉框、复选框等用法一样，读者可自行测试，这里不再展开。

到此为止，表单的指令、状态追踪、自定义校验等内容已经全部讲述完，下面开始学习新的模板内容－管道。

##3.6 管道（pipes）
管道是用于将模板内的数据转换成用户能快速识别的数据来显示。如日期数据，对于用户来说，只需要看日期信息，而日期的原始数据为Mon Jun 06 2016 14:17:00 GMT+0800 (CST)，这样的展示不直观，用户更喜欢直接看到转换后的日期信息2016-06-06。再如，知道活动的开始时间，在页面中需要展示活动还有多长时间开始的倒计时，这时需要通过活动的开始时间及现在时间的计算得到倒计时，再显示到页面。Angular管道可以很优雅地在模板中执行一个管道函数获取其返回值。管道使得代码更清晰，更有层次。

###3.6.1 管道的用法
管道是将获取到的原始数据作为输入数据，将转换后的期望数据作为输出数据并显示在模板中。我们使用管道操作符`|`来使用管道，操作符`|`左边为输入数据，右边为需使用的管道。下面将生日数据转换成用户友好的展示方式：

```js
@Component({
  selector: 'my-app'，
  template: `
    <p>The hero's birthday is {{ birthday | date }}</p>
  `，
})
export class AppComponent { 
   birthday = new Date(1990，3，15);
}
```
在例子中，展示友好的生日日期是通过管道操作符右边的`date`管道来实现的。输出结果为`The heros birthday is Apr 15， 1990`

####管道参数
管道可以使用参数，通过传入的参数输出不同格式的数据。如日期以固定格式输出，使用`:`符号给日期管道添加参数：

```html
<p>The hero's birthday is {{ birthday | date:"MM／dd/yyy" }}</p>
```
输出值为`The heros birthday is 04/15/1990`

####链式管道
一个模板输入可以使用多个管道进行不同的处理，这就是链式管道。我们可以使用链式管道展示更丰富的数据格式。链式管道用法如下：

```js
{{ expression | pipeName1 | pipeName2}}
```
expression值通过管道pipeName1处理后返回处理后的结果expression2，expression2再通过pipeName2管道处理，输出链式管道处理的最终结果。

```html
<p> The chained hero's birthday is {{ birthday | date | uppercase}} </p>
```
birthday链到`DatePipe`和`UpperCasePipe`上，将日期格式化成友好展示方式后再格式化为大写，结果为：`APR 15， 1990`

使用链式管道可以通过括号来控制编译的顺序，下面的例子将显示SUNDAY， APRIL 15， 1990

```html
<p> The chained hero's birthday is {{ ( birthday | date:'fullDate' ) | uppercase}} </p>
```

####管道内置指令

Angular根据常用的业务场景，封装了部分常用的内置管道指令，内置管道可以直接在任何模板中使用。下面将详细讲解每个内置管道的用法。

**DatePipe**

`DatePipe`基于所请求的格式串，格式化一个日期值，显示在模板中。使用格式：

```
expression | date:format
```
输入值expression可以为Date日期对象或者是日期字符串如`2016/04/05`;
format为日期格式，可以随意自定义，Angular提供了年月日等标志符，可以根据标志符自定义日期格式。

表 2.3-6 `DatePipe`指令日期标志符（取2016-06-08 20:05:08时间为例）

| 日期        | 标志符   | 缩写         |   全称                     |  单标志符  |      双标志符  |    
|------------ |:------:| ------------:|--------------------------:|------------:|------------:|
| 地区        | G       | G (AD)       | GGGG (Anno Domini)        | -           | -           |
| 年          | y      | -             | -                        | y (2016)     | yy (16)    
| 月          | M      |MMM (Jun)      | MMMM (June)              | M (6)        | MM (06)
| 日          | d      | -             | -                        | d (8)        | dd (08) 
| 星期        | E      | EEE (Fri)     | EEEE (Friday)            | -            |  － ｜
| 时间(AM，PM) | j      | -             |-                         | j (8 PM)     | jj (08 PM) 
| 12小时制时间 | h      | -             |-                         | h (8)        | hh (08) 
| 24小时制时间 | H      |-              |-                         | H (20)       | HH (20)
| 分          | m      | -             |-                         | m (5)        | mm (05)  
| 秒          | s      | -             |-                         | s (8)        | ss (08)  
| 时区         | Z     | -             | Z (china Standard Time)  | -            |-|
| 时区         | z     | z (GMT-8:00)  |-                         | -            |-|

根据表格2.3-6日期标识符，以月份为例，若月份需要英文缩写的话，使用`MMM`；月份展示英文全称，使用`MMMM`；需要显示数字可以使用单标志符`M`；若月份是1-9月，希望显示成含前置0效果的两位数值01-09，则使用双标志符`MM`。具体例子如下：

```js
@Component({
  selector: 'my-app'，
  template: `
   <div>
     <p>'{{date | date:"y-MM-dd EEEE"}}'</p>
  </div>
  `，
})
export class AppComponent { 
  date: date = new Date('2016-06-08 20:05:08');
}

```
结果为`2016-06-08 Wednesday`

>截止rc3版本，双标志符jj、hh 、mm、ss经过测试，并未实现添加前置0的效果。后续使用时，可先测试正确性，检查是否有更新。

Angular也提供了常用的`DatePipe`可选预定义格式，如下表

表 2.3-7 `DatePipe`可选预定义格式

| 预定义格式名   | 缩写           | 格式效果                 |
|------------  |:-------------:| -----------------------:|
| 'medium'     | 'yMMMdjms'    | Jun 6， 2016， 5:22:01 PM |
| 'short'      | 'yMdjm'       | 6/6/2016， 5:21 PM       |
| 'fullDate'   | 'yMMMMEEEEd'  | Monday， June 6， 2016    |
| 'longDate'   | 'yMMMMd'      | June 6， 2016            |
| 'mediumDate' | 'yMMMd'       | Jun 6， 2016             |
| 'shortDate'  | 'yMd'         | 6/6/2016                |
| 'mediumTime' | 'jms'         | 5:19:10 PM              |
| 'shortTime'  | 'jm'          | 5:19 PM                 |

日期管道也可以这样使用：

```html
{{ dateObj | date:'medium' }}      // 输出是 'Jun 6， 2016， 5:22:01 PM'
{{ dateObj | date:'shortTime' }}   // 输出是 '5:19 PM'
```

**JsonPipe**

`JsonPipe`将输入数据对象经过`JSON.stringify`转换后输出对象字符串，在开发调试时非常方便。

```js
@Component({
  selector: 'my-app'，
  template: `
  <div>
  <p>没经过JSON管道处理: {{jsonObject}}</p>
  <p>经过JSON管道处理:</p>
  <pre>{{jsonObject | json}}</pre>
  </div>
  `，
})
export class AppComponent { 
   jsonObject: Object = {foo: 'bar'， baz: 'qux'， nested: {xyz: 3， numbers: [1， 2， 3， 4， 5]}};
}
```
输出结果为：

```html
没经过JSON管道处理: [object Object]
经过JSON管道处理:{
  "foo": "bar"，
  "baz": "qux"，
  "nested": {
    "xyz": 3，
    "numbers": [
      1，
      2，
      3，
      4，
      5
    ]
  }
}
```
没经过JSON管道转换的，在视图中显示为对象toString后的值‘[object Object]’，无法得知对象内部的变量和值。经过JSON管道转换的，在视图中显示的是对象`JSON.stringify`后的值，在调试时可以一目了然查看对象内部变量和值，有助于快速定位问题。

**UpperCasePipe**

`UpperCasePipe` 将文本所有小写字母转成大写字母。

```
<p>{{value | uppercase}}</p>
```

**LowerCasePipe**

`LowerCasePipe ` 将文本所有大写字母转成小写字母。

```
<p>{{value | lowercase}}</p>
```

**DecimalPipe**

`DecimalPipe` 将数值转成本地化文本，用法如下：

```
expression | number[:digitInfo]
```
参数digitInfo格式为：

```
{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}
```

 * minIntegerDigits：整数部分保留最小的位数，默认值为1
 * minFractionDigits：分数部分保留最小的位数，默认值为0
 * maxFractionDigits：分数部分保留最大的位数，默认值为3
 
使用具体看下面例子：
```
{% raw %} 
@Component({
  selector: 'my-app'，
  template: `
   <div>
    <p>e: {{e | number:'3.4-5'}}</p>
    <p>pi: {{pi | number:'3.1-5'}}</p>
  </div>
  `，
})
export class AppComponent { 
  e: number = 2.718281828459045;
  pi: number = 33456;
}
{% endraw %}
```
例子结果为：

```
e: 002.71828    
pi: 33，456.0
```
对于变量e进行数值本地格式化的参数为“3.4-5”，参数`.`之前的3表示整数位最少保留3位，原数值整数位为1位，不足3位，以前置0填充，填充后整数位为“002”。参数`.`后面的`4-5`表示最小保留分数位为4位，最大保留分数位为5位，因原始数据分数位大于5位，最大保留5位限制发挥作用，经四舍五入后分数位为“71828”。

对于变量pi进行数值本地格式化的参数为“3.1-5”，参数`.`之前的3表示整数位最少保留3位，原数值整数位为5位，大于3位，不需添加前缀0，直接本地化格式后整数位为“33，456”。参数`.`后面的`1-5`表示最大保留分数位为5位，最小保留分数位为1位，因原始数据分数位数为0，因此最小保留1位限制发挥作用，分位补一个0，最终格式化的值为“33，456.0”。

**CurrencyPipe**

`CurrencyPipe` 将数值转成本地货币格式，用法如下：

```
expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]
```
currencyCode为`ISO 4217`货币码，如`CNY`为人民币、`USD`为美元、`EUR`为欧元。symbolDisplay为布尔值，true表示显示货币符号，如`¥`、`$`等 ， false表示显示`ISO 4217`货币码。digitInfo详情可查看`DecimalPipe`的digitInfo格式说明。

```
@Component({
  selector: 'my-app'，
  template: `<div>
    <p>A: {{a | currency:'USD':false}}</p>
    <p>B: {{b | currency:'USD':true:'4.2-2'}}</p>
  </div>`
})
export class AppComponent {
  a: number = 0.259;
  b: number = 1.3495;
}   
```
结果为：

```
A: USD0.259
B: $0，001.35
```
例子中，变量a第一个参数为USD，表示转换成美元货币格式，第二个参数为false，货币前缀展示美元`ISO 4217`货币码。变量b第一个参数为USD，表示转换成美元货币格式，第二个参数为true，货币前缀展示美元货币符号，第三个前缀表示对货币数值进行数值本地化，整数位保留4位，不足4位添加前置0，整数位为"0，001"，分数位保留2到2位，原分数位为3位，保留2位进行四舍五入后分数位为“35”，因此解析后转换成货币格式为“$0，001.35”。

**PercentPipe**

`PercentPipe`将数值转换为本地格式百分比，用法如下：

```
expression | percent[:digitInfo]
```
digitInfo详情可查看`DecimalPipe`的digitInfo格式说明。

```js
@Component({
  selector: 'my-app'，
  template: `
   <div>
    <p>A: {{a | percent}}</p>
    <p>B: {{b | percent:'4.3-5'}}</p>
  </div>
  `，
})

export class AppComponent { 
  a: number = 0.259;
  b: number = 1.3495;
}
```
结果为：

```
A: 25.9%
B: 0，134.950%
```
例子中，变量a直接转换成百分比格式。变量首先经过百分比将小数点往右移动两位后变成134.95，然后进行数值本地化，整数位保留4位，不足4位添加前置0，整数位为"0，134"，分数位保留3到5位，因分数不足3位，添加后置0，分数位为“950”，因此解析后转换成百分比格式为“0，134.950%”。


**SlicePipe**

`SlicePipe` 将数组或者字符串裁剪成新子集，用法如下：

```
expression | slice:start[:end]
```
`SlicePipe`以JavaScript API`Array.prototype.slice()`及`String.prototype.slice()`的功能效果为基础，在模板管道中实现相同的功能。参数start和end为数组的索引，具体定义可参考JavaScript API`Array.prototype.slice()`及`String.prototype.slice()`的介绍。

```js
@Component({
  selector: 'my-app'，
  template: `
   <div>
   	  <h5>数组裁剪：</h5>
     <li *ngFor="let  i of collection | slice:1:3">list:{{i}}</li>
     <h5>字符串裁剪：</h5>
     <p>str[0:4]: '{{str | slice:0:4}}'</p>
  </div>
  `，
})
export class AppComponent { 
  collection: string[] = ['a'， 'b'， 'c'， 'd'];
  str: string = 'abcdefghij';
}
```
结果为：

```
数组裁剪：
  list:b
  list:c
字符串裁剪：
  str[0:4]: 'abcd'
```
上述例子中，实现了使用管道将数组及字符串进行裁剪。数组collection相当于执行了`collection.slice(1，3)`，从数组索引为1开始裁剪到数组索引为3之前止，所以裁剪出数组索引为1的值b和索引为2的值c，字符串裁剪同理。

**ReplacePipe**

`ReplacePipe ` 将符合一定规则的文本替换成其指定的文本，用法如下：

```
expression | replace:pattern:replacement
```
输入值expression可以为`String`字符串类型和`Number`数值类型，`Number`数值类型最后会强制转换为`String`字符串类型; 

参数pattern为匹配需被替换的文本，可为`String`字符串类型或者`RegExp`正则表达式，pattern最后会转换成`RegExp`正则表达式对象，因此在书写上注意特殊符号的转义。参数replacement为被替换成的文本，可为`String`字符串类型或者`Function`函数表达式。

```js
@Component({
  selector: 'my-app'，
  template: `
   <div>
     <p>'{{str | replace:"abc":"aaa-"}}'</p>
     <p>'{{str2 | replace:pattent:"-"}}'</p>
     <p>'{{str3 | replace:"/":"+"}}'</p>
  </div>
  `，
})
export class AppComponent { 
  str: string = 'abcabcabcabc';
  str2: string = '2016/06/24';
  str3: string = '(3*5)/(2-1)';
  pattent: RegExp = /\//g;
}
```
结果为：

```html
<p>'aaa-abcabcabc'</p>
<p>'2016-06-24'</p>
<p>'(3*5)+(2-1)'</p>
```
例子中字符串str相当于执行了`str.repalce('abc'，'aaa-')`将第一个"abc"替换成"aaa-"；字符串str2传人了一个正则对象，相当于执行了`str2.repalce(/\//g，'-')`将字符串str2中所有的"/"替换成“－”；str3相当于执行了`str3.repalce('/'，'+')`将第一个"/"替换成"+"；

`ReplacePipe`以JavaScript API`String.prototype.replace()`的功能效果为基础，实现了类似的功能，参数start和end的具体定义可参考JavaScript API`Array.prototype.slice()`及`String.prototype.slice()`的介绍。


### 3.6.2 自定义管道
虽然Angular提供了许多内置的管道指令，但是数据转换的格式各式各样，内置管道不能一一满足需求。Angular提供自定义管道功能，可根据业务场景自定义各式各样的数据转换需求。下面通过定义一个日期格式化的自定义管道来认识模板自定义管道。

#### 定义元数据

```
@Pipe({name: 'dateReform'})
```
通过`@Pipe`装饰器来告诉Angular这是一个管道类，`@Pipe`装饰器有一个name属性，用来指定管道名称。名称必须是有效的JavaScript标识符，这里命名为dateReform。
在使用`@Pipe`前必须引入`Pipe`组件，如下：

```
import { Pipe } from '@Angular/core';
```

#### 实现transform方法
自定义的管道必须继承类`PipeTransform`，在使用类`PipeTransform`前，需从`'@Angular/core'`中引入`PipeTransform`组件。同时自定义管道必需重载实现`PipeTransform`接口`transform`方法，方法接收一个输入参数，和若干可选参数，最后返回转换后的值，如下：

```
export class DateReform implements PipeTransform {
  transform(val:string， format:string):string {

    let date = new Date(val);
    let year = date.getFullYear() + '';
    let month = date.getMonth() + 1 + '';
    let day = date.getDate() + '';

    let yyyy = year;
    let MM = (month.length < 2 ? '0' : '') + month;
    let dd = (day.length < 2 ? '0' : '') + day;

    let result = '';
    switch(format) {
      case 'yyyy-MM-dd':
        result = [yyyy， MM， dd].join('-');
      break;
      case 'yyyyMMdd':
        result = [yyyy， MM， dd].join('');
      break;
      default:
        result = [yyyy， MM， dd].join('');
    }

    return result;
  }
}
```
例子中定义了一个名为`DateReform`的管道类，`DateReform`管道类继承类`PipeTransform`，`DateReform`管道`transform`方法接收一个需要转换的日期输入参数val，及一个可选代表日期格式的参数format，根据日期格式，将输入的日期进行格式话，最后返回转换后的日期字符串值，显示在视图中；若日期格式参数没有传人，则使用默认的日期格式对日期进行格式化，并返回显示在视图中。

####在模板中使用自定义管道
在组件模板中使用自定义管道，首先须引入自定义管道`DateReform`：

```
import {DateReform} from './dateReform.pipe';
```
接着定义组件，在组件中使用自定义管道：

```
@Component({
  selector: 'my-app'，
  pipes: [DateReform]，
  template: `
   <div>
    <p>
      日期: {{value | dateReform: "yyyy-MM-dd"}}
    </p>
  </div>
  `，
})
export class AppComponent { 
  value: number = new Date();
}
```
例子中使用自定义日期管道实现了将日期格式化为“年-月-日”的格式。在模板中使用管道，需组件`@Component`装饰器声明`pipes: [DateReform]`，告诉模板可以使用自定义管道`DateReform`，之后可以在模板中随意使用管道`DateReform`。

自定义管道和内置管道使用方式完全相同，不同的是使用前需将管道import进来，且必须在`@Component`装饰器的pipes数组里列出需使用的自定义管道。

####全局自定义管道
上文定义的`DateReform `日期管道，不仅会在当前页面使用，也会在其他页面使用。对于这类通用的自定义管道，每次使用前都需要在当前页面import管道，在`@Component`装饰器的pipes数组里列出使用的管道，比较繁琐。为了避免这种使用场景，Angular提供了全局自定义管道，供全局使用。

定义全局自定义管道需在根组件中注入自定义管道的服务。在启动应用入口页面引入自定义管道`DateReform`，同时从`'@Angular/core'`引入`bootstrap`、`provide`、`PLATFORM_PIPES`组件。

在启动应用入口页面依赖注入管道`DateReform`：

```js
bootstrap(AppComponent， [{provide: PLATFORM_PIPES， useValue: [DateReform]， multi:true}]);
```
使用`{provide: PLATFORM_PIPES， useValue: [DateReform]， multi:true}`注册日期格式提供器，在根组件上依赖注入`DateReform`提供器服务，它会在整个应用程序中被共享，详细关于提供器的内容，会在依赖注入章节讲解。
此时管道`DateReform`为全局自定义管道，像内置管道一样可以在任何组件中随意使用，且无需在定义组件前import `DateReform`管道，也无需在`@Component`装饰器的pipes数组里列出使用`DateReform`管道等，节省许多重复操作。使用代码如下：

```js
@Component({
  selector: 'my-app'，
  template: `
   <div>
    <p>
      日期: {{value | dateReform: "yyyy-MM-dd"}}
    </p>
  </div>
  `，
})
export class TestComponent { 
  value: number = new Date();
}
```

### 3.6.3 管道状态
Angular在每次点击、移动鼠标、定时器触发、服务器响应等事件后会执行数据绑定值变化检测，这会带来性能问题，因此如果我们使用管道，Angular会选择使用更简单、更快速的变化检测算法来提高性能。下面通过显示联系人的列表看看有管道时Angular是如何优化性能的。

无管道时，添加新联系人，实时更新联系人列表

```
@Component({
  selector: 'my-app'，
  template: `
  <input type="text" #box  (keyup.enter)="addContact(box.value); box.value=''"placeholder="输入联系人后回车添加">
  <div *ngFor="let contact of (contacts)">
    {{contact.name}}
  </div>
  `，
})
export class AppComponent { 
  contacts=[{name:'张三'}，{name:'李四'}];
  addContact(name:string) {
    this.contacts.push({name});
  }
}
```
上述例子中，在表单输入联系人后，回车触发addContact，通过push将新contact推入数组中，同时contacts数组数据被刷新显示到页面上，实现了在表单中输入一个联系人名称，在列表中实时显示更新后的联系人的列表的功能。

下面添加一个过滤`李`姓联系人的自定义管道SelectContactPipe，用于过滤出姓`李`的联系人，当添加新联系人，实时更新`李`姓联系人列表。SelectContactPipe自定义管道如下：

```
@Pipe({ name: 'selectContact' })
export class SelectContactPipe implements PipeTransform {
  transform(allContacts: Array) {
    return allContacts.filter(contact => contact.name.match("^李"));
  }
}
```
在组件模板中使用管道：

```
<div *ngFor="let contact of (contacts | selectContactPipe)">
{{contact.name}}
</div>
```
结果是添加的`李`姓联系人并不会实时显示在页面，因为Angular使用了一个忽略变更列表内部数据变化的检测算法对性能进行了优化。例子中使用`this.contacts.push(contact)`新增一个联系人，数组对象引用没有发生改变。所以从Angular角度来说，相同数组，不进入`SelectContactPipe`筛选管道，列表数据没有更新，页面不会实时显示更新的联系人。这个筛选管道是pure管道。

Angular管道有两种变化检测机制，分别对应两种类型的管道，pure管道和impure管道。其中pure是默认类型，接下来看看pure和impure两者的区别。

####Pure 管道
在 pure 管道，Angular只有在检测到输入值发生 pure 变更时才会进入pure管道执行`transform`方法触发数据变化，从而达到页面数据更新。pure 变更指的是基本数据类型String、Number、Boolean、Symbol等输入值的变化或对象Date、Array、Function、Object等引用的变化。

现以`DatePipe`日前管道为例，分别用字符串类型和Date对象类型作为输入值，对日期进行格式化。同时设定2秒的定时器，动态改变日期的月份，查看模板显示的效果。

```
@Component({
  selector: 'my-app'，
  template: `
   <div>
     <p>'{{date | date:"y-MM-dd HH:mm:ss EEEE"}}'</p>
      <p>'{{date2 | date:"y-MM-dd HH:mm:ss EEEE"}}'</p>
  </div>
  `，
})
export class AppComponent { 
  date: date = new Date('2016-06-08 20:05:08');
  date2: string = '2016-06-08 20:05:08';
  constructor() { 
    let self = this;
    setTimeout(function(){
      self.date.setMonth(12);
      self.date2 = '2016-12-08 20:05:08';
    }，2000);
  }
}
```
上述例子中，日期管道的输入值分别为一个日期对象和一个日期字符串，初始日期都为’2016-06-08 20:05:08‘，添加一个2秒的计时器，2秒时间后将日期月份变为12。最初显示为：

```
'2016-06-08 20:5:8 Wednesday'
'2016-06-08 20:5:8 Wednesday'
```

2秒后显示为：

```
'2016-06-08 20:5:8 Wednesday'
'2016-12-08 20:5:8 Thursday'
```
由显示的结果可以看出，在pure管道`date`中，输入为字符串基本类型日期时，当2秒计时完成后，日期字符串月份修改为12月，会执行日期管道`transform`方法，通过管道显示出来的日期也变为12月。而输入日期对象时，2秒计时完成后，直接修改日期对象的月份为12，日期对象的引用并没有发生改变，不会执行日期管道`transform`方法，因此通过管道显示出来的日期没有发生改变。

一个对象引用检查要比一个对象内部所有值的检查快得多，Angular为了能快速判断是否可以跳过管道执行和视图更新，会忽略对象内部的变化，这就是pure管道变化检测策略。因pure管道对象引用检测的受限，所以需要另一种管道的变化检测策略 impure 管道。

####Impure 管道
Angular每次组件变化检测周期时都会执行 impure 管道，每个按钮或鼠标移动时都会进入管道`transform`方法，执行管道处理。

以上述添加新联系人例子为例，在管道元数据里设置 pure 属性值为 false 可以定义 impure 类型管道。

```
@Pipe({ 
  name: 'selectContactPipe' ，
  pure: false
})
```
此例子添加pure: false 定义Impure管道。当新`李`姓联系人推入数组后，Impure管道在变化周期内都会去检测执行`SelectContactPipe`管道的“transform”方法，对变化后的联系人列表进行过滤，因此联系人列表数据会同步到模板视图中。

####Impure异步管道

在Angular内置管道指令中，还有一个有趣的管道`AsyncPipe`。`AsyncPipe`是Impure异步管道，接收的是 Promise 或 Observable 对象作为输入值，并自己订阅它，最终返回产生的值。

```
import { Component } from '@Angular/core';
import { Observable } from 'rxjs/Rx';
@Component({
  selector: 'my-app'，
  template: `
    <p>时间: {{ time | async }}</p>
  `，
})
export class AppComponent {
  contacts: Observable<string>;
  constructor() { this.getObservableTime(); }
  getObservableTime() {
    this.time = new Observable<number>((observer: Subscriber<number>) => {
      setInterval(() => observer.next(new Date().toLocaleString())， 1000);
    });
  }; 
}
```
这个例子，使用`AsyncPipe`管道把一个时间字符串 time 的 Observable 绑定到视图中，通过异步管道实现了每隔一秒，时间切换的时钟效果。

除了`AsyncPipe`是异步管道之外，`SlicePipe`与`JsonPipe`也是异步管道，具体可看表2.3-8。

表 2.3-8 内置管道类型总结

| 管道           | 类型   | 功能   |
|------------   |:------:|:------:| 
| DatePipe      | pure   | 日期管道，格式化日期 
| UpperCasePipe | pure   | 将文本所有小写字母转成大写字母
| LowerCasePipe | pure   | 将文本所有大写字母转成小写字母
| DecimalPipe   | pure   | 将数值按特定的格式显示的文本
| CurrencyPipe  | pure   | 将数值转成本地货币格式
| PercentPipe   | pure   | 将数值转百分比格式
| ReplacePipe   | pure   | 将符合一定规则的文本替换成其指定的文本
| SlicePipe     | impure | 将数组或者字符串裁剪成新子集
| AsyncPipe     | impure | 异步管道，输入值为 Promise 或 Observable 对象，并订阅该对象，返回产生的值
| JsonPipe      | impure | 将输入数据对象经过`JSON.stringify`转换后输出对象字符串


####Pure管道和pure 函数
pure函数是指在处理输入并返回结果时，不会产生任何副作用的函数。 Pure管道使用Pure函数，给定相同的输入，它们总是返回相同的输出。一个pure管道必须总是用pure函数实现。在本章前面见过的管道都是用pure函数实现的。
 
## 3.7 模板表达式操作符

模板表达式语言是使用了Javascript语法的一个子集，并补充了几个用于特定场景的特殊操作符。在之前管道部分的管道操作符（|）就是其中之一，接下来看一下安全导航操作符（?.）。
为了消除因为属性路径中null和undefined而导致页面渲染失败甚至程序崩溃，Angular的安全导航操作符（?.）绝对是一种流畅而便利的方式。如下所示，`title`属性值为空，页面仍会被渲染，但是显示的值为空；只能看到“标题是”，后面没有任何东西。这是合理的，至少程序没有崩溃。

```HTML
标题是{{title}}
```

但假设模板表达式需要一个属性路径，比如要显示子标题的第一个字符：

```HTML
标题的第一个字符是{{subtitle.firstString}}
```

如果`subtitle`为null，Javascript就会抛出一个空引用的错误，Angular也是如此：

```JAVASCRIPT
TypeError: Cannot read property 'firstString' of null in [null].
```

这时你会发现，整个页面不见了。如果确信firstString属性永远不可能为空，程序可以这么去写。如果它必须不能为空，但它仍然会是空值，你就制造了一个编程错误。另一方面，属性路径中空值可能随时发生。
当等待数据的时候，视图渲染器应该把空属性路径显示为空白，就像上面`title`属性所做的那样，但不幸的是，当`subtitle`为空的时候，程序已经崩溃了。此时，可以通过NgIf来解决这个问题。如：

```HTML
<div *ngIf="nullUser">空联系人的名字是{{nullUser.firstName}}</div>
```

也可以通过`&&`来把属性路径的各个部分串起来，让它在遇到第一个空值的时候就返回空，如：

```HTML
空联系人的名字是{{nullUser && nullUser.firstName}}
```

这两种方法都可行，但有些笨重，特别是当这个属性路径非常长的时候，比如a.b.c.d。Angular安全导航操作符(?.)是一种更加流畅和便利的方法。表达式在它遇到第一个空值的时候会跳出。显示是空的，程序正常工作，而没有发生错误。如：

```HTML
空联系人的名字是{{nullUser?.firstName}}
```

在像a?.b?.c?.d的长属性路径中，将会更加完美。



### 本章小节
本章着重介绍了模板相关语法，以及与模板相关的表单、管道等，下面将从模板语法、表单、管道三个维度总结如下：

#### 模板语法
本章模板语法主要介绍了插值、数据绑定、模板引用变量、内置指令等，涵盖的主要内容有：

1、模板表达式和模板声明的上下文都不能引用全局命名空间的成员，而只能引用其上下文环境的成员变量，书写的时候要注意无副作用、高效执行、足够简单和幂等性优先的原则。
2、在Angular中，数据绑定是作用在DOM对象属性和事件上，而不是HTML标签特性上。
3、通过插值、属性绑定和事件绑定的方式可以实现数据的单向以及双向绑定
4、指令可以通过EventEmitter来自定义事件，通过$event可以传递有关这个事件包括数据值在内的信息
5、通过属性绑定可以改变输入属性，通过事件绑定可以描述输出属性
6、通过输入属性数据流入了指令，通过输出属性数据流出了指令
7、数据绑定中目标属性为字符串值、字符串是固定的值或初始值永不改变时可以省略中括号，其余切记不要忘记中括号
8、模板引用变量的定义及NgForm和模板引用变量的关系
9、介绍了NgClass、NgStyle、NgIf、NgSwitch和NgFor五个内置指令。

#### 表单
本章表单部分主要涵盖的内置指令、表单状态追踪、表单检验及表单双向数据绑定，关键点有：

1、表单提供`ngForm` 、`ngModel` 、`ngModelGroup` 、`ngSubmit`等内置表单指令，实现表单数据修改、双向数据绑定、校验、提交等功能。</br>
2、表单加入ngModel及name属性后，可以根据valid、pristine、dirty、touched、untouched等值进行表单状态跟踪及校验。</br>
3、表单加入ngModel及name属性后，用户对表单的操作状态，同时会通过表单状态类体现出来。可以通过ng-touched、ng-untouched、ng-dirty、ng-pristine、ng-valid、ng-invalid等表单状态类，自定义表单在不同状态下的样式。</br>
4、表单内置验证包括required、minlength、maxlength、pattern，表单提交时，可以通过valid检测校验合法性。</br>
5、表单通过`FormBuilder`构建表单的方式添加自定义校验。如果想添加多个校验，可以使用Validators.compose。</br>


#### 管道
本章管道主要涵盖Angular的内置管道指令用法、自定义管道、全局自定义管道及管道状态，关键点有：

1、管道通过管道符号`|`声明使用，`|`符号后接管道名pipeName即可使用管道，同时可通过`:`冒号给管道传入参数。</br>
2、Angular支持链式管道，多个管道之间同样以`|`符号分割，形成链式管道，模板最后输出的是多个管道作用后的结果。</br>
3、Angular提供许多内置管道，如日期格式化管道、文本转换大写管道、文本转换小写管道、数值格式化管道、货币格式化管道、百分比格式化管道、文本替换管道、数组或字符串裁剪管道、异步管道、Json格式化管道。</br>
4、Angular提供自定义管道，管道可以在该组件模板中局部范围内使用。同时Angular提供自定义全局管道，自定义全局管道可以在所有的组件模板中使用。</br>
5、Angular管道分为pure及impure管道，pure管道只有在基本数据类型String、Number、Boolean、Symbol等输入值的变化或者对象Date、Array、Function、Object等引用发生改变时才执行管道处理。impure管道是在组件变化检测周期时都会执行管道处理。</br>
