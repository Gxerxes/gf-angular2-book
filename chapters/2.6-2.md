# 6.3 service注入service
大型系统中service之间的通讯跟调用是很常见的，每个service各司其职，提供对外接口供第三方调用，回到通讯录列表的例子中，当底层服务异常的时候想记录下错误信息，这就需要一个单独的log服务来帮忙，譬如下面的简单版实现，把log信息打印到console平台

	import { Injectable } from '@angular/core';
	
	@Injectable()
	export class Logger {
	  logs:string[] = [];
	  log(message: string){
	    this.logs.push(message);
	    console.log(message);
	  }
	}
注意@Injectable()这里，这个注解是必须的，它告诉Angular2这是一个可注入的服务，意味着其它service可以直接在构造函数里面注入了，下面是具备log功能的ContractServices。

	import {Injectable} from '@angular/core';
	import {CONTACTS}     from './mock-contact';
	import {Logger}     from './log';
	
	@Injectable()
	export class ContactService {
	  constructor(private logger: Logger) {  }
	
	  getContact(id: number) {
	    return Promise.resolve(CONTACTS).then(
	        heroes => heroes.filter(hero => hero.id === id)[0]
	    );
	  }
	
	  getCollections() {
      this.logger.log('Getting contracts ...');
	   return Promise.resolve(CONTACTS).then(
	       heroes => heroes.filter(hero => hero.collection === 1)
	   )
	  }
	}
同时，还需要注册**provider**到组件中使得Angular2能够创建具体的实例并注入到ContractServices中，考虑Logger这种通用的服务应该是系统级别通用的，在根组件注入是更很合适，这样整个系统都可以共有。在contract-app.ts中，增加对Logger到provider数组中
```
providers: [Logger]
```
关于注入选择的本章后面会详细介绍层级注入，此时，service注入到另一个service的实现就完成了。
需要讨论的是什么时候class才需要@Injectable()？Angular2推荐任何情况下都使用这个注解，一方面任何class都有可能被inject，即使现在看起来并不需要。另一方面，这也是一种好的团队协作约定，使用的时候无需去关注service是否可inject这个问题。


# 6.4 Provider
provider在前后台各种技术领域都被广泛使用，从古老.Net的MembershipProvider，Hibernate的ConnectionProvider，到Android的ContentProvider，Angualr2版本的Provider，虽然实现过程不尽相同，但核心概念都类似，**Provider**作为封装了逻辑操作或数据操作的提供者，提供了接口或数据供调用方使用，相比接口继承实现模式,**Provider**模式提供了更多的可扩展性和灵活性。  
在Angular2中，注入器的依赖项总是一个**Provider**对象，考虑到平常使用的场景大多是类作为提供者，框架会自动把**类**名转为**Provider**对象，上面在在contract-app.ts中注册的Logger服务，只需要简单的往组件元数据的**providers**数组中添加Logger服务  

	providers: [Logger]

这种语法糖等同于

	providers: [new Provider(Logger,{useClass:Logger})] 
	
Angular2自动帮我们根据类名生成了Provider对象，实际上还有其它生成Provider的方法，用provider函数构造
	
	[provide(Logger, {useClass: Logger})]
或者用对象描述的方式，省去provider方法

	[provide(Logger, {useClass: Logger})]
这几种方式都包含两个参数，第一个是令牌（token），作为键值（key）提供了注入的唯一标识，第二个参数是用于指定Provider生成的对象，有若干种方式来生成。

# 6.5 层级注入
## angular组件树，引入层级注入概念
Angular2的开发模式以组件为基础，开发中自然而然形成层层组件的嵌套，这种组织关系的形状跟提起一串葡萄很类似，一个根组件下面是各层级的子组件，依赖注入就像葡萄籽，可以出现在任何层级的任何组件中，每个组件（葡萄）可以拥有一个或多个的注入，每个注入对于每个**注入器（injector）**而言都是**单例（singleton）**。


> 实际上，每个组件都有独立的injector，由这个injector创建的provider都是单例，这是组件级别的单例，跟Angular1.x不一样，有1.x开发经验的读者会更有体会。

## 注入的查找过程 配图
前面提到注入可以发生在整棵组件树的任一层级，并在创建的injector维持单例，更进一步，依赖注入可以传递到子孙组件中去，层层传递，子组件可以直接享用父组件中注入的实例，无须自己再创建，如果有多个，这些后代（子孙）组件也都共用这个实例。

``` javascript
class Random{
	constructor(){
		this.num = +new Date();
		console.log("random number... " + this.num);
	}
};

@Component({
	selector:"sub-a",
	providers:[Random],
	template:"<div>subA : {{ random.num }}</div>",
})
class SubA{
	constructor(@Inject(Random) r){
		this.random = r;
    	console.log("SubA is..." + r.num);
	}
}

@Component({
	selector:"sub-b",
	providers:[Random],
	template:"<div>subB : {{ random.num }}</div>"
})
class SubB{
	constructor(@Inject(Random) r){
    	this.random = r;
		console.log("SubB is ..." + r.num);
	}
}

@Component({
	selector:"app",
	template : `
		<h1>APP</h1>
		<sub-a></sub-a>
		<sub-b></sub-b>
	`,
	directives:[SubA,SubB]
})
class App{
	constructor(){}
}

```
结果将输出：
subA : 0.6594064461255684
subB : 0.9344545328845055

这说明了每个子组件都有自己的实例，如果我们稍微把组件的注解部分改下，把注入提升到父组件中，代码如下

``` javascript
@Component({
	selector:"sub-a",
	template:"<div>subA : {{ random.num }}</div>",
})

@Component({
	selector:"sub-b",
	template:"<div>subB : {{ random.num }}</div>"
})

@Component({
	selector:"app",
	template : `
		<h1>APP</h1>
		<sub-a></sub-a>
		<sub-b></sub-b>
	`,
	providers:[Random],
    directives:[SubA,SubB]
})
```
此时结果变成：
subA : 0.027503783541033888
subB : 0.027503783541033888

这说明子组件共用了父组件的实例。

另一个问题，Angualr2是如何查找到合适的实例的呢？在组件的构造函数试图注入某个token的时候，Angular2会先从当前的注入器（injector）查找，找不到就继续往父组件查找，直到根组件，最后查找App.bootstrap,此时找不到的话就报错了。这种树形的从子孙往上查找直到根节点的设计在计算机里很常见，面向对象里获取某个子类的属性，同样是往父类层层查找直到根对象Object，在JavaScript里的原型链继承同样如此。
![](media/14658674688748/14660433159079.jpg)￼
￼
> Angular2这种灵活设计引申了另一个问题，什么时候在根组件注入，什么时候在子组件注入?每个依赖注入总是维护单例，因此如果全局性，不需要针对每个组件维护单例的场景，可以直接在根组件注入，整个组件树共享，像Log，Util等，如果需要针对每个组件创建不同的实例，就应该在子组件中注入，考虑通讯录的例子.

#6.6 总结

在本章中我们介绍了依赖注入的基本概念，重点剖析了Angular2的依赖注入以及它的一个重要概念Providers的五种注入形式，最后通过例子说明了Angular中如何使用依赖注入，主要包括三部分：组件中注入Service、service中注入service和层级注入的使用。

通过本章的学习，对依赖注入是什么以及Angular2中如何使用依赖注入有了一个清晰的认识，下一章中，将探索Angular2的路由、子路由和路由的生命周期。

