# 6.3 service注入service
大型系统中service之间的通讯跟调用是很常见的，每个service各司其职，提供对外接口供第三方调用，回到通讯录列表的例子中，当底层服务异常的时候想记录下错误信息，这就需要一个单独的log服务来帮忙，譬如下面的简单版实现，把log信息打印到console平台

	import { Injectable } from '@angular/core';
	
	@Injectable()
	export class Logger {
	  logs:string[] = [];
	  log(message: string){
	    this.logs.push(message);
	    console.log(message);
	  }
	}
注意@Injectable()这里，这个注解是必须的，它告诉Angular2这是一个可注入的服务，意味着其它service可以直接在构造函数里面注入了，下面是具备log功能的ContractServices。

	import {Injectable} from '@angular/core';
	import {CONTACTS}     from './mock-contact';
	import {Logger}     from './log';
	
	@Injectable()
	export class ContactService {
	  constructor(private logger: Logger) {  }
	
	  getContact(id: number) {
	    return Promise.resolve(CONTACTS).then(
	        heroes => heroes.filter(hero => hero.id === id)[0]
	    );
	  }
	
	  getCollections() {
      this.logger.log('Getting contracts ...');
	   return Promise.resolve(CONTACTS).then(
	       heroes => heroes.filter(hero => hero.collection === 1)
	   )
	  }
	}
同时，还需要注册**provider**到组件中使得Angular2能够创建具体的实例并注入到ContractServices中，考虑Logger这种通用的服务应该是系统级别通用的，在根组件注入是更很合适，这样整个系统都可以共有。在contract-app.ts中，增加对Logger到provider数组中
```
providers: [Logger]
```
关于注入选择的本章后面会详细介绍层级注入，此时，service注入到另一个service的实现就完成了。
需要讨论的是什么时候class才需要@Injectable()？Angular2推荐任何情况下都使用这个注解，一方面任何class都有可能被inject，即使现在看起来并不需要。另一方面，这也是一种好的团队协作约定，使用的时候无需去关注service是否可inject这个问题。


# 6.4 Provider
provider在前后台各种技术领域都被广泛使用，从古老.Net的MembershipProvider，Hibernate的ConnectionProvider，到Android的ContentProvider，Angualr2版本的Provider，虽然实现过程不尽相同，但核心概念都类似，**Provider**作为封装了逻辑操作或数据操作的提供者，提供了接口或数据供调用方使用，相比接口继承实现模式,**Provider**模式提供了更多的可扩展性和灵活性。  
在Angular2中，注入器的依赖项总是一个**Provider**对象，考虑到平常使用的场景大多是类作为提供者，框架会自动把**类**名转为**Provider**对象，上面在在contract-app.ts中注册的Logger服务，只需要简单的往组件元数据的**providers**数组中添加Logger服务  

	providers: [Logger]

这种语法糖等同于

	providers: [new Provider(Logger,{useClass:Logger})] 
	
Angular2自动帮我们根据类名生成了Provider对象，实际上还有其它生成Provider的方法，用provider函数构造
	
	[provide(Logger, {useClass: Logger})]
或者用对象描述的方式，省去provider方法

	[provide(Logger, {useClass: Logger})]
这几种方式都包含两个参数，第一个是令牌（token），作为键值（key）提供了注入的唯一标识，第二个参数是用于指定Provider生成的对象，有若干种方式来生成。

